{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCacheData = exports.Common = exports.BUNDLER_NODES = exports.arweave = void 0;\n\nconst axios_1 = __importDefault(require(\"axios\"));\n\nconst arweave_1 = __importDefault(require(\"arweave\"));\n\nconst arweaveUtils = __importStar(require(\"arweave/node/lib/utils\"));\n\nconst smartweave_1 = require(\"smartweave\");\n\nconst query_1 = require(\"@kyve/query\"); //@ts-ignore // Needed to allow implicit any here\n\n\nconst human_crypto_keys_1 = require(\"human-crypto-keys\"); //@ts-ignore\n\n\nconst pem_jwk_1 = require(\"pem-jwk\");\n\nconst HOST_GATEWAY = \"arweave.net\";\nconst URL_ARWEAVE_INFO = `https://${HOST_GATEWAY}/info`;\nconst URL_ARWEAVE_GQL = `https://${HOST_GATEWAY}/graphql`;\nconst BLOCK_TEMPLATE = `\n  pageInfo {\n    hasNextPage\n  }\n  edges {\n    cursor\n    node {\n      id anchor signature recipient\n      owner { address key }\n      fee { winston ar }\n      quantity { winston ar }\n      data { size type }\n      tags { name value }\n      block { id timestamp height previous }\n      parent { id }\n    }\n  }`;\nexports.arweave = arweave_1.default.init({\n  host: HOST_GATEWAY,\n  protocol: \"https\",\n  port: 443\n});\nexports.BUNDLER_NODES = \"/nodes\";\n/**\n * Tools for interacting with the koi network\n */\n\nclass Common {\n  constructor(bundlerUrl = \"https://bundler.openkoi.com:8888\", contractId = \"cETTyJQYxJLVQ6nC3VxzsZf1x2-6TW2LFkGZa91gUWc\") {\n    this.bundlerUrl = bundlerUrl;\n    this.contractId = contractId;\n    console.log(\"Initialized Koii Tools for true ownership and direct communication using version \", this.contractId);\n  }\n  /**\n   * Generates wallet optionally with a mnemonic phrase\n   * @param use_mnemonic [false] Flag for enabling mnemonic phrase wallet generation\n   */\n\n\n  async generateWallet(use_mnemonic = false) {\n    let key, mnemonic;\n\n    if (use_mnemonic === true) {\n      mnemonic = await this._generateMnemonic();\n      key = await this._getKeyFromMnemonic(mnemonic);\n    } else key = await exports.arweave.wallets.generate();\n\n    if (!key) throw Error(\"failed to create wallet\");\n    this.mnemonic = mnemonic;\n    this.wallet = key;\n    await this.getWalletAddress();\n    return true;\n  }\n  /**\n   * Loads arweave wallet\n   * @param source object to load from, JSON or JWK, or mnemonic key\n   */\n\n\n  async loadWallet(source) {\n    switch (typeof source) {\n      case \"string\":\n        this.wallet = await this._getKeyFromMnemonic(source);\n        break;\n\n      default:\n        this.wallet = source;\n    }\n\n    await this.getWalletAddress();\n    return this.wallet;\n  }\n  /**\n   * Manually set wallet address\n   * @param walletAddress Address as a string\n   * @returns Wallet address\n   */\n\n\n  setWallet(walletAddress) {\n    if (!this.address) this.address = walletAddress;\n    return this.address;\n  }\n  /**\n   * Uses koi wallet to get the address\n   * @returns Wallet address\n   */\n\n\n  async getWalletAddress() {\n    if (typeof this.address !== \"string\") this.address = await exports.arweave.wallets.jwkToAddress(this.wallet);\n    return this.address;\n  }\n  /**\n   * Get and set arweave balance\n   * @returns Balance as a string if wallet exists, else undefined\n   */\n\n\n  async getWalletBalance() {\n    if (!this.address) return 0;\n    const winston = await exports.arweave.wallets.getBalance(this.address);\n    const ar = exports.arweave.ar.winstonToAr(winston);\n    return parseFloat(ar);\n  }\n  /**\n   * Gets koi balance from cache\n   * @returns Balance as a number\n   */\n\n\n  async getKoiBalance() {\n    const state = await this.getContractState();\n    if (this.address !== undefined && this.address in state.balances) return state.balances[this.address];\n    return 0;\n  }\n  /**\n   * Gets the current contract state\n   * @returns Current KOI system state\n   */\n\n\n  getContractState() {\n    return this._readContract();\n  }\n  /**\n   * Get contract state\n   * @param id Transaction ID\n   * @returns State object\n   */\n\n\n  async getTransaction(id) {\n    return exports.arweave.transactions.get(id);\n  }\n  /**\n   * Get block height\n   * @returns Block height maybe number\n   */\n\n\n  async getBlockHeight() {\n    const info = await getArweaveNetInfo();\n    return info.data.height;\n  }\n  /**\n   * Get the NFT state from arweave, this should be the initial state\n   * @param txId Transaction ID of the NFT\n   * @returns The NFT state object\n   */\n\n\n  async readNftState(txId) {\n    try {\n      const response = await axios_1.default.get(`https://bundler.openkoi.com:8888/state/getNFTState?tranxId=${txId}`);\n      return response.data;\n    } catch (err) {\n      console.log(\"ERRPR\", err);\n      if (err) console.error('error fetching NFT data from bundler for ' + txId);\n      return smartweave_1.smartweave.readContract(exports.arweave, txId);\n    }\n  }\n  /**\n   * Interact with contract to stake\n   * @param qty Quantity to stake\n   * @returns Transaction ID\n   */\n\n\n  stake(qty) {\n    if (!Number.isInteger(qty)) throw Error('Invalid value for \"qty\". Must be an integer');\n    const input = {\n      function: \"stake\",\n      qty: qty\n    };\n    return this._interactWrite(input);\n  }\n  /**\n   * Interact with contract to withdraw\n   * @param qty Quantity to transfer\n   * @returns Transaction ID\n   */\n\n\n  withdraw(qty) {\n    if (!Number.isInteger(qty)) throw Error('Invalid value for \"qty\". Must be an integer');\n    const input = {\n      function: \"withdraw\",\n      qty: qty\n    };\n    return this._interactWrite(input);\n  }\n  /**\n   * Interact with contract to transfer koi\n   * @param qty Quantity to transfer\n   * @param target Receiver address\n   * @returns Transaction ID\n   */\n\n\n  async transfer(qty, target, token) {\n    const input = {\n      function: \"transfer\",\n      qty: qty,\n      target: target\n    };\n\n    switch (token) {\n      case \"AR\":\n        {\n          const transaction = await exports.arweave.createTransaction({\n            target: target,\n            quantity: exports.arweave.ar.arToWinston(qty.toString())\n          }, this.wallet);\n          await exports.arweave.transactions.sign(transaction, this.wallet);\n          await exports.arweave.transactions.post(transaction);\n          return transaction.id;\n        }\n\n      case \"KOI\":\n        {\n          const txid = await this._interactWrite(input);\n          return txid;\n        }\n\n      default:\n        {\n          throw Error(\"token or coin ticker doesn't exist\");\n        }\n    }\n  }\n  /**\n   * Mint koi\n   * @param arg object arg.targetAddress(receiver address) and arg.qty(amount to mint)\n   * @returns Transaction ID\n   */\n\n\n  mint(arg) {\n    const input = {\n      function: \"mint\",\n      qty: arg.qty,\n      target: arg.targetAddress\n    };\n    return this._interactWrite(input);\n  }\n  /**\n   * Interact with contract to register data\n   * @param txId It has batchFile/value(string) and stake amount/value(int) as properties\n   * @param ownerId String container the owner ID\n   * @returns Transaction ID\n   */\n\n\n  registerData(txId, ownerId = \"\") {\n    const input = {\n      function: \"registerData\",\n      txId: txId,\n      owner: ownerId\n    };\n    return this._interactWrite(input);\n  }\n  /**\n   * Sign transaction\n   * @param tx Transaction to be signed\n   * @returns signed Transaction\n   */\n\n\n  async signTransaction(tx) {\n    try {\n      //const wallet = this.wallet;\n      // Now we sign the transaction\n      await exports.arweave.transactions.sign(tx, this.wallet); // After is signed, we send the transaction\n      //await exports.arweave.transactions.post(transaction);\n\n      return tx;\n    } catch (err) {\n      return null;\n    }\n  }\n  /**\n   * Get transaction data from Arweave\n   * @param txId Transaction ID\n   * @returns Transaction\n   */\n\n\n  nftTransactionData(txId) {\n    return exports.arweave.transactions.get(txId);\n  }\n  /**\n   * Sign payload\n   * @param payload Payload to sign\n   * @returns Signed payload with signature\n   */\n\n\n  async signPayload(payload) {\n    if (this.wallet === undefined) return null;\n    const data = payload.data || payload.vote || null;\n    const jwk = this.wallet;\n    const publicModulus = jwk.n;\n    const dataInString = JSON.stringify(data);\n    const dataIn8Array = arweaveUtils.stringToBuffer(dataInString);\n    const rawSignature = await exports.arweave.crypto.sign(jwk, dataIn8Array);\n    payload.signature = arweaveUtils.bufferTob64Url(rawSignature);\n    payload.owner = publicModulus;\n    return payload;\n  }\n  /**\n   * Verify signed payload\n   * @param payload\n   * @returns Verification result\n   */\n\n\n  async verifySignature(payload) {\n    const data = payload.data || payload.vote || null;\n    const rawSignature = arweaveUtils.b64UrlToBuffer(payload.signature);\n    const dataInString = JSON.stringify(data);\n    const dataIn8Array = arweaveUtils.stringToBuffer(dataInString);\n    return await exports.arweave.crypto.verify(payload.owner, dataIn8Array, rawSignature);\n  }\n  /**\n   * Posts data to Arweave\n   * @param data\n   * @returns Transaction ID\n   */\n\n\n  async postData(data) {\n    // TODO: define data interface\n    const wallet = this.wallet;\n    const transaction = await exports.arweave.createTransaction({\n      data: Buffer.from(JSON.stringify(data, null, 2), \"utf8\")\n    }, wallet); // Now we sign the transaction\n\n    await exports.arweave.transactions.sign(transaction, wallet);\n    const txId = transaction.id; // After is signed, we send the transaction\n\n    const response = await exports.arweave.transactions.post(transaction);\n    if (response.status === 200) return txId;\n    return null;\n  }\n  /**\n   * Gets all the transactions where the wallet is the owner\n   * @param wallet Wallet address as a string\n   * @param count The number of results to return\n   * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n   * @returns Object with transaction IDs as keys, and transaction data strings as values\n   */\n\n\n  getOwnedTxs(wallet, count, cursorId) {\n    const countStr = count !== undefined ? `, first: ${count}` : \"\";\n    const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n    const query = `\n      query {\n        transactions(owners:[\"${wallet}\"]${countStr}${afterStr}) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n    const request = JSON.stringify({\n      query\n    });\n    return this.gql(request);\n  }\n  /**\n   * Gets all the transactions where the wallet is the recipient\n   * @param wallet Wallet address as a string\n   * @param count The number of results to return\n   * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n   * @returns Object with transaction IDs as keys, and transaction data strings as values\n   */\n\n\n  getRecipientTxs(wallet, count, cursorId) {\n    const countStr = count !== undefined ? `, first: ${count}` : \"\";\n    const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n    const query = `\n      query {\n        transactions(recipients:[\"${wallet}\"]${countStr}${afterStr}) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n    const request = JSON.stringify({\n      query\n    });\n    return this.gql(request);\n  }\n  /**\n   * Get the updated state of an NFT\n   * @param contentTxId TxId of the content\n   * @param state\n   * @returns An object with {totaltViews, totalReward, 24hrsViews}\n   */\n\n\n  async contentView(contentTxId, state) {\n    const rewardReport = state.stateUpdate.trafficLogs.rewardReport;\n\n    try {\n      const nftState = await this.readNftState(contentTxId);\n      const contentViews = { ...nftState,\n        totalViews: 0,\n        totalReward: 0,\n        twentyFourHrViews: 0,\n        txIdContent: contentTxId\n      };\n      rewardReport.forEach(ele => {\n        const logSummary = ele.logsSummary;\n\n        for (const txId in logSummary) {\n          if (txId == contentTxId) {\n            if (rewardReport.indexOf(ele) == rewardReport.length - 1) {\n              contentViews.twentyFourHrViews = logSummary[contentTxId];\n            }\n\n            const rewardPerAttention = ele.rewardPerAttention;\n            contentViews.totalViews += logSummary[contentTxId];\n            const rewardPerLog = logSummary[contentTxId] * rewardPerAttention;\n            contentViews.totalReward += rewardPerLog;\n          }\n        }\n      });\n      return contentViews;\n    } catch (err) {\n      return null;\n    }\n  }\n  /**\n   * Get a list of all NFT IDs\n   * @returns Array of transaction IDs which are registered NFTs\n   */\n\n\n  async retrieveAllRegisteredContent() {\n    const state = await this.getContractState();\n    const registerRecords = state.registeredRecord;\n    const txIdArr = Object.keys(registerRecords);\n    return txIdArr;\n  }\n  /**\n   * Get a list of NFT IDs by owner\n   * @param owner Wallet address of the owner\n   * @returns Array containing the NFTs\n   */\n\n\n  async getNftIdsByOwner(owner) {\n    const state = await this.getContractState();\n    const nfts = [];\n\n    for (const nft in state.registeredRecord) if (state.registeredRecord[nft] === owner) nfts.push(nft);\n\n    return nfts;\n  }\n  /**\n   * Get Koi rewards earned from an NFT\n   * @param txId The transaction id to process\n   * @returns Koi rewards earned or null if the transaction is not a valid Koi NFT\n   */\n\n\n  async getNftReward(txId) {\n    const state = await this.getContractState();\n    if (!(txId in state.registeredRecord)) return null;\n    const nft = await this.contentView(txId, state);\n    return nft.totalReward;\n  }\n  /**\n   * Query Arweave using GQL\n   * @param request Query string\n   * @returns Object containing the query results\n   */\n\n\n  async gql(request) {\n    const {\n      data\n    } = await axios_1.default.post(URL_ARWEAVE_GQL, request, {\n      headers: {\n        \"content-type\": \"application/json\"\n      }\n    });\n    return data;\n  }\n  /**\n   * Gets an array of service nodes\n   * @param url URL of the service node to retrieve the array from a known service node\n   * @returns Array of service nodes\n   */\n\n\n  async getNodes(url = this.bundlerUrl) {\n    const res = await getCacheData(url + exports.BUNDLER_NODES);\n\n    try {\n      return JSON.parse(res.data);\n    } catch (_e) {\n      return [];\n    }\n  }\n  /**\n   * Gets the list of all KIDs(DIDs)\n   * @param count The number of results to return\n   * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n   * @returns {Array} - returns a Javascript Array of object with each object representing a single KID\n   */\n\n\n  async getAllKID(count, cursorId) {\n    const countStr = count !== undefined ? `, first: ${count}` : \"\";\n    const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n    const query = `\n    query {\n      transactions(tags: {\n        name: \"Action\",\n        values: [\"KID/Create\"]\n    }${countStr}${afterStr}) {\n        ${BLOCK_TEMPLATE}\n      }\n    }`;\n    const request = JSON.stringify({\n      query\n    });\n    let gqlResp = await this.gql(request);\n\n    if (gqlResp && gqlResp.data.transactions.edges) {\n      return gqlResp.data.transactions.edges;\n    }\n\n    return {\n      message: \"No KIDs Found\"\n    };\n  }\n  /**\n     * Get the KID state for the particular walletAddress\n     * @param walletAddress The wallet address for the person whose DID is to be found\n     * @returns {Object} - returns a contract object having id which can be used to get the state\n     */\n\n\n  async getKIDByWalletAddress(walletAddress) {\n    const query = `\n      query {\n        transactions(tags: [{\n          name: \"Action\",\n          values: [\"KID/Create\"]\n      },\n        {\n          name: \"Wallet-Address\",\n          values: [\"${walletAddress}\"]\n      }\n      ]) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n    const request = JSON.stringify({\n      query\n    });\n    let gqlResp = await this.gql(request);\n\n    if (gqlResp && gqlResp.data.transactions.edges) {\n      return gqlResp.data.transactions.edges;\n    }\n\n    return {\n      message: \"No KID Found for this address\"\n    };\n  }\n  /**\n   * Creates a KID smartcontract on arweave\n   * @param KIDObject - an object containing name, description, addresses and link\n   * @param image - an object containing contentType and blobData\n   * @returns {txId} - returns a txId in case of success and false in case of failure\n   */\n\n\n  async createKID(KIDObject, image) {\n    const initialState = KIDObject;\n\n    if (initialState && initialState.addresses && initialState.addresses.Arweave) {\n      try {\n        const tx = await exports.arweave.createTransaction({\n          data: image.blobData\n        }, this.wallet);\n        tx.addTag('Content-Type', image.contentType);\n        tx.addTag('Network', 'Koii');\n        tx.addTag('Action', 'KID/Create');\n        tx.addTag('App-Name', 'SmartWeaveContract');\n        tx.addTag('App-Version', '0.1.0');\n        tx.addTag('Contract-Src', 't2jB63nGIWYUTDy2b00JPzSDtx1GQRsmKUeHtvZu1_A');\n        tx.addTag('Wallet-Address', initialState.addresses.Arweave);\n        tx.addTag('Init-State', JSON.stringify(initialState));\n        await exports.arweave.transactions.sign(tx, this.wallet);\n        const uploader = await exports.arweave.transactions.getUploader(tx);\n\n        while (!uploader.isComplete) {\n          await uploader.uploadChunk();\n          console.log(uploader.pctComplete + '% complete', uploader.uploadedChunks + '/' + uploader.totalChunks);\n        }\n\n        console.log(\"TX ID: \", tx.id);\n        return tx.id;\n      } catch (err) {\n        console.log('create transaction error');\n        console.log('err-transaction', err);\n        return false;\n      }\n    } else {\n      console.log('Arweave Address missing in addresses');\n      return false;\n    }\n  }\n  /**\n   * Updates the state of a KID smartcontract on arweave\n   * @param KIDObject - an object containing name, description, addresses and link\n   * @param contractId - the contract Id for KID to be updated\n   * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n   */\n\n\n  async updateKID(KIDObject, contractId) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n      function: 'updateKID',\n      ...KIDObject\n    });\n    return txId;\n  }\n  /**\n     * Creates a NFT Collection smartcontract on arweave\n     * @param collectionObject - an object containing name, description, addresses and link\n     * @returns {txId} - returns a txId in case of success and false in case of failure\n     */\n\n\n  async createCollection(collectionObject) {\n    const initialState = collectionObject;\n\n    if (!collectionObject.owner) {\n      console.log(\"collectionObject doesn't contain an owner\");\n      return false;\n    }\n\n    try {\n      const tx = await exports.arweave.createTransaction({\n        data: Buffer.from(collectionObject.owner, 'utf8')\n      }, this.wallet);\n      tx.addTag('Content-Type', 'text/plain');\n      tx.addTag('Network', 'Koii');\n      tx.addTag('Action', 'Collection/Create');\n      tx.addTag('App-Name', 'SmartWeaveContract');\n      tx.addTag('App-Version', '0.1.0');\n      tx.addTag('Contract-Src', 'NCepV_8bY831CMHK0LZQAQAVwZyNKLalmC36FlagLQE');\n      tx.addTag('Wallet-Address', collectionObject.owner);\n      tx.addTag('Init-State', JSON.stringify(initialState));\n      await exports.arweave.transactions.sign(tx, this.wallet);\n      const uploader = await exports.arweave.transactions.getUploader(tx);\n\n      while (!uploader.isComplete) {\n        await uploader.uploadChunk();\n        console.log(uploader.pctComplete + '% complete', uploader.uploadedChunks + '/' + uploader.totalChunks);\n      }\n\n      console.log(\"TX ID: \", tx.id);\n      return tx.id;\n    } catch (err) {\n      console.log('create transaction error');\n      console.log('err-transaction', err);\n      return false;\n    }\n  }\n  /**\n     * Gets the list of all Collections by walletAddress\n     * @param walletAddress The wallet address for the person whose DID is to be found\n     * @param count The number of results to return\n     * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n     * @returns {Array} - returns a Javascript Array of object with each object representing a Collection object (The collection object contains id which can be used in func readState to get actual state)\n     */\n\n\n  async getCollectionsByWalletAddress(walletAddress, count, cursorId) {\n    const countStr = count !== undefined ? `, first: ${count}` : \"\";\n    const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n    const query = `\n      query {\n        transactions(tags: [{\n          name: \"Action\",\n          values: [\"Collection/Create\"]\n      },\n        {\n          name: \"Wallet-Address\",\n          values: [\"${walletAddress}\"]\n      }\n      ]${countStr}${afterStr}) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n    const request = JSON.stringify({\n      query\n    });\n    let gqlResp = await this.gql(request);\n\n    if (gqlResp && gqlResp.data.transactions.edges) {\n      return gqlResp.data.transactions.edges;\n    }\n\n    return {\n      message: \"No Collections found for this address\"\n    };\n  }\n  /**\n   * Get the state from arweave for any contract\n   * @param txId Transaction ID of the NFT\n   * @returns The NFT state object\n   */\n\n\n  async readState(txId) {\n    return smartweave_1.smartweave.readContract(exports.arweave, txId);\n  }\n  /**\n   * Add new NFTs to the existing collection\n   * @param nftId - The transaction id of the NFT to be added to the collection\n   * @param contractId - the contract Id for Collection to be updated\n   * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n   */\n\n\n  async addToCollection(nftId, contractId) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n      function: 'addToCollection',\n      nftId\n    });\n    return txId;\n  }\n  /**\n   * Remove NFTs from the existing collection\n   * @param index - The index of the NFT which is to be removed from the collection\n   * @param contractId - the contract Id for Collection to be updated\n   * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n   */\n\n\n  async removeFromCollection(index, contractId) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n      function: 'removeFromCollection',\n      index\n    });\n    return txId;\n  }\n  /**\n   * Updates the view of the existing Collection\n   * @param newView - The view you want to set for the collection to display (Initialized with 'default')\n   * @param contractId - the contract Id for Collection to be updated\n   * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n   */\n\n\n  async updateView(newView, contractId) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n      function: 'updateView',\n      newView\n    });\n    return txId;\n  }\n  /**\n   * Updates the index of the NFT which should be used as the preview for the collection\n   * @param imageIndex - The index of the NFT which should be used as the preview for the collection\n   * @param contractId - the contract Id for Collection to be updated\n   * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n   */\n\n\n  async updatePreviewImageIndex(imageIndex, contractId) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n      function: 'updatePreviewImageIndex',\n      imageIndex\n    });\n    return txId;\n  }\n  /**\n   * Updates the array of NFTs from which the collection is composed of (Can be used to reorder the NFts in the collection also)\n   * @param collection - The array of NFTs from which the collection is composed of.\n   * @param contractId - the contract Id for Collection to be updated\n   * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n   */\n\n\n  async updateCollection(collection, contractId) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n      function: 'updateCollection',\n      collection\n    });\n    return txId;\n  }\n  /**\n   *  Calculates total Views and earned KOII for given NFTIds Array\n   * @param nftIdArr - The array of NFTIds for which total Views and earned KOII will be calculated\n   * @returns {object} - returns an object containing totalViews and totalRewards\n   */\n\n\n  async getViewsAndEarnedKOII(nftIdArr) {\n    let state = await this.getContractState();\n\n    if (state) {\n      const rewardReport = state.stateUpdate ? state.stateUpdate.trafficLogs.rewardReport : [];\n      let totalViewsOverall = 0;\n      let totalRewardOverall = 0;\n\n      for (let i = 0; i < nftIdArr.length; i++) {\n        let contentTxId = nftIdArr[i];\n        let contentViews = {\n          totalViews: 0,\n          totalReward: 0,\n          twentyFourHrViews: 0\n        };\n        rewardReport.forEach(ele => {\n          let logSummary = ele.logsSummary;\n\n          for (let txId in logSummary) {\n            if (txId == contentTxId) {\n              if (rewardReport.indexOf(ele) == rewardReport.length - 1) {\n                contentViews.twentyFourHrViews = logSummary[contentTxId];\n              }\n\n              const rewardPerAttention = ele.rewardPerAttention;\n              contentViews.totalViews += logSummary[contentTxId];\n              const rewardPerLog = logSummary[contentTxId] * rewardPerAttention;\n              contentViews.totalReward += rewardPerLog;\n            }\n          }\n        });\n        totalViewsOverall += contentViews.totalViews;\n        totalRewardOverall += contentViews.totalReward;\n      }\n\n      return {\n        totalViews: totalViewsOverall,\n        totalReward: totalRewardOverall\n      };\n    } else {\n      return {\n        message: \"Views and earned KOII cannot be extracted (State not valid)\"\n      };\n    }\n  } // Protected functions\n\n  /**\n   * Writes to contract\n   * @param input Passes to smartweave write function, in order to execute a contract function\n   * @returns Transaction ID\n   */\n\n\n  _interactWrite(input) {\n    const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n    return smartweave_1.smartweave.interactWrite(exports.arweave, wallet, this.contractId, input);\n  }\n  /**\n   * Read contract latest state\n   * @returns Contract\n   */\n\n\n  async _readContract() {\n    // return smartweave.readContract(arweave, this.contractId);\n    const poolID = \"OFD4GqQcqp-Y_Iqh8DN_0s3a_68oMvvnekeOEu_a45I\";\n    const query = new query_1.Query(poolID); // finding latest transactions\n\n    try {\n      const snapshotArray = await query.limit(1).find();\n      if (snapshotArray && snapshotArray.length > 0) return JSON.parse(snapshotArray[0]).state;else console.error(\"NOTHING RETURNED FROM KYVE\");\n    } catch (e) {\n      console.error(\"ERROR RETRIEVING FROM KYVE\", e);\n    }\n\n    return smartweave_1.smartweave.readContract(exports.arweave, this.contractId);\n  } // Private functions\n\n  /**\n   * Generate a 12 word mnemonic for an Arweave key https://github.com/acolytec3/arweave-mnemonic-keys\n   * @returns {string} - a promise resolving to a 12 word mnemonic seed phrase\n   */\n\n\n  async _generateMnemonic() {\n    const keys = await human_crypto_keys_1.generateKeyPair({\n      id: \"rsa\",\n      modulusLength: 4096\n    }, {\n      privateKeyFormat: \"pkcs1-pem\"\n    });\n    return keys.mnemonic;\n  }\n  /**\n   * Generates a JWK object representation of an Arweave key\n   * @param mnemonic - a 12 word mnemonic represented as a string\n   * @returns {object} - returns a Javascript object that conforms to the JWKInterface required by Arweave-js\n   */\n\n\n  async _getKeyFromMnemonic(mnemonic) {\n    const keyPair = await human_crypto_keys_1.getKeyPairFromMnemonic(mnemonic, {\n      id: \"rsa\",\n      modulusLength: 4096\n    }, {\n      privateKeyFormat: \"pkcs1-pem\"\n    }); //@ts-ignore Need to access private attribute\n\n    const privateKey = pem_jwk_1.pem2jwk(keyPair.privateKey);\n    delete privateKey.alg;\n    delete privateKey.key_ops;\n    return privateKey;\n  }\n\n}\n\nexports.Common = Common;\n/**\n * Get cached data from path\n * @param path Path to cached data\n * @returns Data as generic type T\n */\n\nfunction getCacheData(path) {\n  return axios_1.default.get(path);\n}\n\nexports.getCacheData = getCacheData;\n/**\n * Get info from Arweave net\n * @returns Axios response with info\n */\n\nfunction getArweaveNetInfo() {\n  return axios_1.default.get(URL_ARWEAVE_INFO);\n}\n\nmodule.exports = {\n  BUNDLER_NODES: exports.BUNDLER_NODES,\n  arweave: exports.arweave,\n  Common,\n  getCacheData\n};","map":{"version":3,"sources":["../src/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCacheData = exports.Common = exports.BUNDLER_NODES = exports.arweave = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\nconst arweave_1 = __importDefault(require(\"arweave\"));\nconst arweaveUtils = __importStar(require(\"arweave/node/lib/utils\"));\nconst smartweave_1 = require(\"smartweave\");\nconst query_1 = require(\"@kyve/query\");\n//@ts-ignore // Needed to allow implicit any here\nconst human_crypto_keys_1 = require(\"human-crypto-keys\");\n//@ts-ignore\nconst pem_jwk_1 = require(\"pem-jwk\");\nconst HOST_GATEWAY = \"arweave.net\";\nconst URL_ARWEAVE_INFO = `https://${HOST_GATEWAY}/info`;\nconst URL_ARWEAVE_GQL = `https://${HOST_GATEWAY}/graphql`;\nconst BLOCK_TEMPLATE = `\n  pageInfo {\n    hasNextPage\n  }\n  edges {\n    cursor\n    node {\n      id anchor signature recipient\n      owner { address key }\n      fee { winston ar }\n      quantity { winston ar }\n      data { size type }\n      tags { name value }\n      block { id timestamp height previous }\n      parent { id }\n    }\n  }`;\nexports.arweave = arweave_1.default.init({\n    host: HOST_GATEWAY,\n    protocol: \"https\",\n    port: 443\n});\nexports.BUNDLER_NODES = \"/nodes\";\n/**\n * Tools for interacting with the koi network\n */\nclass Common {\n    constructor(bundlerUrl = \"https://bundler.openkoi.com:8888\", contractId = \"cETTyJQYxJLVQ6nC3VxzsZf1x2-6TW2LFkGZa91gUWc\") {\n        this.bundlerUrl = bundlerUrl;\n        this.contractId = contractId;\n        console.log(\"Initialized Koii Tools for true ownership and direct communication using version \", this.contractId);\n    }\n    /**\n     * Generates wallet optionally with a mnemonic phrase\n     * @param use_mnemonic [false] Flag for enabling mnemonic phrase wallet generation\n     */\n    async generateWallet(use_mnemonic = false) {\n        let key, mnemonic;\n        if (use_mnemonic === true) {\n            mnemonic = await this._generateMnemonic();\n            key = await this._getKeyFromMnemonic(mnemonic);\n        }\n        else\n            key = await exports.arweave.wallets.generate();\n        if (!key)\n            throw Error(\"failed to create wallet\");\n        this.mnemonic = mnemonic;\n        this.wallet = key;\n        await this.getWalletAddress();\n        return true;\n    }\n    /**\n     * Loads arweave wallet\n     * @param source object to load from, JSON or JWK, or mnemonic key\n     */\n    async loadWallet(source) {\n        switch (typeof source) {\n            case \"string\":\n                this.wallet = await this._getKeyFromMnemonic(source);\n                break;\n            default:\n                this.wallet = source;\n        }\n        await this.getWalletAddress();\n        return this.wallet;\n    }\n    /**\n     * Manually set wallet address\n     * @param walletAddress Address as a string\n     * @returns Wallet address\n     */\n    setWallet(walletAddress) {\n        if (!this.address)\n            this.address = walletAddress;\n        return this.address;\n    }\n    /**\n     * Uses koi wallet to get the address\n     * @returns Wallet address\n     */\n    async getWalletAddress() {\n        if (typeof this.address !== \"string\")\n            this.address = await exports.arweave.wallets.jwkToAddress(this.wallet);\n        return this.address;\n    }\n    /**\n     * Get and set arweave balance\n     * @returns Balance as a string if wallet exists, else undefined\n     */\n    async getWalletBalance() {\n        if (!this.address)\n            return 0;\n        const winston = await exports.arweave.wallets.getBalance(this.address);\n        const ar = exports.arweave.ar.winstonToAr(winston);\n        return parseFloat(ar);\n    }\n    /**\n     * Gets koi balance from cache\n     * @returns Balance as a number\n     */\n    async getKoiBalance() {\n        const state = await this.getContractState();\n        if (this.address !== undefined && this.address in state.balances)\n            return state.balances[this.address];\n        return 0;\n    }\n    /**\n     * Gets the current contract state\n     * @returns Current KOI system state\n     */\n    getContractState() {\n        return this._readContract();\n    }\n    /**\n     * Get contract state\n     * @param id Transaction ID\n     * @returns State object\n     */\n    async getTransaction(id) {\n        return exports.arweave.transactions.get(id);\n    }\n    /**\n     * Get block height\n     * @returns Block height maybe number\n     */\n    async getBlockHeight() {\n        const info = await getArweaveNetInfo();\n        return info.data.height;\n    }\n    /**\n     * Get the NFT state from arweave, this should be the initial state\n     * @param txId Transaction ID of the NFT\n     * @returns The NFT state object\n     */\n    async readNftState(txId) {\n        try {\n            const response = await axios_1.default.get(`https://bundler.openkoi.com:8888/state/getNFTState?tranxId=${txId}`);\n            return response.data;\n        }\n        catch (err) {\n            console.log(\"ERRPR\", err);\n            if (err)\n                console.error('error fetching NFT data from bundler for ' + txId);\n            return smartweave_1.smartweave.readContract(exports.arweave, txId);\n        }\n    }\n    /**\n     * Interact with contract to stake\n     * @param qty Quantity to stake\n     * @returns Transaction ID\n     */\n    stake(qty) {\n        if (!Number.isInteger(qty))\n            throw Error('Invalid value for \"qty\". Must be an integer');\n        const input = {\n            function: \"stake\",\n            qty: qty\n        };\n        return this._interactWrite(input);\n    }\n    /**\n     * Interact with contract to withdraw\n     * @param qty Quantity to transfer\n     * @returns Transaction ID\n     */\n    withdraw(qty) {\n        if (!Number.isInteger(qty))\n            throw Error('Invalid value for \"qty\". Must be an integer');\n        const input = {\n            function: \"withdraw\",\n            qty: qty\n        };\n        return this._interactWrite(input);\n    }\n    /**\n     * Interact with contract to transfer koi\n     * @param qty Quantity to transfer\n     * @param target Receiver address\n     * @returns Transaction ID\n     */\n    async transfer(qty, target, token) {\n        const input = {\n            function: \"transfer\",\n            qty: qty,\n            target: target\n        };\n        switch (token) {\n            case \"AR\": {\n                const transaction = await exports.arweave.createTransaction({ target: target, quantity: exports.arweave.ar.arToWinston(qty.toString()) }, this.wallet);\n                await exports.arweave.transactions.sign(transaction, this.wallet);\n                await exports.arweave.transactions.post(transaction);\n                return transaction.id;\n            }\n            case \"KOI\": {\n                const txid = await this._interactWrite(input);\n                return txid;\n            }\n            default: {\n                throw Error(\"token or coin ticker doesn't exist\");\n            }\n        }\n    }\n    /**\n     * Mint koi\n     * @param arg object arg.targetAddress(receiver address) and arg.qty(amount to mint)\n     * @returns Transaction ID\n     */\n    mint(arg) {\n        const input = {\n            function: \"mint\",\n            qty: arg.qty,\n            target: arg.targetAddress\n        };\n        return this._interactWrite(input);\n    }\n    /**\n     * Interact with contract to register data\n     * @param txId It has batchFile/value(string) and stake amount/value(int) as properties\n     * @param ownerId String container the owner ID\n     * @returns Transaction ID\n     */\n    registerData(txId, ownerId = \"\") {\n        const input = {\n            function: \"registerData\",\n            txId: txId,\n            owner: ownerId\n        };\n        return this._interactWrite(input);\n    }\n    /**\n     * Sign transaction\n     * @param tx Transaction to be signed\n     * @returns signed Transaction\n     */\n    async signTransaction(tx) {\n        try {\n            //const wallet = this.wallet;\n            // Now we sign the transaction\n            await exports.arweave.transactions.sign(tx, this.wallet);\n            // After is signed, we send the transaction\n            //await exports.arweave.transactions.post(transaction);\n            return tx;\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    /**\n     * Get transaction data from Arweave\n     * @param txId Transaction ID\n     * @returns Transaction\n     */\n    nftTransactionData(txId) {\n        return exports.arweave.transactions.get(txId);\n    }\n    /**\n     * Sign payload\n     * @param payload Payload to sign\n     * @returns Signed payload with signature\n     */\n    async signPayload(payload) {\n        if (this.wallet === undefined)\n            return null;\n        const data = payload.data || payload.vote || null;\n        const jwk = this.wallet;\n        const publicModulus = jwk.n;\n        const dataInString = JSON.stringify(data);\n        const dataIn8Array = arweaveUtils.stringToBuffer(dataInString);\n        const rawSignature = await exports.arweave.crypto.sign(jwk, dataIn8Array);\n        payload.signature = arweaveUtils.bufferTob64Url(rawSignature);\n        payload.owner = publicModulus;\n        return payload;\n    }\n    /**\n     * Verify signed payload\n     * @param payload\n     * @returns Verification result\n     */\n    async verifySignature(payload) {\n        const data = payload.data || payload.vote || null;\n        const rawSignature = arweaveUtils.b64UrlToBuffer(payload.signature);\n        const dataInString = JSON.stringify(data);\n        const dataIn8Array = arweaveUtils.stringToBuffer(dataInString);\n        return await exports.arweave.crypto.verify(payload.owner, dataIn8Array, rawSignature);\n    }\n    /**\n     * Posts data to Arweave\n     * @param data\n     * @returns Transaction ID\n     */\n    async postData(data) {\n        // TODO: define data interface\n        const wallet = this.wallet;\n        const transaction = await exports.arweave.createTransaction({\n            data: Buffer.from(JSON.stringify(data, null, 2), \"utf8\")\n        }, wallet);\n        // Now we sign the transaction\n        await exports.arweave.transactions.sign(transaction, wallet);\n        const txId = transaction.id;\n        // After is signed, we send the transaction\n        const response = await exports.arweave.transactions.post(transaction);\n        if (response.status === 200)\n            return txId;\n        return null;\n    }\n    /**\n     * Gets all the transactions where the wallet is the owner\n     * @param wallet Wallet address as a string\n     * @param count The number of results to return\n     * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n     * @returns Object with transaction IDs as keys, and transaction data strings as values\n     */\n    getOwnedTxs(wallet, count, cursorId) {\n        const countStr = count !== undefined ? `, first: ${count}` : \"\";\n        const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n        const query = `\n      query {\n        transactions(owners:[\"${wallet}\"]${countStr}${afterStr}) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n        const request = JSON.stringify({ query });\n        return this.gql(request);\n    }\n    /**\n     * Gets all the transactions where the wallet is the recipient\n     * @param wallet Wallet address as a string\n     * @param count The number of results to return\n     * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n     * @returns Object with transaction IDs as keys, and transaction data strings as values\n     */\n    getRecipientTxs(wallet, count, cursorId) {\n        const countStr = count !== undefined ? `, first: ${count}` : \"\";\n        const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n        const query = `\n      query {\n        transactions(recipients:[\"${wallet}\"]${countStr}${afterStr}) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n        const request = JSON.stringify({ query });\n        return this.gql(request);\n    }\n    /**\n     * Get the updated state of an NFT\n     * @param contentTxId TxId of the content\n     * @param state\n     * @returns An object with {totaltViews, totalReward, 24hrsViews}\n     */\n    async contentView(contentTxId, state) {\n        const rewardReport = state.stateUpdate.trafficLogs.rewardReport;\n        try {\n            const nftState = await this.readNftState(contentTxId);\n            const contentViews = {\n                ...nftState,\n                totalViews: 0,\n                totalReward: 0,\n                twentyFourHrViews: 0,\n                txIdContent: contentTxId\n            };\n            rewardReport.forEach((ele) => {\n                const logSummary = ele.logsSummary;\n                for (const txId in logSummary) {\n                    if (txId == contentTxId) {\n                        if (rewardReport.indexOf(ele) == rewardReport.length - 1) {\n                            contentViews.twentyFourHrViews = logSummary[contentTxId];\n                        }\n                        const rewardPerAttention = ele.rewardPerAttention;\n                        contentViews.totalViews += logSummary[contentTxId];\n                        const rewardPerLog = logSummary[contentTxId] * rewardPerAttention;\n                        contentViews.totalReward += rewardPerLog;\n                    }\n                }\n            });\n            return contentViews;\n        }\n        catch (err) {\n            return null;\n        }\n    }\n    /**\n     * Get a list of all NFT IDs\n     * @returns Array of transaction IDs which are registered NFTs\n     */\n    async retrieveAllRegisteredContent() {\n        const state = await this.getContractState();\n        const registerRecords = state.registeredRecord;\n        const txIdArr = Object.keys(registerRecords);\n        return txIdArr;\n    }\n    /**\n     * Get a list of NFT IDs by owner\n     * @param owner Wallet address of the owner\n     * @returns Array containing the NFTs\n     */\n    async getNftIdsByOwner(owner) {\n        const state = await this.getContractState();\n        const nfts = [];\n        for (const nft in state.registeredRecord)\n            if (state.registeredRecord[nft] === owner)\n                nfts.push(nft);\n        return nfts;\n    }\n    /**\n     * Get Koi rewards earned from an NFT\n     * @param txId The transaction id to process\n     * @returns Koi rewards earned or null if the transaction is not a valid Koi NFT\n     */\n    async getNftReward(txId) {\n        const state = await this.getContractState();\n        if (!(txId in state.registeredRecord))\n            return null;\n        const nft = await this.contentView(txId, state);\n        return nft.totalReward;\n    }\n    /**\n     * Query Arweave using GQL\n     * @param request Query string\n     * @returns Object containing the query results\n     */\n    async gql(request) {\n        const { data } = await axios_1.default.post(URL_ARWEAVE_GQL, request, {\n            headers: { \"content-type\": \"application/json\" }\n        });\n        return data;\n    }\n    /**\n     * Gets an array of service nodes\n     * @param url URL of the service node to retrieve the array from a known service node\n     * @returns Array of service nodes\n     */\n    async getNodes(url = this.bundlerUrl) {\n        const res = await getCacheData(url + exports.BUNDLER_NODES);\n        try {\n            return JSON.parse(res.data);\n        }\n        catch (_e) {\n            return [];\n        }\n    }\n    /**\n     * Gets the list of all KIDs(DIDs)\n     * @param count The number of results to return\n     * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n     * @returns {Array} - returns a Javascript Array of object with each object representing a single KID\n     */\n    async getAllKID(count, cursorId) {\n        const countStr = count !== undefined ? `, first: ${count}` : \"\";\n        const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n        const query = `\n    query {\n      transactions(tags: {\n        name: \"Action\",\n        values: [\"KID/Create\"]\n    }${countStr}${afterStr}) {\n        ${BLOCK_TEMPLATE}\n      }\n    }`;\n        const request = JSON.stringify({ query });\n        let gqlResp = await this.gql(request);\n        if (gqlResp && gqlResp.data.transactions.edges) {\n            return gqlResp.data.transactions.edges;\n        }\n        return { message: \"No KIDs Found\" };\n    }\n    /**\n       * Get the KID state for the particular walletAddress\n       * @param walletAddress The wallet address for the person whose DID is to be found\n       * @returns {Object} - returns a contract object having id which can be used to get the state\n       */\n    async getKIDByWalletAddress(walletAddress) {\n        const query = `\n      query {\n        transactions(tags: [{\n          name: \"Action\",\n          values: [\"KID/Create\"]\n      },\n        {\n          name: \"Wallet-Address\",\n          values: [\"${walletAddress}\"]\n      }\n      ]) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n        const request = JSON.stringify({ query });\n        let gqlResp = await this.gql(request);\n        if (gqlResp && gqlResp.data.transactions.edges) {\n            return gqlResp.data.transactions.edges;\n        }\n        return { message: \"No KID Found for this address\" };\n    }\n    /**\n     * Creates a KID smartcontract on arweave\n     * @param KIDObject - an object containing name, description, addresses and link\n     * @param image - an object containing contentType and blobData\n     * @returns {txId} - returns a txId in case of success and false in case of failure\n     */\n    async createKID(KIDObject, image) {\n        const initialState = KIDObject;\n        if (initialState && initialState.addresses && initialState.addresses.Arweave) {\n            try {\n                const tx = await exports.arweave.createTransaction({\n                    data: image.blobData,\n                }, this.wallet);\n                tx.addTag('Content-Type', image.contentType);\n                tx.addTag('Network', 'Koii');\n                tx.addTag('Action', 'KID/Create');\n                tx.addTag('App-Name', 'SmartWeaveContract');\n                tx.addTag('App-Version', '0.1.0');\n                tx.addTag('Contract-Src', 't2jB63nGIWYUTDy2b00JPzSDtx1GQRsmKUeHtvZu1_A');\n                tx.addTag('Wallet-Address', initialState.addresses.Arweave);\n                tx.addTag('Init-State', JSON.stringify(initialState));\n                await exports.arweave.transactions.sign(tx, this.wallet);\n                const uploader = await exports.arweave.transactions.getUploader(tx);\n                while (!uploader.isComplete) {\n                    await uploader.uploadChunk();\n                    console.log(uploader.pctComplete + '% complete', uploader.uploadedChunks + '/' + uploader.totalChunks);\n                }\n                console.log(\"TX ID: \", tx.id);\n                return tx.id;\n            }\n            catch (err) {\n                console.log('create transaction error');\n                console.log('err-transaction', err);\n                return false;\n            }\n        }\n        else {\n            console.log('Arweave Address missing in addresses');\n            return false;\n        }\n    }\n    /**\n     * Updates the state of a KID smartcontract on arweave\n     * @param KIDObject - an object containing name, description, addresses and link\n     * @param contractId - the contract Id for KID to be updated\n     * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n     */\n    async updateKID(KIDObject, contractId) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n            function: 'updateKID',\n            ...KIDObject\n        });\n        return txId;\n    }\n    /**\n       * Creates a NFT Collection smartcontract on arweave\n       * @param collectionObject - an object containing name, description, addresses and link\n       * @returns {txId} - returns a txId in case of success and false in case of failure\n       */\n    async createCollection(collectionObject) {\n        const initialState = collectionObject;\n        if (!collectionObject.owner) {\n            console.log(\"collectionObject doesn't contain an owner\");\n            return false;\n        }\n        try {\n            const tx = await exports.arweave.createTransaction({\n                data: Buffer.from(collectionObject.owner, 'utf8'),\n            }, this.wallet);\n            tx.addTag('Content-Type', 'text/plain');\n            tx.addTag('Network', 'Koii');\n            tx.addTag('Action', 'Collection/Create');\n            tx.addTag('App-Name', 'SmartWeaveContract');\n            tx.addTag('App-Version', '0.1.0');\n            tx.addTag('Contract-Src', 'NCepV_8bY831CMHK0LZQAQAVwZyNKLalmC36FlagLQE');\n            tx.addTag('Wallet-Address', collectionObject.owner);\n            tx.addTag('Init-State', JSON.stringify(initialState));\n            await exports.arweave.transactions.sign(tx, this.wallet);\n            const uploader = await exports.arweave.transactions.getUploader(tx);\n            while (!uploader.isComplete) {\n                await uploader.uploadChunk();\n                console.log(uploader.pctComplete + '% complete', uploader.uploadedChunks + '/' + uploader.totalChunks);\n            }\n            console.log(\"TX ID: \", tx.id);\n            return tx.id;\n        }\n        catch (err) {\n            console.log('create transaction error');\n            console.log('err-transaction', err);\n            return false;\n        }\n    }\n    /**\n       * Gets the list of all Collections by walletAddress\n       * @param walletAddress The wallet address for the person whose DID is to be found\n       * @param count The number of results to return\n       * @param cursorId Cursor ID after which to query results, from data.transactions.edges[n].cursor\n       * @returns {Array} - returns a Javascript Array of object with each object representing a Collection object (The collection object contains id which can be used in func readState to get actual state)\n       */\n    async getCollectionsByWalletAddress(walletAddress, count, cursorId) {\n        const countStr = count !== undefined ? `, first: ${count}` : \"\";\n        const afterStr = cursorId !== undefined ? `, after: \"${cursorId}\"` : \"\";\n        const query = `\n      query {\n        transactions(tags: [{\n          name: \"Action\",\n          values: [\"Collection/Create\"]\n      },\n        {\n          name: \"Wallet-Address\",\n          values: [\"${walletAddress}\"]\n      }\n      ]${countStr}${afterStr}) {\n          ${BLOCK_TEMPLATE}\n        }\n      }`;\n        const request = JSON.stringify({ query });\n        let gqlResp = await this.gql(request);\n        if (gqlResp && gqlResp.data.transactions.edges) {\n            return gqlResp.data.transactions.edges;\n        }\n        return { message: \"No Collections found for this address\" };\n    }\n    /**\n     * Get the state from arweave for any contract\n     * @param txId Transaction ID of the NFT\n     * @returns The NFT state object\n     */\n    async readState(txId) {\n        return smartweave_1.smartweave.readContract(exports.arweave, txId);\n    }\n    /**\n     * Add new NFTs to the existing collection\n     * @param nftId - The transaction id of the NFT to be added to the collection\n     * @param contractId - the contract Id for Collection to be updated\n     * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n     */\n    async addToCollection(nftId, contractId) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n            function: 'addToCollection',\n            nftId\n        });\n        return txId;\n    }\n    /**\n     * Remove NFTs from the existing collection\n     * @param index - The index of the NFT which is to be removed from the collection\n     * @param contractId - the contract Id for Collection to be updated\n     * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n     */\n    async removeFromCollection(index, contractId) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n            function: 'removeFromCollection',\n            index\n        });\n        return txId;\n    }\n    /**\n     * Updates the view of the existing Collection\n     * @param newView - The view you want to set for the collection to display (Initialized with 'default')\n     * @param contractId - the contract Id for Collection to be updated\n     * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n     */\n    async updateView(newView, contractId) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n            function: 'updateView',\n            newView\n        });\n        return txId;\n    }\n    /**\n     * Updates the index of the NFT which should be used as the preview for the collection\n     * @param imageIndex - The index of the NFT which should be used as the preview for the collection\n     * @param contractId - the contract Id for Collection to be updated\n     * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n     */\n    async updatePreviewImageIndex(imageIndex, contractId) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n            function: 'updatePreviewImageIndex',\n            imageIndex\n        });\n        return txId;\n    }\n    /**\n     * Updates the array of NFTs from which the collection is composed of (Can be used to reorder the NFts in the collection also)\n     * @param collection - The array of NFTs from which the collection is composed of.\n     * @param contractId - the contract Id for Collection to be updated\n     * @returns {txId} - returns a transaction id of arweave for the updateKID smartweave call\n     */\n    async updateCollection(collection, contractId) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        const txId = await smartweave_1.smartweave.interactWrite(exports.arweave, wallet, contractId, {\n            function: 'updateCollection',\n            collection\n        });\n        return txId;\n    }\n    /**\n     *  Calculates total Views and earned KOII for given NFTIds Array\n     * @param nftIdArr - The array of NFTIds for which total Views and earned KOII will be calculated\n     * @returns {object} - returns an object containing totalViews and totalRewards\n     */\n    async getViewsAndEarnedKOII(nftIdArr) {\n        let state = await this.getContractState();\n        if (state) {\n            const rewardReport = state.stateUpdate ? state.stateUpdate.trafficLogs.rewardReport : [];\n            let totalViewsOverall = 0;\n            let totalRewardOverall = 0;\n            for (let i = 0; i < nftIdArr.length; i++) {\n                let contentTxId = nftIdArr[i];\n                let contentViews = {\n                    totalViews: 0,\n                    totalReward: 0,\n                    twentyFourHrViews: 0\n                };\n                rewardReport.forEach((ele) => {\n                    let logSummary = ele.logsSummary;\n                    for (let txId in logSummary) {\n                        if (txId == contentTxId) {\n                            if (rewardReport.indexOf(ele) == rewardReport.length - 1) {\n                                contentViews.twentyFourHrViews = logSummary[contentTxId];\n                            }\n                            const rewardPerAttention = ele.rewardPerAttention;\n                            contentViews.totalViews += logSummary[contentTxId];\n                            const rewardPerLog = logSummary[contentTxId] * rewardPerAttention;\n                            contentViews.totalReward += rewardPerLog;\n                        }\n                    }\n                });\n                totalViewsOverall += contentViews.totalViews;\n                totalRewardOverall += contentViews.totalReward;\n            }\n            return { totalViews: totalViewsOverall, totalReward: totalRewardOverall };\n        }\n        else {\n            return { message: \"Views and earned KOII cannot be extracted (State not valid)\" };\n        }\n    }\n    // Protected functions\n    /**\n     * Writes to contract\n     * @param input Passes to smartweave write function, in order to execute a contract function\n     * @returns Transaction ID\n     */\n    _interactWrite(input) {\n        const wallet = this.wallet === undefined ? \"use_wallet\" : this.wallet;\n        return smartweave_1.smartweave.interactWrite(exports.arweave, wallet, this.contractId, input);\n    }\n    /**\n     * Read contract latest state\n     * @returns Contract\n     */\n    async _readContract() {\n        // return smartweave.readContract(arweave, this.contractId);\n        const poolID = \"OFD4GqQcqp-Y_Iqh8DN_0s3a_68oMvvnekeOEu_a45I\";\n        const query = new query_1.Query(poolID);\n        // finding latest transactions\n        try {\n            const snapshotArray = await query.limit(1).find();\n            if (snapshotArray && snapshotArray.length > 0)\n                return JSON.parse(snapshotArray[0]).state;\n            else\n                console.error(\"NOTHING RETURNED FROM KYVE\");\n        }\n        catch (e) {\n            console.error(\"ERROR RETRIEVING FROM KYVE\", e);\n        }\n        return smartweave_1.smartweave.readContract(exports.arweave, this.contractId);\n    }\n    // Private functions\n    /**\n     * Generate a 12 word mnemonic for an Arweave key https://github.com/acolytec3/arweave-mnemonic-keys\n     * @returns {string} - a promise resolving to a 12 word mnemonic seed phrase\n     */\n    async _generateMnemonic() {\n        const keys = await human_crypto_keys_1.generateKeyPair({ id: \"rsa\", modulusLength: 4096 }, { privateKeyFormat: \"pkcs1-pem\" });\n        return keys.mnemonic;\n    }\n    /**\n     * Generates a JWK object representation of an Arweave key\n     * @param mnemonic - a 12 word mnemonic represented as a string\n     * @returns {object} - returns a Javascript object that conforms to the JWKInterface required by Arweave-js\n     */\n    async _getKeyFromMnemonic(mnemonic) {\n        const keyPair = await human_crypto_keys_1.getKeyPairFromMnemonic(mnemonic, { id: \"rsa\", modulusLength: 4096 }, { privateKeyFormat: \"pkcs1-pem\" });\n        //@ts-ignore Need to access private attribute\n        const privateKey = pem_jwk_1.pem2jwk(keyPair.privateKey);\n        delete privateKey.alg;\n        delete privateKey.key_ops;\n        return privateKey;\n    }\n}\nexports.Common = Common;\n/**\n * Get cached data from path\n * @param path Path to cached data\n * @returns Data as generic type T\n */\nfunction getCacheData(path) {\n    return axios_1.default.get(path);\n}\nexports.getCacheData = getCacheData;\n/**\n * Get info from Arweave net\n * @returns Axios response with info\n */\nfunction getArweaveNetInfo() {\n    return axios_1.default.get(URL_ARWEAVE_INFO);\n}\nmodule.exports = {\n    BUNDLER_NODES: exports.BUNDLER_NODES,\n    arweave: exports.arweave,\n    Common,\n    getCacheData\n};\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"script"}