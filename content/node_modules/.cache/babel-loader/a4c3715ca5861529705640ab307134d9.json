{"ast":null,"code":"import { UnsupportedAlgorithmError } from './errors';\n\nconst getEcFieldSize = namedCurve => // Get the the curve's field size in bytes by extracting the number of bits from it and converting it to bytes\n// Note that the number of bits may not be multiples of 8\nMath.floor((Number(namedCurve.match(/\\d+/)[0]) + 7) / 8);\n\nexport const decodeEcPoint = (namedCurve, publicKey) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (publicKey[0] !== 4) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported');\n  }\n\n  if (publicKey.length !== fieldSizeBytes * 2 + 1) {\n    throw new UnsupportedAlgorithmError(`Expecting EC public key to have length ${fieldSizeBytes * 2 - 1}`);\n  }\n\n  return {\n    x: publicKey.slice(1, fieldSizeBytes + 1),\n    y: publicKey.slice(fieldSizeBytes + 1)\n  };\n};\nexport const encodeEcPoint = (namedCurve, x, y) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!y) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported (y must be specified)');\n  }\n\n  if (!x || x.length !== fieldSizeBytes || !y || y.length !== fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(`Expecting x & y points to have length ${fieldSizeBytes} bytes`);\n  }\n\n  return new Uint8Array([4, ...x, ...y]);\n};\nexport const validateEcD = (namedCurve, d) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!d || d.length < fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(`Expecting d length to be >= ${fieldSizeBytes} bytes`);\n  }\n\n  return d;\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/util/ec.js"],"names":["UnsupportedAlgorithmError","getEcFieldSize","namedCurve","Math","floor","Number","match","decodeEcPoint","publicKey","fieldSizeBytes","length","x","slice","y","encodeEcPoint","Uint8Array","validateEcD","d"],"mappings":"AAAA,SAASA,yBAAT,QAA0C,UAA1C;;AAEA,MAAMC,cAAc,GAAGC,UAAU,IAAI;AACrC;AACAC,IAAI,CAACC,KAAL,CAAW,CAACC,MAAM,CAACH,UAAU,CAACI,KAAX,CAAiB,KAAjB,EAAwB,CAAxB,CAAD,CAAN,GAAqC,CAAtC,IAA2C,CAAtD,CAFA;;AAIA,OAAO,MAAMC,aAAa,GAAG,CAACL,UAAD,EAAaM,SAAb,KAA2B;AACtD,QAAMC,cAAc,GAAGR,cAAc,CAACC,UAAD,CAArC;;AAEA,MAAIM,SAAS,CAAC,CAAD,CAAT,KAAiB,CAArB,EAAwB;AACtB,UAAM,IAAIR,yBAAJ,CAA8B,2CAA9B,CAAN;AACD;;AAED,MAAIQ,SAAS,CAACE,MAAV,KAAqBD,cAAc,GAAG,CAAjB,GAAqB,CAA9C,EAAiD;AAC/C,UAAM,IAAIT,yBAAJ,CAA+B,0CAAyCS,cAAc,GAAG,CAAjB,GAAqB,CAAE,EAA/F,CAAN;AACD;;AAED,SAAO;AACLE,IAAAA,CAAC,EAAEH,SAAS,CAACI,KAAV,CAAgB,CAAhB,EAAmBH,cAAc,GAAG,CAApC,CADE;AAELI,IAAAA,CAAC,EAAEL,SAAS,CAACI,KAAV,CAAgBH,cAAc,GAAG,CAAjC;AAFE,GAAP;AAID,CAfM;AAgBP,OAAO,MAAMK,aAAa,GAAG,CAACZ,UAAD,EAAaS,CAAb,EAAgBE,CAAhB,KAAsB;AACjD,QAAMJ,cAAc,GAAGR,cAAc,CAACC,UAAD,CAArC;;AAEA,MAAI,CAACW,CAAL,EAAQ;AACN,UAAM,IAAIb,yBAAJ,CAA8B,iEAA9B,CAAN;AACD;;AAED,MAAI,CAACW,CAAD,IAAMA,CAAC,CAACD,MAAF,KAAaD,cAAnB,IAAqC,CAACI,CAAtC,IAA2CA,CAAC,CAACH,MAAF,KAAaD,cAA5D,EAA4E;AAC1E,UAAM,IAAIT,yBAAJ,CAA+B,yCAAwCS,cAAe,QAAtF,CAAN;AACD;;AAED,SAAO,IAAIM,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAGJ,CAAP,EAAU,GAAGE,CAAb,CAAf,CAAP;AACD,CAZM;AAaP,OAAO,MAAMG,WAAW,GAAG,CAACd,UAAD,EAAae,CAAb,KAAmB;AAC5C,QAAMR,cAAc,GAAGR,cAAc,CAACC,UAAD,CAArC;;AAEA,MAAI,CAACe,CAAD,IAAMA,CAAC,CAACP,MAAF,GAAWD,cAArB,EAAqC;AACnC,UAAM,IAAIT,yBAAJ,CAA+B,+BAA8BS,cAAe,QAA5E,CAAN;AACD;;AAED,SAAOQ,CAAP;AACD,CARM","sourcesContent":["import { UnsupportedAlgorithmError } from './errors';\n\nconst getEcFieldSize = namedCurve => // Get the the curve's field size in bytes by extracting the number of bits from it and converting it to bytes\n// Note that the number of bits may not be multiples of 8\nMath.floor((Number(namedCurve.match(/\\d+/)[0]) + 7) / 8);\n\nexport const decodeEcPoint = (namedCurve, publicKey) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (publicKey[0] !== 4) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported');\n  }\n\n  if (publicKey.length !== fieldSizeBytes * 2 + 1) {\n    throw new UnsupportedAlgorithmError(`Expecting EC public key to have length ${fieldSizeBytes * 2 - 1}`);\n  }\n\n  return {\n    x: publicKey.slice(1, fieldSizeBytes + 1),\n    y: publicKey.slice(fieldSizeBytes + 1)\n  };\n};\nexport const encodeEcPoint = (namedCurve, x, y) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!y) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported (y must be specified)');\n  }\n\n  if (!x || x.length !== fieldSizeBytes || !y || y.length !== fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(`Expecting x & y points to have length ${fieldSizeBytes} bytes`);\n  }\n\n  return new Uint8Array([4, ...x, ...y]);\n};\nexport const validateEcD = (namedCurve, d) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!d || d.length < fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(`Expecting d length to be >= ${fieldSizeBytes} bytes`);\n  }\n\n  return d;\n};"]},"metadata":{},"sourceType":"module"}