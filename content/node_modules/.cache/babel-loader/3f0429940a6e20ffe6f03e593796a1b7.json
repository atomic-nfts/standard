{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeContractSource = exports.log = exports.arrayToHex = exports.formatTags = exports.unpackTags = exports.getTag = void 0;\n\nfunction getTag(tx, name) {\n  const tags = tx.get('tags');\n\n  for (const tag of tags) {\n    // decoding tags can throw on invalid utf8 data.\n    try {\n      if (tag.get('name', {\n        decode: true,\n        string: true\n      }) === name) {\n        return tag.get('value', {\n          decode: true,\n          string: true\n        });\n      } // tslint:disable-next-line: no-empty\n\n    } catch (e) {}\n  }\n\n  return false;\n}\n\nexports.getTag = getTag;\n/**\n * Unpacks string tags from a Tx and puts in a KV map\n * Tags that appear multiple times will be converted to an\n * array of string values, ordered as they appear in the tx.\n *\n * @param tx\n */\n\nfunction unpackTags(tx) {\n  const tags = tx.get('tags');\n  const result = {};\n\n  for (const tag of tags) {\n    try {\n      const name = tag.get('name', {\n        decode: true,\n        string: true\n      });\n      const value = tag.get('value', {\n        decode: true,\n        string: true\n      });\n\n      if (!result.hasOwnProperty(name)) {\n        result[name] = value;\n        continue;\n      }\n\n      result[name] = [...result[name], value];\n    } catch (e) {// ignore tags with invalid utf-8 strings in key or value.\n    }\n  }\n\n  return result;\n}\n\nexports.unpackTags = unpackTags;\n\nfunction formatTags(tags) {\n  const result = {};\n\n  for (const tag of tags) {\n    const {\n      name,\n      value\n    } = tag;\n\n    if (!result.hasOwnProperty(name)) {\n      result[name] = value;\n      continue;\n    }\n\n    result[name] = [...result[name], value];\n  }\n\n  return result;\n}\n\nexports.formatTags = formatTags;\n\nfunction arrayToHex(arr) {\n  let str = '';\n\n  for (const a of arr) {\n    str += ('0' + a.toString(16)).slice(-2);\n  }\n\n  return str;\n}\n\nexports.arrayToHex = arrayToHex;\n\nfunction log(arweave, ...str) {\n  if (!arweave || !arweave.getConfig().api.logging) return;\n  typeof arweave.getConfig().api.logger === 'function' ? arweave.getConfig().api.logger(...str) : console.log(...str);\n}\n\nexports.log = log;\n\nfunction normalizeContractSource(contractSrc) {\n  // Convert from ES Module format to something we can run inside a Function.\n  // Removes the `export` keyword and adds ;return handle to the end of the function.\n  // Additionally it removes 'IIFE' declarations\n  // (which may be generated when bundling multiple sources into one output file\n  // - eg. using esbuild's \"IIFE\" bundle format).\n  // We also assign the passed in SmartWeaveGlobal to SmartWeave, and declare\n  // the ContractError exception.\n  // We then use `new Function()` which we can call and get back the returned handle function\n  // which has access to the per-instance globals.\n  contractSrc = contractSrc.replace(/export\\s+async\\s+function\\s+handle/gmu, 'async function handle').replace(/export\\s+function\\s+handle/gmu, 'function handle').replace(/\\(\\s*\\(\\)\\s*=>\\s*{/g, '').replace(/\\s*\\(\\s*function\\s*\\(\\)\\s*{/g, '').replace(/}\\s*\\)\\s*\\(\\)\\s*;/g, '');\n  return `\n    const [SmartWeave, BigNumber, clarity] = arguments;\n    clarity.SmartWeave = SmartWeave;\n    class ContractError extends Error { constructor(message) { super(message); this.name = \\'ContractError\\' } };\n    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };\n    ${contractSrc};\n    return handle;\n  `;\n}\n\nexports.normalizeContractSource = normalizeContractSource;","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/@kyve/contract-lib/node_modules/smartweave/lib/utils.js"],"names":["Object","defineProperty","exports","value","normalizeContractSource","log","arrayToHex","formatTags","unpackTags","getTag","tx","name","tags","get","tag","decode","string","e","result","hasOwnProperty","arr","str","a","toString","slice","arweave","getConfig","api","logging","logger","console","contractSrc","replace"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,uBAAR,GAAkCF,OAAO,CAACG,GAAR,GAAcH,OAAO,CAACI,UAAR,GAAqBJ,OAAO,CAACK,UAAR,GAAqBL,OAAO,CAACM,UAAR,GAAqBN,OAAO,CAACO,MAAR,GAAiB,KAAK,CAArI;;AACA,SAASA,MAAT,CAAgBC,EAAhB,EAAoBC,IAApB,EAA0B;AACtB,QAAMC,IAAI,GAAGF,EAAE,CAACG,GAAH,CAAO,MAAP,CAAb;;AACA,OAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;AACpB;AACA,QAAI;AACA,UAAIE,GAAG,CAACD,GAAJ,CAAQ,MAAR,EAAgB;AAAEE,QAAAA,MAAM,EAAE,IAAV;AAAgBC,QAAAA,MAAM,EAAE;AAAxB,OAAhB,MAAoDL,IAAxD,EAA8D;AAC1D,eAAOG,GAAG,CAACD,GAAJ,CAAQ,OAAR,EAAiB;AAAEE,UAAAA,MAAM,EAAE,IAAV;AAAgBC,UAAAA,MAAM,EAAE;AAAxB,SAAjB,CAAP;AACH,OAHD,CAIA;;AACH,KALD,CAMA,OAAOC,CAAP,EAAU,CAAG;AAChB;;AACD,SAAO,KAAP;AACH;;AACDf,OAAO,CAACO,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,UAAT,CAAoBE,EAApB,EAAwB;AACpB,QAAME,IAAI,GAAGF,EAAE,CAACG,GAAH,CAAO,MAAP,CAAb;AACA,QAAMK,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMJ,GAAX,IAAkBF,IAAlB,EAAwB;AACpB,QAAI;AACA,YAAMD,IAAI,GAAGG,GAAG,CAACD,GAAJ,CAAQ,MAAR,EAAgB;AAAEE,QAAAA,MAAM,EAAE,IAAV;AAAgBC,QAAAA,MAAM,EAAE;AAAxB,OAAhB,CAAb;AACA,YAAMb,KAAK,GAAGW,GAAG,CAACD,GAAJ,CAAQ,OAAR,EAAiB;AAAEE,QAAAA,MAAM,EAAE,IAAV;AAAgBC,QAAAA,MAAM,EAAE;AAAxB,OAAjB,CAAd;;AACA,UAAI,CAACE,MAAM,CAACC,cAAP,CAAsBR,IAAtB,CAAL,EAAkC;AAC9BO,QAAAA,MAAM,CAACP,IAAD,CAAN,GAAeR,KAAf;AACA;AACH;;AACDe,MAAAA,MAAM,CAACP,IAAD,CAAN,GAAe,CAAC,GAAGO,MAAM,CAACP,IAAD,CAAV,EAAkBR,KAAlB,CAAf;AACH,KARD,CASA,OAAOc,CAAP,EAAU,CACN;AACH;AACJ;;AACD,SAAOC,MAAP;AACH;;AACDhB,OAAO,CAACM,UAAR,GAAqBA,UAArB;;AACA,SAASD,UAAT,CAAoBK,IAApB,EAA0B;AACtB,QAAMM,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMJ,GAAX,IAAkBF,IAAlB,EAAwB;AACpB,UAAM;AAAED,MAAAA,IAAF;AAAQR,MAAAA;AAAR,QAAkBW,GAAxB;;AACA,QAAI,CAACI,MAAM,CAACC,cAAP,CAAsBR,IAAtB,CAAL,EAAkC;AAC9BO,MAAAA,MAAM,CAACP,IAAD,CAAN,GAAeR,KAAf;AACA;AACH;;AACDe,IAAAA,MAAM,CAACP,IAAD,CAAN,GAAe,CAAC,GAAGO,MAAM,CAACP,IAAD,CAAV,EAAkBR,KAAlB,CAAf;AACH;;AACD,SAAOe,MAAP;AACH;;AACDhB,OAAO,CAACK,UAAR,GAAqBA,UAArB;;AACA,SAASD,UAAT,CAAoBc,GAApB,EAAyB;AACrB,MAAIC,GAAG,GAAG,EAAV;;AACA,OAAK,MAAMC,CAAX,IAAgBF,GAAhB,EAAqB;AACjBC,IAAAA,GAAG,IAAI,CAAC,MAAMC,CAAC,CAACC,QAAF,CAAW,EAAX,CAAP,EAAuBC,KAAvB,CAA6B,CAAC,CAA9B,CAAP;AACH;;AACD,SAAOH,GAAP;AACH;;AACDnB,OAAO,CAACI,UAAR,GAAqBA,UAArB;;AACA,SAASD,GAAT,CAAaoB,OAAb,EAAsB,GAAGJ,GAAzB,EAA8B;AAC1B,MAAI,CAACI,OAAD,IAAY,CAACA,OAAO,CAACC,SAAR,GAAoBC,GAApB,CAAwBC,OAAzC,EACI;AACJ,SAAOH,OAAO,CAACC,SAAR,GAAoBC,GAApB,CAAwBE,MAA/B,KAA0C,UAA1C,GAAuDJ,OAAO,CAACC,SAAR,GAAoBC,GAApB,CAAwBE,MAAxB,CAA+B,GAAGR,GAAlC,CAAvD,GAAgGS,OAAO,CAACzB,GAAR,CAAY,GAAGgB,GAAf,CAAhG;AACH;;AACDnB,OAAO,CAACG,GAAR,GAAcA,GAAd;;AACA,SAASD,uBAAT,CAAiC2B,WAAjC,EAA8C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,EAAAA,WAAW,GAAGA,WAAW,CACpBC,OADS,CACD,uCADC,EACwC,uBADxC,EAETA,OAFS,CAED,+BAFC,EAEgC,iBAFhC,EAGTA,OAHS,CAGD,qBAHC,EAGsB,EAHtB,EAITA,OAJS,CAID,8BAJC,EAI+B,EAJ/B,EAKTA,OALS,CAKD,oBALC,EAKqB,EALrB,CAAd;AAMA,SAAQ;AACZ;AACA;AACA;AACA;AACA,MAAMD,WAAY;AAClB;AACA,GAPI;AAQH;;AACD7B,OAAO,CAACE,uBAAR,GAAkCA,uBAAlC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeContractSource = exports.log = exports.arrayToHex = exports.formatTags = exports.unpackTags = exports.getTag = void 0;\nfunction getTag(tx, name) {\n    const tags = tx.get('tags');\n    for (const tag of tags) {\n        // decoding tags can throw on invalid utf8 data.\n        try {\n            if (tag.get('name', { decode: true, string: true }) === name) {\n                return tag.get('value', { decode: true, string: true });\n            }\n            // tslint:disable-next-line: no-empty\n        }\n        catch (e) { }\n    }\n    return false;\n}\nexports.getTag = getTag;\n/**\n * Unpacks string tags from a Tx and puts in a KV map\n * Tags that appear multiple times will be converted to an\n * array of string values, ordered as they appear in the tx.\n *\n * @param tx\n */\nfunction unpackTags(tx) {\n    const tags = tx.get('tags');\n    const result = {};\n    for (const tag of tags) {\n        try {\n            const name = tag.get('name', { decode: true, string: true });\n            const value = tag.get('value', { decode: true, string: true });\n            if (!result.hasOwnProperty(name)) {\n                result[name] = value;\n                continue;\n            }\n            result[name] = [...result[name], value];\n        }\n        catch (e) {\n            // ignore tags with invalid utf-8 strings in key or value.\n        }\n    }\n    return result;\n}\nexports.unpackTags = unpackTags;\nfunction formatTags(tags) {\n    const result = {};\n    for (const tag of tags) {\n        const { name, value } = tag;\n        if (!result.hasOwnProperty(name)) {\n            result[name] = value;\n            continue;\n        }\n        result[name] = [...result[name], value];\n    }\n    return result;\n}\nexports.formatTags = formatTags;\nfunction arrayToHex(arr) {\n    let str = '';\n    for (const a of arr) {\n        str += ('0' + a.toString(16)).slice(-2);\n    }\n    return str;\n}\nexports.arrayToHex = arrayToHex;\nfunction log(arweave, ...str) {\n    if (!arweave || !arweave.getConfig().api.logging)\n        return;\n    typeof arweave.getConfig().api.logger === 'function' ? arweave.getConfig().api.logger(...str) : console.log(...str);\n}\nexports.log = log;\nfunction normalizeContractSource(contractSrc) {\n    // Convert from ES Module format to something we can run inside a Function.\n    // Removes the `export` keyword and adds ;return handle to the end of the function.\n    // Additionally it removes 'IIFE' declarations\n    // (which may be generated when bundling multiple sources into one output file\n    // - eg. using esbuild's \"IIFE\" bundle format).\n    // We also assign the passed in SmartWeaveGlobal to SmartWeave, and declare\n    // the ContractError exception.\n    // We then use `new Function()` which we can call and get back the returned handle function\n    // which has access to the per-instance globals.\n    contractSrc = contractSrc\n        .replace(/export\\s+async\\s+function\\s+handle/gmu, 'async function handle')\n        .replace(/export\\s+function\\s+handle/gmu, 'function handle')\n        .replace(/\\(\\s*\\(\\)\\s*=>\\s*{/g, '')\n        .replace(/\\s*\\(\\s*function\\s*\\(\\)\\s*{/g, '')\n        .replace(/}\\s*\\)\\s*\\(\\)\\s*;/g, '');\n    return `\n    const [SmartWeave, BigNumber, clarity] = arguments;\n    clarity.SmartWeave = SmartWeave;\n    class ContractError extends Error { constructor(message) { super(message); this.name = \\'ContractError\\' } };\n    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };\n    ${contractSrc};\n    return handle;\n  `;\n}\nexports.normalizeContractSource = normalizeContractSource;\n"]},"metadata":{},"sourceType":"script"}