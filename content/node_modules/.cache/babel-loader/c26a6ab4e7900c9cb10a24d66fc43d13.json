{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar escapeStringRegexp = require('escape-string-regexp');\n\nvar regexpCache = new Map();\n\nfunction makeRegexp(pattern, options) {\n  options = _objectSpread({\n    caseSensitive: false\n  }, options);\n  var cacheKey = pattern + JSON.stringify(options);\n\n  if (regexpCache.has(cacheKey)) {\n    return regexpCache.get(cacheKey);\n  }\n\n  var negated = pattern[0] === '!';\n\n  if (negated) {\n    pattern = pattern.slice(1);\n  }\n\n  pattern = escapeStringRegexp(pattern).replace(/\\\\\\*/g, '.*');\n  var regexp = new RegExp(\"^\".concat(pattern, \"$\"), options.caseSensitive ? '' : 'i');\n  regexp.negated = negated;\n  regexpCache.set(cacheKey, regexp);\n  return regexp;\n}\n\nmodule.exports = function (inputs, patterns, options) {\n  if (!(Array.isArray(inputs) && Array.isArray(patterns))) {\n    throw new TypeError(\"Expected two arrays, got \".concat(typeof inputs, \" \").concat(typeof patterns));\n  }\n\n  if (patterns.length === 0) {\n    return inputs;\n  }\n\n  var firstNegated = patterns[0][0] === '!';\n  patterns = patterns.map(function (pattern) {\n    return makeRegexp(pattern, options);\n  });\n  var result = [];\n\n  var _iterator = _createForOfIteratorHelper(inputs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var input = _step.value;\n      // If first pattern is negated we include everything to match user expectation\n      var matches = firstNegated;\n\n      var _iterator2 = _createForOfIteratorHelper(patterns),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pattern = _step2.value;\n\n          if (pattern.test(input)) {\n            matches = !pattern.negated;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (matches) {\n        result.push(input);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n};\n\nmodule.exports.isMatch = function (input, pattern, options) {\n  var inputArray = Array.isArray(input) ? input : [input];\n  var patternArray = Array.isArray(pattern) ? pattern : [pattern];\n  return inputArray.some(function (input) {\n    return patternArray.every(function (pattern) {\n      var regexp = makeRegexp(pattern, options);\n      var matches = regexp.test(input);\n      return regexp.negated ? !matches : matches;\n    });\n  });\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/matcher/index.js"],"names":["escapeStringRegexp","require","regexpCache","Map","makeRegexp","pattern","options","caseSensitive","cacheKey","JSON","stringify","has","get","negated","slice","replace","regexp","RegExp","set","module","exports","inputs","patterns","Array","isArray","TypeError","length","firstNegated","map","result","input","matches","test","push","isMatch","inputArray","patternArray","some","every"],"mappings":"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","sourcesContent":["'use strict';\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst regexpCache = new Map();\n\nfunction makeRegexp(pattern, options) {\n\toptions = {\n\t\tcaseSensitive: false,\n\t\t...options\n\t};\n\n\tconst cacheKey = pattern + JSON.stringify(options);\n\n\tif (regexpCache.has(cacheKey)) {\n\t\treturn regexpCache.get(cacheKey);\n\t}\n\n\tconst negated = pattern[0] === '!';\n\n\tif (negated) {\n\t\tpattern = pattern.slice(1);\n\t}\n\n\tpattern = escapeStringRegexp(pattern).replace(/\\\\\\*/g, '.*');\n\n\tconst regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? '' : 'i');\n\tregexp.negated = negated;\n\tregexpCache.set(cacheKey, regexp);\n\n\treturn regexp;\n}\n\nmodule.exports = (inputs, patterns, options) => {\n\tif (!(Array.isArray(inputs) && Array.isArray(patterns))) {\n\t\tthrow new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);\n\t}\n\n\tif (patterns.length === 0) {\n\t\treturn inputs;\n\t}\n\n\tconst firstNegated = patterns[0][0] === '!';\n\n\tpatterns = patterns.map(pattern => makeRegexp(pattern, options));\n\n\tconst result = [];\n\n\tfor (const input of inputs) {\n\t\t// If first pattern is negated we include everything to match user expectation\n\t\tlet matches = firstNegated;\n\n\t\tfor (const pattern of patterns) {\n\t\t\tif (pattern.test(input)) {\n\t\t\t\tmatches = !pattern.negated;\n\t\t\t}\n\t\t}\n\n\t\tif (matches) {\n\t\t\tresult.push(input);\n\t\t}\n\t}\n\n\treturn result;\n};\n\nmodule.exports.isMatch = (input, pattern, options) => {\n\tconst inputArray = Array.isArray(input) ? input : [input];\n\tconst patternArray = Array.isArray(pattern) ? pattern : [pattern];\n\n\treturn inputArray.some(input => {\n\t\treturn patternArray.every(pattern => {\n\t\t\tconst regexp = makeRegexp(pattern, options);\n\t\t\tconst matches = regexp.test(input);\n\t\t\treturn regexp.negated ? !matches : matches;\n\t\t});\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}