{"ast":null,"code":"'use strict';\n\nvar interlaceUtils = require('./interlace');\n\nvar pixelBppMap = {\n  1: {\n    // L\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 0xff\n  },\n  2: {\n    // LA\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 1\n  },\n  3: {\n    // RGB\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 0xff\n  },\n  4: {\n    // RGBA\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3\n  }\n};\n\nfunction bitRetriever(data, depth) {\n  var leftOver = [];\n  var i = 0;\n\n  function split() {\n    if (i === data.length) {\n      throw new Error('Ran out of data');\n    }\n\n    var byte = data[i];\n    i++;\n    var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;\n\n    switch (depth) {\n      default:\n        throw new Error('unrecognised depth');\n\n      case 16:\n        byte2 = data[i];\n        i++;\n        leftOver.push((byte << 8) + byte2);\n        break;\n\n      case 4:\n        byte2 = byte & 0x0f;\n        byte1 = byte >> 4;\n        leftOver.push(byte1, byte2);\n        break;\n\n      case 2:\n        byte4 = byte & 3;\n        byte3 = byte >> 2 & 3;\n        byte2 = byte >> 4 & 3;\n        byte1 = byte >> 6 & 3;\n        leftOver.push(byte1, byte2, byte3, byte4);\n        break;\n\n      case 1:\n        byte8 = byte & 1;\n        byte7 = byte >> 1 & 1;\n        byte6 = byte >> 2 & 1;\n        byte5 = byte >> 3 & 1;\n        byte4 = byte >> 4 & 1;\n        byte3 = byte >> 5 & 1;\n        byte2 = byte >> 6 & 1;\n        byte1 = byte >> 7 & 1;\n        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);\n        break;\n    }\n  }\n\n  return {\n    get: function (count) {\n      while (leftOver.length < count) {\n        split();\n      }\n\n      var returner = leftOver.slice(0, count);\n      leftOver = leftOver.slice(count);\n      return returner;\n    },\n    resetAfterLine: function () {\n      leftOver.length = 0;\n    },\n    end: function () {\n      if (i !== data.length) {\n        throw new Error('extra data found');\n      }\n    }\n  };\n}\n\nfunction mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {\n  // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n\n        if (i === data.length) {\n          throw new Error('Ran out of data');\n        }\n\n        pxData[pxPos + i] = idx !== 0xff ? data[idx + rawPos] : 0xff;\n      }\n\n      rawPos += bpp; //eslint-disable-line no-param-reassign\n    }\n  }\n\n  return rawPos;\n}\n\nfunction mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {\n  // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pixelData = bits.get(bpp);\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        pxData[pxPos + i] = idx !== 0xff ? pixelData[idx] : maxBit;\n      }\n    }\n\n    bits.resetAfterLine();\n  }\n}\n\nexports.dataToBitMap = function (data, bitmapInfo) {\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var depth = bitmapInfo.depth;\n  var bpp = bitmapInfo.bpp;\n  var interlace = bitmapInfo.interlace;\n\n  if (depth !== 8) {\n    var bits = bitRetriever(data, depth);\n  }\n\n  var pxData;\n\n  if (depth <= 8) {\n    pxData = new Buffer(width * height * 4);\n  } else {\n    pxData = new Uint16Array(width * height * 4);\n  }\n\n  var maxBit = Math.pow(2, depth) - 1;\n  var rawPos = 0;\n  var images;\n  var getPxPos;\n\n  if (interlace) {\n    images = interlaceUtils.getImagePasses(width, height);\n    getPxPos = interlaceUtils.getInterlaceIterator(width, height);\n  } else {\n    var nonInterlacedPxPos = 0;\n\n    getPxPos = function () {\n      var returner = nonInterlacedPxPos;\n      nonInterlacedPxPos += 4;\n      return returner;\n    };\n\n    images = [{\n      width: width,\n      height: height\n    }];\n  }\n\n  for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {\n    if (depth === 8) {\n      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);\n    } else {\n      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);\n    }\n  }\n\n  if (depth === 8) {\n    if (rawPos !== data.length) {\n      throw new Error('extra data found');\n    }\n  } else {\n    bits.end();\n  }\n\n  return pxData;\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/pngjs-nozlib/lib/bitmapper.js"],"names":["interlaceUtils","require","pixelBppMap","bitRetriever","data","depth","leftOver","i","split","length","Error","byte","byte8","byte7","byte6","byte5","byte4","byte3","byte2","byte1","push","get","count","returner","slice","resetAfterLine","end","mapImage8Bit","image","pxData","getPxPos","bpp","rawPos","imageWidth","width","imageHeight","height","imagePass","index","y","x","pxPos","idx","mapImageCustomBit","bits","maxBit","pixelData","exports","dataToBitMap","bitmapInfo","interlace","Buffer","Uint16Array","Math","pow","images","getImagePasses","getInterlaceIterator","nonInterlacedPxPos","imageIndex"],"mappings":"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","sourcesContent":["'use strict';\n\nvar interlaceUtils = require('./interlace');\n\nvar pixelBppMap = {\n  1: { // L\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 0xff\n  },\n  2: { // LA\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 1\n  },\n  3: { // RGB\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 0xff\n  },\n  4: { // RGBA\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3\n  }\n};\n\nfunction bitRetriever(data, depth) {\n\n  var leftOver = [];\n  var i = 0;\n\n  function split() {\n    if (i === data.length) {\n      throw new Error('Ran out of data');\n    }\n    var byte = data[i];\n    i++;\n    var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;\n    switch (depth) {\n      default:\n        throw new Error('unrecognised depth');\n      case 16:\n        byte2 = data[i];\n        i++;\n        leftOver.push(((byte << 8) + byte2));\n        break;\n      case 4:\n        byte2 = byte & 0x0f;\n        byte1 = byte >> 4;\n        leftOver.push(byte1, byte2);\n        break;\n      case 2:\n        byte4 = byte & 3;\n        byte3 = byte >> 2 & 3;\n        byte2 = byte >> 4 & 3;\n        byte1 = byte >> 6 & 3;\n        leftOver.push(byte1, byte2, byte3, byte4);\n        break;\n      case 1:\n        byte8 = byte & 1;\n        byte7 = byte >> 1 & 1;\n        byte6 = byte >> 2 & 1;\n        byte5 = byte >> 3 & 1;\n        byte4 = byte >> 4 & 1;\n        byte3 = byte >> 5 & 1;\n        byte2 = byte >> 6 & 1;\n        byte1 = byte >> 7 & 1;\n        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);\n        break;\n    }\n  }\n\n  return {\n    get: function(count) {\n      while (leftOver.length < count) {\n        split();\n      }\n      var returner = leftOver.slice(0, count);\n      leftOver = leftOver.slice(count);\n      return returner;\n    },\n    resetAfterLine: function() {\n      leftOver.length = 0;\n    },\n    end: function() {\n      if (i !== data.length) {\n        throw new Error('extra data found');\n      }\n    }\n  };\n}\n\nfunction mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) { // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        if (i === data.length) {\n          throw new Error('Ran out of data');\n        }\n        pxData[pxPos + i] = idx !== 0xff ? data[idx + rawPos] : 0xff;\n      }\n      rawPos += bpp; //eslint-disable-line no-param-reassign\n    }\n  }\n  return rawPos;\n}\n\nfunction mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) { // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pixelData = bits.get(bpp);\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        pxData[pxPos + i] = idx !== 0xff ? pixelData[idx] : maxBit;\n      }\n    }\n    bits.resetAfterLine();\n  }\n}\n\nexports.dataToBitMap = function(data, bitmapInfo) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var depth = bitmapInfo.depth;\n  var bpp = bitmapInfo.bpp;\n  var interlace = bitmapInfo.interlace;\n\n  if (depth !== 8) {\n    var bits = bitRetriever(data, depth);\n  }\n  var pxData;\n  if (depth <= 8) {\n    pxData = new Buffer(width * height * 4);\n  }\n  else {\n    pxData = new Uint16Array(width * height * 4);\n  }\n  var maxBit = Math.pow(2, depth) - 1;\n  var rawPos = 0;\n  var images;\n  var getPxPos;\n\n  if (interlace) {\n    images = interlaceUtils.getImagePasses(width, height);\n    getPxPos = interlaceUtils.getInterlaceIterator(width, height);\n  }\n  else {\n    var nonInterlacedPxPos = 0;\n    getPxPos = function() {\n      var returner = nonInterlacedPxPos;\n      nonInterlacedPxPos += 4;\n      return returner;\n    };\n    images = [{ width: width, height: height }];\n  }\n\n  for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {\n    if (depth === 8) {\n      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);\n    }\n    else {\n      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);\n    }\n  }\n  if (depth === 8) {\n    if (rawPos !== data.length) {\n      throw new Error('extra data found');\n    }\n  }\n  else {\n    bits.end();\n  }\n\n  return pxData;\n};\n"]},"metadata":{},"sourceType":"script"}