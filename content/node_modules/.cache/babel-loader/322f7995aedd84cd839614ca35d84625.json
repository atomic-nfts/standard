{"ast":null,"code":"var Stream = require('stream'); // through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\n\nexports = module.exports = through;\nthrough.through = through; //create a readable writable stream.\n\nfunction through(write, end, opts) {\n  write = write || function (data) {\n    this.queue(data);\n  };\n\n  end = end || function () {\n    this.queue(null);\n  };\n\n  var ended = false,\n      destroyed = false,\n      buffer = [],\n      _ended = false;\n  var stream = new Stream();\n  stream.readable = stream.writable = true;\n  stream.paused = false; //  stream.autoPause   = !(opts && opts.autoPause   === false)\n\n  stream.autoDestroy = !(opts && opts.autoDestroy === false);\n\n  stream.write = function (data) {\n    write.call(this, data);\n    return !stream.paused;\n  };\n\n  function drain() {\n    while (buffer.length && !stream.paused) {\n      var data = buffer.shift();\n      if (null === data) return stream.emit('end');else stream.emit('data', data);\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n    //    console.error(ended)\n    if (_ended) return stream;\n    if (data === null) _ended = true;\n    buffer.push(data);\n    drain();\n    return stream;\n  }; //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n\n  stream.on('end', function () {\n    stream.readable = false;\n    if (!stream.writable && stream.autoDestroy) process.nextTick(function () {\n      stream.destroy();\n    });\n  });\n\n  function _end() {\n    stream.writable = false;\n    end.call(stream);\n    if (!stream.readable && stream.autoDestroy) stream.destroy();\n  }\n\n  stream.end = function (data) {\n    if (ended) return;\n    ended = true;\n    if (arguments.length) stream.write(data);\n\n    _end(); // will emit or queue\n\n\n    return stream;\n  };\n\n  stream.destroy = function () {\n    if (destroyed) return;\n    destroyed = true;\n    ended = true;\n    buffer.length = 0;\n    stream.writable = stream.readable = false;\n    stream.emit('close');\n    return stream;\n  };\n\n  stream.pause = function () {\n    if (stream.paused) return;\n    stream.paused = true;\n    return stream;\n  };\n\n  stream.resume = function () {\n    if (stream.paused) {\n      stream.paused = false;\n      stream.emit('resume');\n    }\n\n    drain(); //may have become paused again,\n    //as drain emits 'data'.\n\n    if (!stream.paused) stream.emit('drain');\n    return stream;\n  };\n\n  return stream;\n}","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/through/index.js"],"names":["Stream","require","exports","module","through","write","end","opts","data","queue","ended","destroyed","buffer","_ended","stream","readable","writable","paused","autoDestroy","call","drain","length","shift","emit","push","on","process","nextTick","destroy","_end","arguments","pause","resume"],"mappings":"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","sourcesContent":["var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n"]},"metadata":{},"sourceType":"script"}