{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ArweaveUtils = require(\"../utils\");\n\nvar WebCryptoDriver = /*#__PURE__*/function () {\n  function WebCryptoDriver() {\n    _classCallCheck(this, WebCryptoDriver);\n\n    this.keyLength = 4096;\n    this.publicExponent = 0x10001;\n    this.hashAlgorithm = \"sha256\";\n\n    if (!this.detectWebCrypto()) {\n      throw new Error(\"SubtleCrypto not available!\");\n    }\n\n    this.driver = crypto.subtle;\n  }\n\n  _createClass(WebCryptoDriver, [{\n    key: \"generateJWK\",\n    value: function () {\n      var _generateJWK = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var cryptoKey, jwk;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.driver.generateKey({\n                  name: \"RSA-PSS\",\n                  modulusLength: 4096,\n                  publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                  hash: {\n                    name: \"SHA-256\"\n                  }\n                }, true, [\"sign\"]);\n\n              case 2:\n                cryptoKey = _context.sent;\n                _context.next = 5;\n                return this.driver.exportKey(\"jwk\", cryptoKey.privateKey);\n\n              case 5:\n                jwk = _context.sent;\n                return _context.abrupt(\"return\", {\n                  kty: jwk.kty,\n                  e: jwk.e,\n                  n: jwk.n,\n                  d: jwk.d,\n                  p: jwk.p,\n                  q: jwk.q,\n                  dp: jwk.dp,\n                  dq: jwk.dq,\n                  qi: jwk.qi\n                });\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function generateJWK() {\n        return _generateJWK.apply(this, arguments);\n      }\n\n      return generateJWK;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(jwk, data) {\n        var _ref,\n            saltLength,\n            signature,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, saltLength = _ref.saltLength;\n                _context2.t0 = this.driver;\n                _context2.t1 = {\n                  name: \"RSA-PSS\",\n                  saltLength: 32\n                };\n                _context2.next = 5;\n                return this.jwkToCryptoKey(jwk);\n\n              case 5:\n                _context2.t2 = _context2.sent;\n                _context2.t3 = data;\n                _context2.next = 9;\n                return _context2.t0.sign.call(_context2.t0, _context2.t1, _context2.t2, _context2.t3);\n\n              case 9:\n                signature = _context2.sent;\n                return _context2.abrupt(\"return\", new Uint8Array(signature));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sign(_x, _x2) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data) {\n        var algorithm,\n            digest,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                algorithm = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : \"SHA-256\";\n                _context3.next = 3;\n                return this.driver.digest(algorithm, data);\n\n              case 3:\n                digest = _context3.sent;\n                return _context3.abrupt(\"return\", new Uint8Array(digest));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function hash(_x3) {\n        return _hash.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(publicModulus, data, signature) {\n        var publicKey, key, verifyWith32, verifyWith0;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                publicKey = {\n                  kty: \"RSA\",\n                  e: \"AQAB\",\n                  n: publicModulus\n                };\n                _context4.next = 3;\n                return this.jwkToPublicCryptoKey(publicKey);\n\n              case 3:\n                key = _context4.sent;\n                verifyWith32 = this.driver.verify({\n                  name: \"RSA-PSS\",\n                  saltLength: 32\n                }, key, signature, data);\n                verifyWith0 = this.driver.verify({\n                  name: \"RSA-PSS\",\n                  saltLength: 0\n                }, key, signature, data);\n                return _context4.abrupt(\"return\", verifyWith32 || verifyWith0);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function verify(_x4, _x5, _x6) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"jwkToCryptoKey\",\n    value: function () {\n      var _jwkToCryptoKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(jwk) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.driver.importKey(\"jwk\", jwk, {\n                  name: \"RSA-PSS\",\n                  hash: {\n                    name: \"SHA-256\"\n                  }\n                }, false, [\"sign\"]));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function jwkToCryptoKey(_x7) {\n        return _jwkToCryptoKey.apply(this, arguments);\n      }\n\n      return jwkToCryptoKey;\n    }()\n  }, {\n    key: \"jwkToPublicCryptoKey\",\n    value: function () {\n      var _jwkToPublicCryptoKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(publicJwk) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.driver.importKey(\"jwk\", publicJwk, {\n                  name: \"RSA-PSS\",\n                  hash: {\n                    name: \"SHA-256\"\n                  }\n                }, false, [\"verify\"]));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function jwkToPublicCryptoKey(_x8) {\n        return _jwkToPublicCryptoKey.apply(this, arguments);\n      }\n\n      return jwkToPublicCryptoKey;\n    }()\n  }, {\n    key: \"detectWebCrypto\",\n    value: function detectWebCrypto() {\n      if (typeof crypto === \"undefined\") {\n        return false;\n      }\n\n      var subtle = crypto === null || crypto === void 0 ? void 0 : crypto.subtle;\n\n      if (subtle === undefined) {\n        return false;\n      }\n\n      var names = [\"generateKey\", \"importKey\", \"exportKey\", \"digest\", \"sign\"];\n      return names.every(function (name) {\n        return typeof subtle[name] === \"function\";\n      });\n    }\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data, key, salt) {\n        var initialKey, derivedkey, iv, encryptedData;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n                  name: \"PBKDF2\",\n                  length: 32\n                }, false, [\"deriveKey\"]);\n\n              case 2:\n                initialKey = _context7.sent;\n                _context7.next = 5;\n                return this.driver.deriveKey({\n                  name: \"PBKDF2\",\n                  salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer(\"salt\"),\n                  iterations: 100000,\n                  hash: \"SHA-256\"\n                }, initialKey, {\n                  name: \"AES-CBC\",\n                  length: 256\n                }, false, [\"encrypt\", \"decrypt\"]);\n\n              case 5:\n                derivedkey = _context7.sent;\n                iv = new Uint8Array(16);\n                crypto.getRandomValues(iv);\n                _context7.next = 10;\n                return this.driver.encrypt({\n                  name: \"AES-CBC\",\n                  iv: iv\n                }, derivedkey, data);\n\n              case 10:\n                encryptedData = _context7.sent;\n                return _context7.abrupt(\"return\", ArweaveUtils.concatBuffers([iv, encryptedData]));\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function encrypt(_x9, _x10, _x11) {\n        return _encrypt.apply(this, arguments);\n      }\n\n      return encrypt;\n    }()\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(encrypted, key, salt) {\n        var initialKey, derivedkey, iv, data;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n                  name: \"PBKDF2\",\n                  length: 32\n                }, false, [\"deriveKey\"]);\n\n              case 2:\n                initialKey = _context8.sent;\n                _context8.next = 5;\n                return this.driver.deriveKey({\n                  name: \"PBKDF2\",\n                  salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer(\"salt\"),\n                  iterations: 100000,\n                  hash: \"SHA-256\"\n                }, initialKey, {\n                  name: \"AES-CBC\",\n                  length: 256\n                }, false, [\"encrypt\", \"decrypt\"]);\n\n              case 5:\n                derivedkey = _context8.sent;\n                iv = encrypted.slice(0, 16);\n                _context8.next = 9;\n                return this.driver.decrypt({\n                  name: \"AES-CBC\",\n                  iv: iv\n                }, derivedkey, encrypted.slice(16));\n\n              case 9:\n                data = _context8.sent;\n                return _context8.abrupt(\"return\", ArweaveUtils.concatBuffers([data]));\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function decrypt(_x12, _x13, _x14) {\n        return _decrypt.apply(this, arguments);\n      }\n\n      return decrypt;\n    }()\n  }]);\n\n  return WebCryptoDriver;\n}();\n\nexports.default = WebCryptoDriver;","map":{"version":3,"sources":["../../../../../src/common/lib/crypto/webcrypto-driver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArweaveUtils = require(\"../utils\");\nclass WebCryptoDriver {\n    constructor() {\n        this.keyLength = 4096;\n        this.publicExponent = 0x10001;\n        this.hashAlgorithm = \"sha256\";\n        if (!this.detectWebCrypto()) {\n            throw new Error(\"SubtleCrypto not available!\");\n        }\n        this.driver = crypto.subtle;\n    }\n    async generateJWK() {\n        let cryptoKey = await this.driver.generateKey({\n            name: \"RSA-PSS\",\n            modulusLength: 4096,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n            hash: {\n                name: \"SHA-256\",\n            },\n        }, true, [\"sign\"]);\n        let jwk = await this.driver.exportKey(\"jwk\", cryptoKey.privateKey);\n        return {\n            kty: jwk.kty,\n            e: jwk.e,\n            n: jwk.n,\n            d: jwk.d,\n            p: jwk.p,\n            q: jwk.q,\n            dp: jwk.dp,\n            dq: jwk.dq,\n            qi: jwk.qi,\n        };\n    }\n    async sign(jwk, data, { saltLength } = {}) {\n        let signature = await this.driver.sign({\n            name: \"RSA-PSS\",\n            saltLength: 32,\n        }, await this.jwkToCryptoKey(jwk), data);\n        return new Uint8Array(signature);\n    }\n    async hash(data, algorithm = \"SHA-256\") {\n        let digest = await this.driver.digest(algorithm, data);\n        return new Uint8Array(digest);\n    }\n    async verify(publicModulus, data, signature) {\n        const publicKey = {\n            kty: \"RSA\",\n            e: \"AQAB\",\n            n: publicModulus,\n        };\n        const key = await this.jwkToPublicCryptoKey(publicKey);\n        const verifyWith32 = this.driver.verify({\n            name: \"RSA-PSS\",\n            saltLength: 32,\n        }, key, signature, data);\n        const verifyWith0 = this.driver.verify({\n            name: \"RSA-PSS\",\n            saltLength: 0,\n        }, key, signature, data);\n        return verifyWith32 || verifyWith0;\n    }\n    async jwkToCryptoKey(jwk) {\n        return this.driver.importKey(\"jwk\", jwk, {\n            name: \"RSA-PSS\",\n            hash: {\n                name: \"SHA-256\",\n            },\n        }, false, [\"sign\"]);\n    }\n    async jwkToPublicCryptoKey(publicJwk) {\n        return this.driver.importKey(\"jwk\", publicJwk, {\n            name: \"RSA-PSS\",\n            hash: {\n                name: \"SHA-256\",\n            },\n        }, false, [\"verify\"]);\n    }\n    detectWebCrypto() {\n        if (typeof crypto === \"undefined\") {\n            return false;\n        }\n        const subtle = crypto === null || crypto === void 0 ? void 0 : crypto.subtle;\n        if (subtle === undefined) {\n            return false;\n        }\n        const names = [\n            \"generateKey\",\n            \"importKey\",\n            \"exportKey\",\n            \"digest\",\n            \"sign\",\n        ];\n        return names.every((name) => typeof subtle[name] === \"function\");\n    }\n    async encrypt(data, key, salt) {\n        const initialKey = await this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n            name: \"PBKDF2\",\n            length: 32,\n        }, false, [\"deriveKey\"]);\n        // const salt = ArweaveUtils.stringToBuffer(\"salt\");\n        // create a random string for deriving the key\n        // const salt = this.driver.randomBytes(16).toString('hex');\n        const derivedkey = await this.driver.deriveKey({\n            name: \"PBKDF2\",\n            salt: salt\n                ? ArweaveUtils.stringToBuffer(salt)\n                : ArweaveUtils.stringToBuffer(\"salt\"),\n            iterations: 100000,\n            hash: \"SHA-256\",\n        }, initialKey, {\n            name: \"AES-CBC\",\n            length: 256,\n        }, false, [\"encrypt\", \"decrypt\"]);\n        const iv = new Uint8Array(16);\n        crypto.getRandomValues(iv);\n        const encryptedData = await this.driver.encrypt({\n            name: \"AES-CBC\",\n            iv: iv,\n        }, derivedkey, data);\n        return ArweaveUtils.concatBuffers([iv, encryptedData]);\n    }\n    async decrypt(encrypted, key, salt) {\n        const initialKey = await this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n            name: \"PBKDF2\",\n            length: 32,\n        }, false, [\"deriveKey\"]);\n        // const salt = ArweaveUtils.stringToBuffer(\"pepper\");\n        const derivedkey = await this.driver.deriveKey({\n            name: \"PBKDF2\",\n            salt: salt\n                ? ArweaveUtils.stringToBuffer(salt)\n                : ArweaveUtils.stringToBuffer(\"salt\"),\n            iterations: 100000,\n            hash: \"SHA-256\",\n        }, initialKey, {\n            name: \"AES-CBC\",\n            length: 256,\n        }, false, [\"encrypt\", \"decrypt\"]);\n        const iv = encrypted.slice(0, 16);\n        const data = await this.driver.decrypt({\n            name: \"AES-CBC\",\n            iv: iv,\n        }, derivedkey, encrypted.slice(16));\n        // We're just using concat to convert from an array buffer to uint8array\n        return ArweaveUtils.concatBuffers([data]);\n    }\n}\nexports.default = WebCryptoDriver;\n//# sourceMappingURL=webcrypto-driver.js.map"]},"metadata":{},"sourceType":"script"}