{"ast":null,"code":"/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\nvar ncycles = 100; // number of learning cycles\n\nvar netsize = 256; // number of colors used\n\nvar maxnetpos = netsize - 1; // defs for freq and bias\n\nvar netbiasshift = 4; // bias for colour values\n\nvar intbiasshift = 16; // bias for fractions\n\nvar intbias = 1 << intbiasshift;\nvar gammashift = 10;\nvar gamma = 1 << gammashift;\nvar betashift = 10;\nvar beta = intbias >> betashift;\n/* beta = 1/1024 */\n\nvar betagamma = intbias << gammashift - betashift; // defs for decreasing radius factor\n\nvar initrad = netsize >> 3; // for 256 cols, radius starts\n\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\n\nvar radiusbias = 1 << radiusbiasshift;\nvar initradius = initrad * radiusbias; //and decreases by a\n\nvar radiusdec = 30; // factor of 1/30 each cycle\n// defs for decreasing alpha factor\n\nvar alphabiasshift = 10; // alpha starts at 1.0\n\nvar initalpha = 1 << alphabiasshift;\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\n\nvar radbiasshift = 8;\nvar radbias = 1 << radbiasshift;\nvar alpharadbshift = alphabiasshift + radbiasshift;\nvar alpharadbias = 1 << alpharadbshift; // four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\n\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = 3 * prime4;\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\n\nfunction NeuQuant(pixels, samplefac) {\n  var network; // int[netsize][4]\n\n  var netindex; // for network lookup - really 256\n  // bias and freq arrays for learning\n\n  var bias;\n  var freq;\n  var radpower;\n  /*\n    Private Method: init\n     sets up arrays\n  */\n\n  function init() {\n    network = [];\n    netindex = new Int32Array(256);\n    bias = new Int32Array(netsize);\n    freq = new Int32Array(netsize);\n    radpower = new Int32Array(netsize >> 3);\n    var i, v;\n\n    for (i = 0; i < netsize; i++) {\n      v = (i << netbiasshift + 8) / netsize;\n      network[i] = new Float64Array([v, v, v, 0]); //network[i] = [v, v, v, 0]\n\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n  /*\n    Private Method: unbiasnet\n     unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n\n\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n  /*\n    Private Method: altersingle\n     moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n\n\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= alpha * (network[i][0] - b) / initalpha;\n    network[i][1] -= alpha * (network[i][1] - g) / initalpha;\n    network[i][2] -= alpha * (network[i][2] - r) / initalpha;\n  }\n  /*\n    Private Method: alterneigh\n     moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n\n\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n    var p, a;\n\n    while (j < hi || k > lo) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= a * (p[0] - b) / alpharadbias;\n        p[1] -= a * (p[1] - g) / alpharadbias;\n        p[2] -= a * (p[2] - r) / alpharadbias;\n      }\n\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= a * (p[0] - b) / alpharadbias;\n        p[1] -= a * (p[1] - g) / alpharadbias;\n        p[2] -= a * (p[2] - r) / alpharadbias;\n      }\n    }\n  }\n  /*\n    Private Method: contest\n     searches for biased BGR values\n  */\n\n\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n    var i, n, dist, biasdist, betafreq;\n\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = freq[i] >> betashift;\n      freq[i] -= betafreq;\n      bias[i] += betafreq << gammashift;\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return bestbiaspos;\n  }\n  /*\n    Private Method: inxbuild\n     sorts network and builds netindex[0..255]\n  */\n\n\n  function inxbuild() {\n    var i,\n        j,\n        p,\n        q,\n        smallpos,\n        smallval,\n        previouscol = 0,\n        startpos = 0;\n\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n\n        if (q[1] < smallval) {\n          // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n\n      q = network[smallpos]; // swap p (i) and q (smallpos) entries\n\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      } // smallval entry is now in position i\n\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = startpos + i >> 1;\n\n        for (j = previouscol + 1; j < smallval; j++) {\n          netindex[j] = i;\n        }\n\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    netindex[previouscol] = startpos + maxnetpos >> 1;\n\n    for (j = previouscol + 1; j < 256; j++) {\n      netindex[j] = maxnetpos;\n    } // really 256\n\n  }\n  /*\n    Private Method: inxsearch\n     searches for BGR values 0..255 and returns a color index\n  */\n\n\n  function inxsearch(b, g, r) {\n    var a, p, dist;\n    var bestd = 1000; // biggest possible dist is 256*3\n\n    var best = -1;\n    var i = netindex[g]; // index on g\n\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while (i < netsize || j >= 0) {\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; // inx key\n\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n            i++;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n      }\n\n      if (j >= 0) {\n        p = network[j];\n        dist = g - p[1]; // inx key - reverse dif\n\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n            j--;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n      }\n    }\n\n    return best;\n  }\n  /*\n    Private Method: learn\n     \"Main Learning Loop\"\n  */\n\n\n  function learn() {\n    var i;\n    var lengthcount = pixels.length;\n    var alphadec = 30 + (samplefac - 1) / 3;\n    var samplepixels = lengthcount / (3 * samplefac);\n    var delta = ~~(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n    var rad = radius >> radiusbiasshift;\n    if (rad <= 1) rad = 0;\n\n    for (i = 0; i < rad; i++) {\n      radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n    }\n\n    var step;\n\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if (lengthcount % prime1 !== 0) {\n      step = 3 * prime1;\n    } else if (lengthcount % prime2 !== 0) {\n      step = 3 * prime2;\n    } else if (lengthcount % prime3 !== 0) {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n      i++;\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) rad = 0;\n\n        for (j = 0; j < rad; j++) {\n          radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n        }\n      }\n    }\n  }\n  /*\n    Method: buildColormap\n     1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n\n\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n\n  this.buildColormap = buildColormap;\n  /*\n    Method: getColormap\n     builds colormap from the index\n     returns array in the format:\n     >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n\n  function getColormap() {\n    var map = [];\n    var index = [];\n\n    for (var i = 0; i < netsize; i++) {\n      index[network[i][3]] = i;\n    }\n\n    var k = 0;\n\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = network[j][0];\n      map[k++] = network[j][1];\n      map[k++] = network[j][2];\n    }\n\n    return map;\n  }\n\n  this.getColormap = getColormap;\n  /*\n    Method: lookupRGB\n     looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n\n  this.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/gif-encoder/lib/TypedNeuQuant.js"],"names":["ncycles","netsize","maxnetpos","netbiasshift","intbiasshift","intbias","gammashift","gamma","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","alphadec","radbiasshift","radbias","alpharadbshift","alpharadbias","prime1","prime2","prime3","prime4","minpicturebytes","NeuQuant","pixels","samplefac","network","netindex","bias","freq","radpower","init","Int32Array","i","v","Float64Array","unbiasnet","altersingle","alpha","b","g","r","alterneigh","radius","lo","Math","abs","hi","min","j","k","m","p","a","contest","bestd","bestbiasd","bestpos","bestbiaspos","n","dist","biasdist","betafreq","inxbuild","q","smallpos","smallval","previouscol","startpos","inxsearch","best","learn","lengthcount","length","samplepixels","delta","rad","step","pix","buildColormap","getColormap","map","index","l","lookupRGB","module","exports"],"mappings":"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","sourcesContent":["/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\n\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = (1 << intbiasshift);\nvar gammashift = 10;\nvar gamma = (1 << gammashift);\nvar betashift = 10;\nvar beta = (intbias >> betashift); /* beta = 1/1024 */\nvar betagamma = (intbias << (gammashift - betashift));\n\n// defs for decreasing radius factor\nvar initrad = (netsize >> 3); // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = (1 << radiusbiasshift);\nvar initradius = (initrad * radiusbias); //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = (1 << alphabiasshift);\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = (1 << radbiasshift);\nvar alpharadbshift = (alphabiasshift + radbiasshift);\nvar alpharadbias = (1 << alpharadbshift);\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = (3 * prime4);\n\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac) {\n  var network; // int[netsize][4]\n  var netindex; // for network lookup - really 256\n\n  // bias and freq arrays for learning\n  var bias;\n  var freq;\n  var radpower;\n\n  /*\n    Private Method: init\n\n    sets up arrays\n  */\n  function init() {\n    network = [];\n    netindex = new Int32Array(256);\n    bias = new Int32Array(netsize);\n    freq = new Int32Array(netsize);\n    radpower = new Int32Array(netsize >> 3);\n\n    var i, v;\n    for (i = 0; i < netsize; i++) {\n      v = (i << (netbiasshift + 8)) / netsize;\n      network[i] = new Float64Array([v, v, v, 0]);\n      //network[i] = [v, v, v, 0]\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n\n  /*\n    Private Method: unbiasnet\n\n    unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n\n  /*\n    Private Method: altersingle\n\n    moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n  }\n\n  /*\n    Private Method: alterneigh\n\n    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n\n    var p, a;\n    while ((j < hi) || (k > lo)) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n    }\n  }\n\n  /*\n    Private Method: contest\n\n    searches for biased BGR values\n  */\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n\n    var i, n, dist, biasdist, betafreq;\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n\n      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = (freq[i] >> betashift);\n      freq[i] -= betafreq;\n      bias[i] += (betafreq << gammashift);\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n\n    return bestbiaspos;\n  }\n\n  /*\n    Private Method: inxbuild\n\n    sorts network and builds netindex[0..255]\n  */\n  function inxbuild() {\n    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n        if (q[1] < smallval) { // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n      q = network[smallpos];\n      // swap p (i) and q (smallpos) entries\n      if (i != smallpos) {\n        j = q[0];   q[0] = p[0];   p[0] = j;\n        j = q[1];   q[1] = p[1];   p[1] = j;\n        j = q[2];   q[2] = p[2];   p[2] = j;\n        j = q[3];   q[3] = p[3];   p[3] = j;\n      }\n      // smallval entry is now in position i\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = (startpos + i) >> 1;\n        for (j = previouscol + 1; j < smallval; j++)\n          netindex[j] = i;\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n    for (j = previouscol + 1; j < 256; j++)\n      netindex[j] = maxnetpos; // really 256\n  }\n\n  /*\n    Private Method: inxsearch\n\n    searches for BGR values 0..255 and returns a color index\n  */\n  function inxsearch(b, g, r) {\n    var a, p, dist;\n\n    var bestd = 1000; // biggest possible dist is 256*3\n    var best = -1;\n\n    var i = netindex[g]; // index on g\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while ((i < netsize) || (j >= 0)) {\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; // inx key\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n          i++;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = p[2] - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n      if (j >= 0) {\n        p = network[j];\n        dist = g - p[1]; // inx key - reverse dif\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n          j--;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = p[2] - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /*\n    Private Method: learn\n\n    \"Main Learning Loop\"\n  */\n  function learn() {\n    var i;\n\n    var lengthcount = pixels.length;\n    var alphadec = 30 + ((samplefac - 1) / 3);\n    var samplepixels = lengthcount / (3 * samplefac);\n    var delta = ~~(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n\n    var rad = radius >> radiusbiasshift;\n\n    if (rad <= 1) rad = 0;\n    for (i = 0; i < rad; i++)\n      radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n    var step;\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if ((lengthcount % prime1) !== 0) {\n      step = 3 * prime1;\n    } else if ((lengthcount % prime2) !== 0) {\n      step = 3 * prime2;\n    } else if ((lengthcount % prime3) !== 0)  {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n\n      i++;\n\n      if (delta === 0) delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) rad = 0;\n        for (j = 0; j < rad; j++)\n          radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n      }\n    }\n  }\n\n  /*\n    Method: buildColormap\n\n    1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n  this.buildColormap = buildColormap;\n\n  /*\n    Method: getColormap\n\n    builds colormap from the index\n\n    returns array in the format:\n\n    >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n  function getColormap() {\n    var map = [];\n    var index = [];\n\n    for (var i = 0; i < netsize; i++)\n      index[network[i][3]] = i;\n\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = (network[j][0]);\n      map[k++] = (network[j][1]);\n      map[k++] = (network[j][2]);\n    }\n    return map;\n  }\n  this.getColormap = getColormap;\n\n  /*\n    Method: lookupRGB\n\n    looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n  this.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;\n"]},"metadata":{},"sourceType":"script"}