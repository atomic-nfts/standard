{"ast":null,"code":"import _objectSpread from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { maybeDecryptPemBody, maybeEncryptPemBody } from './encryption';\nimport { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey } from './keys';\nimport { uint8ArrayToBinaryString, binaryStringToUint8Array } from '../../util/binary';\nimport { decodePem, encodePem } from '../../util/pem-encoder';\nimport { DecodePemFailedError, UnsupportedAlgorithmError } from '../../util/errors';\nimport { KEY_TYPES } from '../../util/key-types';\n\nvar getKeyType = function getKeyType(pemType) {\n  var match = /^(\\S+?) (PUBLIC|PRIVATE) KEY$/.exec(pemType);\n  return match && match[1].toLocaleLowerCase();\n};\n\nvar getPemType = function getPemType(keyAlgorithm) {\n  var keyType = KEY_TYPES[keyAlgorithm.id];\n  return keyType && keyType.toUpperCase();\n};\n\nexport var decomposePrivateKey = function decomposePrivateKey(pem, options) {\n  var decodedPem;\n\n  try {\n    decodedPem = decodePem(pem, '* PRIVATE KEY');\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Decrypt pem if encrypted\n\n\n  var _maybeDecryptPemBody = maybeDecryptPemBody(decodedPem, options.password),\n      pemBody = _maybeDecryptPemBody.pemBody,\n      encryptionAlgorithm = _maybeDecryptPemBody.encryptionAlgorithm; // Extract the key type from it\n\n\n  var keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  var _decomposeRawPrivateK = decomposeRawPrivateKey(keyType, pemBody),\n      keyAlgorithm = _decomposeRawPrivateK.keyAlgorithm,\n      keyData = _decomposeRawPrivateK.keyData;\n\n  return {\n    format: 'raw-pem',\n    keyAlgorithm: keyAlgorithm,\n    keyData: keyData,\n    encryptionAlgorithm: encryptionAlgorithm\n  };\n};\nexport var composePrivateKey = function composePrivateKey(_ref, options) {\n  var keyAlgorithm = _ref.keyAlgorithm,\n      keyData = _ref.keyData,\n      encryptionAlgorithm = _ref.encryptionAlgorithm;\n  // Compose the key\n  var rawKey = composeRawPrivateKey(keyAlgorithm, keyData); // Extract the pem type\n\n  var pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Encrypt pem if password was specified\n\n\n  var _maybeEncryptPemBody = maybeEncryptPemBody(rawKey, encryptionAlgorithm, options.password),\n      pemBody = _maybeEncryptPemBody.pemBody,\n      pemHeaders = _maybeEncryptPemBody.pemHeaders; // Finally build pem\n\n\n  return encodePem(_objectSpread({\n    type: \"\".concat(pemKeyType, \" PRIVATE KEY\"),\n    body: uint8ArrayToBinaryString(pemBody)\n  }, pemHeaders));\n};\nexport var decomposePublicKey = function decomposePublicKey(pem) {\n  // Decode pem\n  var decodedPem;\n\n  try {\n    decodedPem = decodePem(pem);\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Extract the key type from it\n\n\n  var keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  var pemBody = binaryStringToUint8Array(decodedPem.body);\n\n  var _decomposeRawPublicKe = decomposeRawPublicKey(keyType, pemBody),\n      keyAlgorithm = _decomposeRawPublicKe.keyAlgorithm,\n      keyData = _decomposeRawPublicKe.keyData;\n\n  return {\n    format: 'raw-pem',\n    keyAlgorithm: keyAlgorithm,\n    keyData: keyData\n  };\n};\nexport var composePublicKey = function composePublicKey(_ref2) {\n  var keyAlgorithm = _ref2.keyAlgorithm,\n      keyData = _ref2.keyData;\n  // Compose the key\n  var rawKey = composeRawPublicKey(keyAlgorithm, keyData); // Extract the pem type\n\n  var pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Finally build pem\n\n\n  return encodePem({\n    type: \"\".concat(pemKeyType, \" PUBLIC KEY\"),\n    body: uint8ArrayToBinaryString(rawKey)\n  });\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/formats/raw/raw-pem.js"],"names":["maybeDecryptPemBody","maybeEncryptPemBody","decomposeRawPrivateKey","composeRawPrivateKey","decomposeRawPublicKey","composeRawPublicKey","uint8ArrayToBinaryString","binaryStringToUint8Array","decodePem","encodePem","DecodePemFailedError","UnsupportedAlgorithmError","KEY_TYPES","getKeyType","pemType","match","exec","toLocaleLowerCase","getPemType","keyAlgorithm","keyType","id","toUpperCase","decomposePrivateKey","pem","options","decodedPem","err","invalidInputKey","password","pemBody","encryptionAlgorithm","type","keyData","format","composePrivateKey","rawKey","pemKeyType","pemHeaders","body","decomposePublicKey","composePublicKey"],"mappings":"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","sourcesContent":["import { maybeDecryptPemBody, maybeEncryptPemBody } from './encryption';\nimport { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey } from './keys';\nimport { uint8ArrayToBinaryString, binaryStringToUint8Array } from '../../util/binary';\nimport { decodePem, encodePem } from '../../util/pem-encoder';\nimport { DecodePemFailedError, UnsupportedAlgorithmError } from '../../util/errors';\nimport { KEY_TYPES } from '../../util/key-types';\n\nconst getKeyType = pemType => {\n  const match = /^(\\S+?) (PUBLIC|PRIVATE) KEY$/.exec(pemType);\n  return match && match[1].toLocaleLowerCase();\n};\n\nconst getPemType = keyAlgorithm => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n  return keyType && keyType.toUpperCase();\n};\n\nexport const decomposePrivateKey = (pem, options) => {\n  let decodedPem;\n\n  try {\n    decodedPem = decodePem(pem, '* PRIVATE KEY');\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Decrypt pem if encrypted\n\n\n  const {\n    pemBody,\n    encryptionAlgorithm\n  } = maybeDecryptPemBody(decodedPem, options.password); // Extract the key type from it\n\n  const keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposeRawPrivateKey(keyType, pemBody);\n  return {\n    format: 'raw-pem',\n    keyAlgorithm,\n    keyData,\n    encryptionAlgorithm\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}, options) => {\n  // Compose the key\n  const rawKey = composeRawPrivateKey(keyAlgorithm, keyData); // Extract the pem type\n\n  const pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Encrypt pem if password was specified\n\n\n  const {\n    pemBody,\n    pemHeaders\n  } = maybeEncryptPemBody(rawKey, encryptionAlgorithm, options.password); // Finally build pem\n\n  return encodePem({\n    type: `${pemKeyType} PRIVATE KEY`,\n    body: uint8ArrayToBinaryString(pemBody),\n    ...pemHeaders\n  });\n};\nexport const decomposePublicKey = pem => {\n  // Decode pem\n  let decodedPem;\n\n  try {\n    decodedPem = decodePem(pem);\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Extract the key type from it\n\n\n  const keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  const pemBody = binaryStringToUint8Array(decodedPem.body);\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposeRawPublicKey(keyType, pemBody);\n  return {\n    format: 'raw-pem',\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePublicKey = ({\n  keyAlgorithm,\n  keyData\n}) => {\n  // Compose the key\n  const rawKey = composeRawPublicKey(keyAlgorithm, keyData); // Extract the pem type\n\n  const pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Finally build pem\n\n\n  return encodePem({\n    type: `${pemKeyType} PUBLIC KEY`,\n    body: uint8ArrayToBinaryString(rawKey)\n  });\n};"]},"metadata":{},"sourceType":"module"}