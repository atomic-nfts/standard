{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst error_1 = require(\"./lib/error\");\n\nconst ArweaveUtils = __importStar(require(\"./lib/utils\"));\n\nclass Chunks {\n  constructor(api) {\n    this.api = api;\n  }\n\n  async getTransactionOffset(id) {\n    const resp = await this.api.get(`tx/${id}/offset`);\n\n    if (resp.status === 200) {\n      return resp.data;\n    }\n\n    throw new Error(`Unable to get transaction offset: ${error_1.getError(resp)}`);\n  }\n\n  async getChunk(offset) {\n    const resp = await this.api.get(`chunk/${offset}`);\n\n    if (resp.status === 200) {\n      return resp.data;\n    }\n\n    throw new Error(`Unable to get chunk: ${error_1.getError(resp)}`);\n  }\n\n  async getChunkData(offset) {\n    const chunk = await this.getChunk(offset);\n    const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n    return buf;\n  }\n\n  firstChunkOffset(offsetResponse) {\n    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n  }\n\n  async downloadChunkedData(id) {\n    const offsetResponse = await this.getTransactionOffset(id);\n    const size = parseInt(offsetResponse.size);\n    const endOffset = parseInt(offsetResponse.offset);\n    const startOffset = endOffset - size + 1;\n    const data = new Uint8Array(size);\n    let byte = 0;\n\n    while (startOffset + byte < endOffset) {\n      const chunkData = await this.getChunkData(startOffset + byte);\n      data.set(chunkData, byte);\n      byte += chunkData.length;\n    }\n\n    return data;\n  }\n\n}\n\nexports.default = Chunks;","map":{"version":3,"sources":["../../../src/common/chunks.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,YAAA,GAAA,YAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAaA,MAAqB,MAArB,CAA2B;AACzB,EAAA,WAAA,CAAoB,GAApB,EAA4B;AAAR,SAAA,GAAA,GAAA,GAAA;AAAY;;AAEN,QAApB,oBAAoB,CAAC,EAAD,EAAW;AACnC,UAAM,IAAI,GAAG,MAAM,KAAK,GAAL,CAAS,GAAT,CAAa,MAAM,EAAE,SAArB,CAAnB;;AACA,QAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,aAAO,IAAI,CAAC,IAAZ;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,qCAAqC,OAAA,CAAA,QAAA,CAAS,IAAT,CAAc,EAA7D,CAAN;AACD;;AAEa,QAAR,QAAQ,CACZ,MADY,EACoB;AAEhC,UAAM,IAAI,GAAG,MAAM,KAAK,GAAL,CAAS,GAAT,CAAa,SAAS,MAAM,EAA5B,CAAnB;;AACA,QAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,aAAO,IAAI,CAAC,IAAZ;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,wBAAwB,OAAA,CAAA,QAAA,CAAS,IAAT,CAAc,EAAhD,CAAN;AACD;;AAEiB,QAAZ,YAAY,CAAC,MAAD,EAAiC;AACjD,UAAM,KAAK,GAAG,MAAM,KAAK,QAAL,CAAc,MAAd,CAApB;AACA,UAAM,GAAG,GAAG,YAAY,CAAC,cAAb,CAA4B,KAAK,CAAC,KAAlC,CAAZ;AACA,WAAO,GAAP;AACD;;AAED,EAAA,gBAAgB,CAAC,cAAD,EAA0C;AACxD,WAAO,QAAQ,CAAC,cAAc,CAAC,MAAhB,CAAR,GAAkC,QAAQ,CAAC,cAAc,CAAC,IAAhB,CAA1C,GAAkE,CAAzE;AACD;;AAEwB,QAAnB,mBAAmB,CAAC,EAAD,EAAW;AAClC,UAAM,cAAc,GAAG,MAAM,KAAK,oBAAL,CAA0B,EAA1B,CAA7B;AAEA,UAAM,IAAI,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAhB,CAArB;AACA,UAAM,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,MAAhB,CAA1B;AACA,UAAM,WAAW,GAAG,SAAS,GAAG,IAAZ,GAAmB,CAAvC;AAEA,UAAM,IAAI,GAAG,IAAI,UAAJ,CAAe,IAAf,CAAb;AACA,QAAI,IAAI,GAAG,CAAX;;AAEA,WAAO,WAAW,GAAG,IAAd,GAAqB,SAA5B,EAAuC;AACrC,YAAM,SAAS,GAAG,MAAM,KAAK,YAAL,CAAkB,WAAW,GAAG,IAAhC,CAAxB;AACA,MAAA,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,IAApB;AACA,MAAA,IAAI,IAAI,SAAS,CAAC,MAAlB;AACD;;AAED,WAAO,IAAP;AACD;;AAhDwB;;AAA3B,OAAA,CAAA,OAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = require(\"./lib/error\");\nconst ArweaveUtils = __importStar(require(\"./lib/utils\"));\nclass Chunks {\n    constructor(api) {\n        this.api = api;\n    }\n    async getTransactionOffset(id) {\n        const resp = await this.api.get(`tx/${id}/offset`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get transaction offset: ${error_1.getError(resp)}`);\n    }\n    async getChunk(offset) {\n        const resp = await this.api.get(`chunk/${offset}`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get chunk: ${error_1.getError(resp)}`);\n    }\n    async getChunkData(offset) {\n        const chunk = await this.getChunk(offset);\n        const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n        return buf;\n    }\n    firstChunkOffset(offsetResponse) {\n        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n    }\n    async downloadChunkedData(id) {\n        const offsetResponse = await this.getTransactionOffset(id);\n        const size = parseInt(offsetResponse.size);\n        const endOffset = parseInt(offsetResponse.offset);\n        const startOffset = endOffset - size + 1;\n        const data = new Uint8Array(size);\n        let byte = 0;\n        while (startOffset + byte < endOffset) {\n            const chunkData = await this.getChunkData(startOffset + byte);\n            data.set(chunkData, byte);\n            byte += chunkData.length;\n        }\n        return data;\n    }\n}\nexports.default = Chunks;\n//# sourceMappingURL=chunks.js.map"]},"metadata":{},"sourceType":"script"}