{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readContract = void 0;\n\nconst contract_load_1 = require(\"./contract-load\");\n\nconst utils_1 = require(\"./utils\");\n\nconst contract_step_1 = require(\"./contract-step\");\n\nconst errors_1 = __importDefault(require(\"./errors\"));\n/**\n * Queries all interaction transactions and replays a contract to its latest state.\n *\n * If height is provided, will replay only to that block height.\n *\n * @param arweave         an Arweave client instance\n * @param contractId      the Transaction Id of the contract\n * @param height          if specified the contract will be replayed only to this block height\n * @param returnValidity  if true, the function will return valid and invalid transaction IDs along with the state\n */\n\n\nfunction readContract(arweave, contractId, height, returnValidity) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!height) {\n      const networkInfo = yield arweave.network.getInfo();\n      height = networkInfo.height;\n    }\n\n    const loadPromise = contract_load_1.loadContract(arweave, contractId).catch(err => {\n      const error = new errors_1.default(\"CONTRACT_NOT_FOUND\"\n      /* CONTRACT_NOT_FOUND */\n      , {\n        message: `Contract having txId: ${contractId} not found`,\n        requestedTxId: contractId\n      });\n      throw error;\n    });\n    const fetchTxPromise = fetchTransactions(arweave, contractId, height).catch(err => err); // tslint:disable-next-line: prefer-const\n\n    let [contractInfo, txInfos] = yield Promise.all([loadPromise, fetchTxPromise]);\n    if (contractInfo instanceof Error) throw contractInfo;\n    if (txInfos instanceof Error) throw txInfos;\n    let state;\n    const contractSrc = contractInfo.contractSrc;\n\n    try {\n      state = JSON.parse(contractInfo.initState);\n    } catch (e) {\n      throw new Error(`Unable to parse initial state for contract: ${contractId}`);\n    }\n\n    utils_1.log(arweave, `Replaying ${txInfos.length} confirmed interactions`);\n    yield sortTransactions(arweave, txInfos); // tslint:disable-next-line: prefer-const\n\n    let {\n      handler,\n      swGlobal\n    } = contractInfo;\n    const validity = {};\n\n    for (const txInfo of txInfos) {\n      const currentTx = txInfo.node;\n      const contractIndex = txInfo.node.tags.findIndex(tag => tag.name === 'Contract' && tag.value === contractId);\n      const inputTag = txInfo.node.tags[contractIndex + 1];\n\n      if (!inputTag || inputTag.name !== 'Input') {\n        utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n        continue;\n      }\n\n      let input = inputTag.value;\n\n      try {\n        input = JSON.parse(input);\n      } catch (e) {\n        utils_1.log(arweave, e);\n        continue;\n      }\n\n      if (!input) {\n        utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n        continue;\n      }\n\n      const interaction = {\n        input,\n        caller: currentTx.owner.address\n      };\n      swGlobal._activeTx = currentTx;\n      const result = yield contract_step_1.execute(handler, interaction, state);\n\n      if (result.type === 'exception') {\n        utils_1.log(arweave, `${result.result}`);\n        utils_1.log(arweave, `Executing of interaction: ${currentTx.id} threw exception.`);\n      }\n\n      if (result.type === 'error') {\n        utils_1.log(arweave, `${result.result}`);\n        utils_1.log(arweave, `Executing of interaction: ${currentTx.id} returned error.`);\n      }\n\n      validity[currentTx.id] = result.type === 'ok';\n      state = result.state;\n      const settings = state.settings ? new Map(state.settings) : new Map();\n      const evolve = state.evolve || settings.get('evolve');\n      let canEvolve = state.canEvolve || settings.get('canEvolve'); // By default, contracts can evolve if there's not an explicit `false`.\n\n      if (canEvolve === undefined || canEvolve === null) {\n        canEvolve = true;\n      }\n\n      if (evolve && /[a-z0-9_-]{43}/i.test(evolve) && canEvolve) {\n        if (contractSrc !== state.evolve) {\n          try {\n            contractInfo = yield contract_load_1.loadContract(arweave, contractId, evolve);\n            handler = contractInfo.handler;\n          } catch (e) {\n            const error = new errors_1.default(\"CONTRACT_NOT_FOUND\"\n            /* CONTRACT_NOT_FOUND */\n            , {\n              message: `Contract having txId: ${contractId} not found`,\n              requestedTxId: contractId\n            });\n            throw error;\n          }\n        }\n      }\n    }\n\n    return returnValidity ? {\n      state,\n      validity\n    } : state;\n  });\n}\n\nexports.readContract = readContract; // Sort the transactions based on the sort key generated in addSortKey()\n\nfunction sortTransactions(arweave, txInfos) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const addKeysFuncs = txInfos.map(tx => addSortKey(arweave, tx));\n    yield Promise.all(addKeysFuncs);\n    txInfos.sort((a, b) => a.sortKey.localeCompare(b.sortKey));\n  });\n} // Construct a string that will lexographically sort.\n// { block_height, sha256(block_indep_hash + txid) }\n// pad block height to 12 digits and convert hash value\n// to a hex string.\n\n\nfunction addSortKey(arweave, txInfo) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      node\n    } = txInfo;\n    const blockHashBytes = arweave.utils.b64UrlToBuffer(node.block.id);\n    const txIdBytes = arweave.utils.b64UrlToBuffer(node.id);\n    const concatted = arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);\n    const hashed = utils_1.arrayToHex(yield arweave.crypto.hash(concatted));\n    const blockHeight = `000000${node.block.height}`.slice(-12);\n    txInfo.sortKey = `${blockHeight},${hashed}`;\n  });\n} // the maximum number of transactions we can get from graphql at once\n\n\nconst MAX_REQUEST = 100; // fetch all contract interactions up to the specified block height\n\nfunction fetchTransactions(arweave, contractId, height) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let variables = {\n      tags: [{\n        name: 'App-Name',\n        values: ['SmartWeaveAction']\n      }, {\n        name: 'Contract',\n        values: [contractId]\n      }],\n      blockFilter: {\n        max: height\n      },\n      first: MAX_REQUEST\n    };\n    let transactions = yield getNextPage(arweave, variables);\n    const txInfos = transactions.edges.filter(tx => !tx.node.parent || !tx.node.parent.id);\n\n    while (transactions.pageInfo.hasNextPage) {\n      const cursor = transactions.edges[MAX_REQUEST - 1].cursor;\n      variables = Object.assign(Object.assign({}, variables), {\n        after: cursor\n      });\n      transactions = yield getNextPage(arweave, variables);\n      txInfos.push(...transactions.edges.filter(tx => !tx.node.parent || !tx.node.parent.id));\n    }\n\n    return txInfos;\n  });\n}\n\nfunction getNextPage(arweave, variables) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {\n    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {\n      pageInfo {\n        hasNextPage\n      }\n      edges {\n        node {\n          id\n          owner { address }\n          recipient\n          tags {\n            name\n            value\n          }\n          block {\n            height\n            id\n            timestamp\n          }\n          fee { winston }\n          quantity { winston }\n          parent { id }\n        }\n        cursor\n      }\n    }\n  }`;\n    const response = yield arweave.api.post('graphql', {\n      query,\n      variables\n    });\n\n    if (response.status !== 200) {\n      throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response.status}.`);\n    }\n\n    const data = response.data;\n    const txs = data.data.transactions;\n    return txs;\n  });\n}","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/smartweave/lib/contract-read.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","readContract","contract_load_1","require","utils_1","contract_step_1","errors_1","arweave","contractId","height","returnValidity","networkInfo","network","getInfo","loadPromise","loadContract","catch","err","error","default","message","requestedTxId","fetchTxPromise","fetchTransactions","contractInfo","txInfos","all","Error","state","contractSrc","JSON","parse","initState","log","length","sortTransactions","handler","swGlobal","validity","txInfo","currentTx","node","contractIndex","tags","findIndex","tag","name","inputTag","id","input","interaction","caller","owner","address","_activeTx","execute","type","settings","Map","evolve","get","canEvolve","undefined","test","addKeysFuncs","map","tx","addSortKey","sort","a","b","sortKey","localeCompare","blockHashBytes","utils","b64UrlToBuffer","block","txIdBytes","concatted","concatBuffers","hashed","arrayToHex","crypto","hash","blockHeight","slice","MAX_REQUEST","variables","values","blockFilter","max","first","transactions","getNextPage","edges","filter","parent","pageInfo","hasNextPage","cursor","assign","after","push","query","response","api","post","status","data","txs"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASA,IAAIO,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAElB,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAkB,OAAO,CAACC,YAAR,GAAuB,KAAK,CAA5B;;AACA,MAAMC,eAAe,GAAGC,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMG,QAAQ,GAAGX,eAAe,CAACQ,OAAO,CAAC,UAAD,CAAR,CAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,YAAT,CAAsBM,OAAtB,EAA+BC,UAA/B,EAA2CC,MAA3C,EAAmDC,cAAnD,EAAmE;AAC/D,SAAOlC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,QAAI,CAACiC,MAAL,EAAa;AACT,YAAME,WAAW,GAAG,MAAMJ,OAAO,CAACK,OAAR,CAAgBC,OAAhB,EAA1B;AACAJ,MAAAA,MAAM,GAAGE,WAAW,CAACF,MAArB;AACH;;AACD,UAAMK,WAAW,GAAGZ,eAAe,CAACa,YAAhB,CAA6BR,OAA7B,EAAsCC,UAAtC,EAAkDQ,KAAlD,CAAyDC,GAAD,IAAS;AACjF,YAAMC,KAAK,GAAG,IAAIZ,QAAQ,CAACa,OAAb,CAAqB;AAAqB;AAA1C,QAAoE;AAC9EC,QAAAA,OAAO,EAAG,yBAAwBZ,UAAW,YADiC;AAE9Ea,QAAAA,aAAa,EAAEb;AAF+D,OAApE,CAAd;AAIA,YAAMU,KAAN;AACH,KANmB,CAApB;AAOA,UAAMI,cAAc,GAAGC,iBAAiB,CAAChB,OAAD,EAAUC,UAAV,EAAsBC,MAAtB,CAAjB,CAA+CO,KAA/C,CAAsDC,GAAD,IAASA,GAA9D,CAAvB,CAZgD,CAahD;;AACA,QAAI,CAACO,YAAD,EAAeC,OAAf,IAA0B,MAAMzC,OAAO,CAAC0C,GAAR,CAAY,CAACZ,WAAD,EAAcQ,cAAd,CAAZ,CAApC;AACA,QAAIE,YAAY,YAAYG,KAA5B,EACI,MAAMH,YAAN;AACJ,QAAIC,OAAO,YAAYE,KAAvB,EACI,MAAMF,OAAN;AACJ,QAAIG,KAAJ;AACA,UAAMC,WAAW,GAAGL,YAAY,CAACK,WAAjC;;AACA,QAAI;AACAD,MAAAA,KAAK,GAAGE,IAAI,CAACC,KAAL,CAAWP,YAAY,CAACQ,SAAxB,CAAR;AACH,KAFD,CAGA,OAAO3C,CAAP,EAAU;AACN,YAAM,IAAIsC,KAAJ,CAAW,+CAA8CnB,UAAW,EAApE,CAAN;AACH;;AACDJ,IAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,aAAYkB,OAAO,CAACS,MAAO,yBAAjD;AACA,UAAMC,gBAAgB,CAAC5B,OAAD,EAAUkB,OAAV,CAAtB,CA5BgD,CA6BhD;;AACA,QAAI;AAAEW,MAAAA,OAAF;AAAWC,MAAAA;AAAX,QAAwBb,YAA5B;AACA,UAAMc,QAAQ,GAAG,EAAjB;;AACA,SAAK,MAAMC,MAAX,IAAqBd,OAArB,EAA8B;AAC1B,YAAMe,SAAS,GAAGD,MAAM,CAACE,IAAzB;AACA,YAAMC,aAAa,GAAGH,MAAM,CAACE,IAAP,CAAYE,IAAZ,CAAiBC,SAAjB,CAA4BC,GAAD,IAASA,GAAG,CAACC,IAAJ,KAAa,UAAb,IAA2BD,GAAG,CAAC/D,KAAJ,KAAc0B,UAA7E,CAAtB;AACA,YAAMuC,QAAQ,GAAGR,MAAM,CAACE,IAAP,CAAYE,IAAZ,CAAiBD,aAAa,GAAG,CAAjC,CAAjB;;AACA,UAAI,CAACK,QAAD,IAAaA,QAAQ,CAACD,IAAT,KAAkB,OAAnC,EAA4C;AACxC1C,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,mDAAkDiC,SAAS,CAACQ,EAAG,EAArF;AACA;AACH;;AACD,UAAIC,KAAK,GAAGF,QAAQ,CAACjE,KAArB;;AACA,UAAI;AACAmE,QAAAA,KAAK,GAAGnB,IAAI,CAACC,KAAL,CAAWkB,KAAX,CAAR;AACH,OAFD,CAGA,OAAO5D,CAAP,EAAU;AACNe,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAqBlB,CAArB;AACA;AACH;;AACD,UAAI,CAAC4D,KAAL,EAAY;AACR7C,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,mDAAkDiC,SAAS,CAACQ,EAAG,EAArF;AACA;AACH;;AACD,YAAME,WAAW,GAAG;AAChBD,QAAAA,KADgB;AAEhBE,QAAAA,MAAM,EAAEX,SAAS,CAACY,KAAV,CAAgBC;AAFR,OAApB;AAIAhB,MAAAA,QAAQ,CAACiB,SAAT,GAAqBd,SAArB;AACA,YAAMjD,MAAM,GAAG,MAAMc,eAAe,CAACkD,OAAhB,CAAwBnB,OAAxB,EAAiCc,WAAjC,EAA8CtB,KAA9C,CAArB;;AACA,UAAIrC,MAAM,CAACiE,IAAP,KAAgB,WAApB,EAAiC;AAC7BpD,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,GAAEhB,MAAM,CAACA,MAAO,EAAtC;AACAa,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,6BAA4BiC,SAAS,CAACQ,EAAG,mBAA/D;AACH;;AACD,UAAIzD,MAAM,CAACiE,IAAP,KAAgB,OAApB,EAA6B;AACzBpD,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,GAAEhB,MAAM,CAACA,MAAO,EAAtC;AACAa,QAAAA,OAAO,CAAC6B,GAAR,CAAY1B,OAAZ,EAAsB,6BAA4BiC,SAAS,CAACQ,EAAG,kBAA/D;AACH;;AACDV,MAAAA,QAAQ,CAACE,SAAS,CAACQ,EAAX,CAAR,GAAyBzD,MAAM,CAACiE,IAAP,KAAgB,IAAzC;AACA5B,MAAAA,KAAK,GAAGrC,MAAM,CAACqC,KAAf;AACA,YAAM6B,QAAQ,GAAG7B,KAAK,CAAC6B,QAAN,GAAiB,IAAIC,GAAJ,CAAQ9B,KAAK,CAAC6B,QAAd,CAAjB,GAA2C,IAAIC,GAAJ,EAA5D;AACA,YAAMC,MAAM,GAAG/B,KAAK,CAAC+B,MAAN,IAAgBF,QAAQ,CAACG,GAAT,CAAa,QAAb,CAA/B;AACA,UAAIC,SAAS,GAAGjC,KAAK,CAACiC,SAAN,IAAmBJ,QAAQ,CAACG,GAAT,CAAa,WAAb,CAAnC,CAtC0B,CAuC1B;;AACA,UAAIC,SAAS,KAAKC,SAAd,IAA2BD,SAAS,KAAK,IAA7C,EAAmD;AAC/CA,QAAAA,SAAS,GAAG,IAAZ;AACH;;AACD,UAAIF,MAAM,IAAI,kBAAkBI,IAAlB,CAAuBJ,MAAvB,CAAV,IAA4CE,SAAhD,EAA2D;AACvD,YAAIhC,WAAW,KAAKD,KAAK,CAAC+B,MAA1B,EAAkC;AAC9B,cAAI;AACAnC,YAAAA,YAAY,GAAG,MAAMtB,eAAe,CAACa,YAAhB,CAA6BR,OAA7B,EAAsCC,UAAtC,EAAkDmD,MAAlD,CAArB;AACAvB,YAAAA,OAAO,GAAGZ,YAAY,CAACY,OAAvB;AACH,WAHD,CAIA,OAAO/C,CAAP,EAAU;AACN,kBAAM6B,KAAK,GAAG,IAAIZ,QAAQ,CAACa,OAAb,CAAqB;AAAqB;AAA1C,cAAoE;AAC9EC,cAAAA,OAAO,EAAG,yBAAwBZ,UAAW,YADiC;AAE9Ea,cAAAA,aAAa,EAAEb;AAF+D,aAApE,CAAd;AAIA,kBAAMU,KAAN;AACH;AACJ;AACJ;AACJ;;AACD,WAAOR,cAAc,GAAG;AAAEkB,MAAAA,KAAF;AAASU,MAAAA;AAAT,KAAH,GAAyBV,KAA9C;AACH,GA5Fe,CAAhB;AA6FH;;AACD5B,OAAO,CAACC,YAAR,GAAuBA,YAAvB,C,CACA;;AACA,SAASkC,gBAAT,CAA0B5B,OAA1B,EAAmCkB,OAAnC,EAA4C;AACxC,SAAOjD,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAMwF,YAAY,GAAGvC,OAAO,CAACwC,GAAR,CAAaC,EAAD,IAAQC,UAAU,CAAC5D,OAAD,EAAU2D,EAAV,CAA9B,CAArB;AACA,UAAMlF,OAAO,CAAC0C,GAAR,CAAYsC,YAAZ,CAAN;AACAvC,IAAAA,OAAO,CAAC2C,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,OAAF,CAAUC,aAAV,CAAwBF,CAAC,CAACC,OAA1B,CAAvB;AACH,GAJe,CAAhB;AAKH,C,CACD;AACA;AACA;AACA;;;AACA,SAASJ,UAAT,CAAoB5D,OAApB,EAA6BgC,MAA7B,EAAqC;AACjC,SAAO/D,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAM;AAAEiE,MAAAA;AAAF,QAAWF,MAAjB;AACA,UAAMkC,cAAc,GAAGlE,OAAO,CAACmE,KAAR,CAAcC,cAAd,CAA6BlC,IAAI,CAACmC,KAAL,CAAW5B,EAAxC,CAAvB;AACA,UAAM6B,SAAS,GAAGtE,OAAO,CAACmE,KAAR,CAAcC,cAAd,CAA6BlC,IAAI,CAACO,EAAlC,CAAlB;AACA,UAAM8B,SAAS,GAAGvE,OAAO,CAACmE,KAAR,CAAcK,aAAd,CAA4B,CAACN,cAAD,EAAiBI,SAAjB,CAA5B,CAAlB;AACA,UAAMG,MAAM,GAAG5E,OAAO,CAAC6E,UAAR,CAAmB,MAAM1E,OAAO,CAAC2E,MAAR,CAAeC,IAAf,CAAoBL,SAApB,CAAzB,CAAf;AACA,UAAMM,WAAW,GAAI,SAAQ3C,IAAI,CAACmC,KAAL,CAAWnE,MAAO,EAA3B,CAA6B4E,KAA7B,CAAmC,CAAC,EAApC,CAApB;AACA9C,IAAAA,MAAM,CAACgC,OAAP,GAAkB,GAAEa,WAAY,IAAGJ,MAAO,EAA1C;AACH,GARe,CAAhB;AASH,C,CACD;;;AACA,MAAMM,WAAW,GAAG,GAApB,C,CACA;;AACA,SAAS/D,iBAAT,CAA2BhB,OAA3B,EAAoCC,UAApC,EAAgDC,MAAhD,EAAwD;AACpD,SAAOjC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,QAAI+G,SAAS,GAAG;AACZ5C,MAAAA,IAAI,EAAE,CACF;AACIG,QAAAA,IAAI,EAAE,UADV;AAEI0C,QAAAA,MAAM,EAAE,CAAC,kBAAD;AAFZ,OADE,EAKF;AACI1C,QAAAA,IAAI,EAAE,UADV;AAEI0C,QAAAA,MAAM,EAAE,CAAChF,UAAD;AAFZ,OALE,CADM;AAWZiF,MAAAA,WAAW,EAAE;AACTC,QAAAA,GAAG,EAAEjF;AADI,OAXD;AAcZkF,MAAAA,KAAK,EAAEL;AAdK,KAAhB;AAgBA,QAAIM,YAAY,GAAG,MAAMC,WAAW,CAACtF,OAAD,EAAUgF,SAAV,CAApC;AACA,UAAM9D,OAAO,GAAGmE,YAAY,CAACE,KAAb,CAAmBC,MAAnB,CAA2B7B,EAAD,IAAQ,CAACA,EAAE,CAACzB,IAAH,CAAQuD,MAAT,IAAmB,CAAC9B,EAAE,CAACzB,IAAH,CAAQuD,MAAR,CAAehD,EAArE,CAAhB;;AACA,WAAO4C,YAAY,CAACK,QAAb,CAAsBC,WAA7B,EAA0C;AACtC,YAAMC,MAAM,GAAGP,YAAY,CAACE,KAAb,CAAmBR,WAAW,GAAG,CAAjC,EAAoCa,MAAnD;AACAZ,MAAAA,SAAS,GAAGzF,MAAM,CAACsG,MAAP,CAActG,MAAM,CAACsG,MAAP,CAAc,EAAd,EAAkBb,SAAlB,CAAd,EAA4C;AAAEc,QAAAA,KAAK,EAAEF;AAAT,OAA5C,CAAZ;AACAP,MAAAA,YAAY,GAAG,MAAMC,WAAW,CAACtF,OAAD,EAAUgF,SAAV,CAAhC;AACA9D,MAAAA,OAAO,CAAC6E,IAAR,CAAa,GAAGV,YAAY,CAACE,KAAb,CAAmBC,MAAnB,CAA2B7B,EAAD,IAAQ,CAACA,EAAE,CAACzB,IAAH,CAAQuD,MAAT,IAAmB,CAAC9B,EAAE,CAACzB,IAAH,CAAQuD,MAAR,CAAehD,EAArE,CAAhB;AACH;;AACD,WAAOvB,OAAP;AACH,GA1Be,CAAhB;AA2BH;;AACD,SAASoE,WAAT,CAAqBtF,OAArB,EAA8BgF,SAA9B,EAAyC;AACrC,SAAO/G,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAM+H,KAAK,GAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IA1BQ;AA2BA,UAAMC,QAAQ,GAAG,MAAMjG,OAAO,CAACkG,GAAR,CAAYC,IAAZ,CAAiB,SAAjB,EAA4B;AAC/CH,MAAAA,KAD+C;AAE/ChB,MAAAA;AAF+C,KAA5B,CAAvB;;AAIA,QAAIiB,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AACzB,YAAM,IAAIhF,KAAJ,CAAW,0EAAyE6E,QAAQ,CAACG,MAAO,GAApG,CAAN;AACH;;AACD,UAAMC,IAAI,GAAGJ,QAAQ,CAACI,IAAtB;AACA,UAAMC,GAAG,GAAGD,IAAI,CAACA,IAAL,CAAUhB,YAAtB;AACA,WAAOiB,GAAP;AACH,GAtCe,CAAhB;AAuCH","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readContract = void 0;\nconst contract_load_1 = require(\"./contract-load\");\nconst utils_1 = require(\"./utils\");\nconst contract_step_1 = require(\"./contract-step\");\nconst errors_1 = __importDefault(require(\"./errors\"));\n/**\n * Queries all interaction transactions and replays a contract to its latest state.\n *\n * If height is provided, will replay only to that block height.\n *\n * @param arweave         an Arweave client instance\n * @param contractId      the Transaction Id of the contract\n * @param height          if specified the contract will be replayed only to this block height\n * @param returnValidity  if true, the function will return valid and invalid transaction IDs along with the state\n */\nfunction readContract(arweave, contractId, height, returnValidity) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!height) {\n            const networkInfo = yield arweave.network.getInfo();\n            height = networkInfo.height;\n        }\n        const loadPromise = contract_load_1.loadContract(arweave, contractId).catch((err) => {\n            const error = new errors_1.default(\"CONTRACT_NOT_FOUND\" /* CONTRACT_NOT_FOUND */, {\n                message: `Contract having txId: ${contractId} not found`,\n                requestedTxId: contractId,\n            });\n            throw error;\n        });\n        const fetchTxPromise = fetchTransactions(arweave, contractId, height).catch((err) => err);\n        // tslint:disable-next-line: prefer-const\n        let [contractInfo, txInfos] = yield Promise.all([loadPromise, fetchTxPromise]);\n        if (contractInfo instanceof Error)\n            throw contractInfo;\n        if (txInfos instanceof Error)\n            throw txInfos;\n        let state;\n        const contractSrc = contractInfo.contractSrc;\n        try {\n            state = JSON.parse(contractInfo.initState);\n        }\n        catch (e) {\n            throw new Error(`Unable to parse initial state for contract: ${contractId}`);\n        }\n        utils_1.log(arweave, `Replaying ${txInfos.length} confirmed interactions`);\n        yield sortTransactions(arweave, txInfos);\n        // tslint:disable-next-line: prefer-const\n        let { handler, swGlobal } = contractInfo;\n        const validity = {};\n        for (const txInfo of txInfos) {\n            const currentTx = txInfo.node;\n            const contractIndex = txInfo.node.tags.findIndex((tag) => tag.name === 'Contract' && tag.value === contractId);\n            const inputTag = txInfo.node.tags[contractIndex + 1];\n            if (!inputTag || inputTag.name !== 'Input') {\n                utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n                continue;\n            }\n            let input = inputTag.value;\n            try {\n                input = JSON.parse(input);\n            }\n            catch (e) {\n                utils_1.log(arweave, e);\n                continue;\n            }\n            if (!input) {\n                utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n                continue;\n            }\n            const interaction = {\n                input,\n                caller: currentTx.owner.address,\n            };\n            swGlobal._activeTx = currentTx;\n            const result = yield contract_step_1.execute(handler, interaction, state);\n            if (result.type === 'exception') {\n                utils_1.log(arweave, `${result.result}`);\n                utils_1.log(arweave, `Executing of interaction: ${currentTx.id} threw exception.`);\n            }\n            if (result.type === 'error') {\n                utils_1.log(arweave, `${result.result}`);\n                utils_1.log(arweave, `Executing of interaction: ${currentTx.id} returned error.`);\n            }\n            validity[currentTx.id] = result.type === 'ok';\n            state = result.state;\n            const settings = state.settings ? new Map(state.settings) : new Map();\n            const evolve = state.evolve || settings.get('evolve');\n            let canEvolve = state.canEvolve || settings.get('canEvolve');\n            // By default, contracts can evolve if there's not an explicit `false`.\n            if (canEvolve === undefined || canEvolve === null) {\n                canEvolve = true;\n            }\n            if (evolve && /[a-z0-9_-]{43}/i.test(evolve) && canEvolve) {\n                if (contractSrc !== state.evolve) {\n                    try {\n                        contractInfo = yield contract_load_1.loadContract(arweave, contractId, evolve);\n                        handler = contractInfo.handler;\n                    }\n                    catch (e) {\n                        const error = new errors_1.default(\"CONTRACT_NOT_FOUND\" /* CONTRACT_NOT_FOUND */, {\n                            message: `Contract having txId: ${contractId} not found`,\n                            requestedTxId: contractId,\n                        });\n                        throw error;\n                    }\n                }\n            }\n        }\n        return returnValidity ? { state, validity } : state;\n    });\n}\nexports.readContract = readContract;\n// Sort the transactions based on the sort key generated in addSortKey()\nfunction sortTransactions(arweave, txInfos) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const addKeysFuncs = txInfos.map((tx) => addSortKey(arweave, tx));\n        yield Promise.all(addKeysFuncs);\n        txInfos.sort((a, b) => a.sortKey.localeCompare(b.sortKey));\n    });\n}\n// Construct a string that will lexographically sort.\n// { block_height, sha256(block_indep_hash + txid) }\n// pad block height to 12 digits and convert hash value\n// to a hex string.\nfunction addSortKey(arweave, txInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { node } = txInfo;\n        const blockHashBytes = arweave.utils.b64UrlToBuffer(node.block.id);\n        const txIdBytes = arweave.utils.b64UrlToBuffer(node.id);\n        const concatted = arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);\n        const hashed = utils_1.arrayToHex(yield arweave.crypto.hash(concatted));\n        const blockHeight = `000000${node.block.height}`.slice(-12);\n        txInfo.sortKey = `${blockHeight},${hashed}`;\n    });\n}\n// the maximum number of transactions we can get from graphql at once\nconst MAX_REQUEST = 100;\n// fetch all contract interactions up to the specified block height\nfunction fetchTransactions(arweave, contractId, height) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let variables = {\n            tags: [\n                {\n                    name: 'App-Name',\n                    values: ['SmartWeaveAction'],\n                },\n                {\n                    name: 'Contract',\n                    values: [contractId],\n                },\n            ],\n            blockFilter: {\n                max: height,\n            },\n            first: MAX_REQUEST,\n        };\n        let transactions = yield getNextPage(arweave, variables);\n        const txInfos = transactions.edges.filter((tx) => !tx.node.parent || !tx.node.parent.id);\n        while (transactions.pageInfo.hasNextPage) {\n            const cursor = transactions.edges[MAX_REQUEST - 1].cursor;\n            variables = Object.assign(Object.assign({}, variables), { after: cursor });\n            transactions = yield getNextPage(arweave, variables);\n            txInfos.push(...transactions.edges.filter((tx) => !tx.node.parent || !tx.node.parent.id));\n        }\n        return txInfos;\n    });\n}\nfunction getNextPage(arweave, variables) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {\n    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {\n      pageInfo {\n        hasNextPage\n      }\n      edges {\n        node {\n          id\n          owner { address }\n          recipient\n          tags {\n            name\n            value\n          }\n          block {\n            height\n            id\n            timestamp\n          }\n          fee { winston }\n          quantity { winston }\n          parent { id }\n        }\n        cursor\n      }\n    }\n  }`;\n        const response = yield arweave.api.post('graphql', {\n            query,\n            variables,\n        });\n        if (response.status !== 200) {\n            throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response.status}.`);\n        }\n        const data = response.data;\n        const txs = data.data.transactions;\n        return txs;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}