{"ast":null,"code":"import deepForEach from 'deep-for-each';\nimport cloneDeep from 'clone-deep';\nimport asn1 from '@lordvlad/asn1.js';\nimport { Buffer } from 'buffer';\nimport { typedArrayToUint8Array, bnToUint8Array } from './binary';\nimport { EncodeAsn1FailedError, DecodeAsn1FailedError } from './errors'; // Ensure that all asn1 objid are returned as strings separated with '.'\n// See https://github.com/indutny/asn1.js/blob/b99ce086320e0123331e6272f6de75548c6855fa/lib/asn1/decoders/der.js#L198\n\nexport const objidValues = new Proxy({}, {\n  get: (obj, key) => {\n    if (key === 'hasOwnProperty') {\n      return key => key.indexOf('.') > 0;\n    }\n\n    return key.indexOf('.') > 0 ? key : undefined;\n  }\n});\n/* eslint-disable babel/no-invalid-this*/\n\nexport const define = (name, fn) => asn1.define(name, function () {\n  fn(this);\n});\n/* eslint-enable babel/no-invalid-this*/\n\nexport const decodeAsn1 = (encodedEntity, Model) => {\n  let decodedEntity;\n\n  try {\n    decodedEntity = Model.decode(Buffer.from(encodedEntity), 'der');\n  } catch (err) {\n    throw new DecodeAsn1FailedError(`Failed to decode ${Model.name}`, Model.name, {\n      originalError: err\n    });\n  }\n\n  const mapValue = value => {\n    // Convert any typed array, including Node's buffer, to Uint8Array\n    if (ArrayBuffer.isView(value)) {\n      return typedArrayToUint8Array(value);\n    } // Big number to array buffer\n\n\n    if (value && value.toArrayLike) {\n      return bnToUint8Array(value);\n    }\n\n    return value;\n  }; // Apply conversion to all properties deep within the entity\n\n\n  deepForEach(decodedEntity, (value, key, subject) => {\n    subject[key] = mapValue(value);\n  });\n  return mapValue(decodedEntity);\n};\nexport const encodeAsn1 = (decodedEntity, Model) => {\n  const mapValue = value => {\n    // Typed array to node buffer\n    if (value instanceof Uint8Array) {\n      return Buffer.from(value);\n    }\n\n    return value;\n  }; // Clone argument because we are going to mutate it\n\n\n  decodedEntity = cloneDeep(decodedEntity); // Apply conversion to all properties deep within the entity\n\n  decodedEntity = mapValue(decodedEntity);\n  deepForEach(decodedEntity, (value, key, subject) => {\n    subject[key] = mapValue(value);\n  });\n  let encodedEntity;\n\n  try {\n    encodedEntity = Model.encode(decodedEntity, 'der');\n  } catch (err) {\n    /* istanbul ignore next */\n    throw new EncodeAsn1FailedError(`Failed to encode ${Model.name}`, Model.name, {\n      originalError: err\n    });\n  } // Convert Node's buffer (a typed a array) to Uint8Array\n\n\n  return typedArrayToUint8Array(encodedEntity);\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/util/asn1-encoder.js"],"names":["deepForEach","cloneDeep","asn1","Buffer","typedArrayToUint8Array","bnToUint8Array","EncodeAsn1FailedError","DecodeAsn1FailedError","objidValues","Proxy","get","obj","key","indexOf","undefined","define","name","fn","decodeAsn1","encodedEntity","Model","decodedEntity","decode","from","err","originalError","mapValue","value","ArrayBuffer","isView","toArrayLike","subject","encodeAsn1","Uint8Array","encode"],"mappings":"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","sourcesContent":["import deepForEach from 'deep-for-each';\nimport cloneDeep from 'clone-deep';\nimport asn1 from '@lordvlad/asn1.js';\nimport { Buffer } from 'buffer';\nimport { typedArrayToUint8Array, bnToUint8Array } from './binary';\nimport { EncodeAsn1FailedError, DecodeAsn1FailedError } from './errors'; // Ensure that all asn1 objid are returned as strings separated with '.'\n// See https://github.com/indutny/asn1.js/blob/b99ce086320e0123331e6272f6de75548c6855fa/lib/asn1/decoders/der.js#L198\n\nexport const objidValues = new Proxy({}, {\n  get: (obj, key) => {\n    if (key === 'hasOwnProperty') {\n      return key => key.indexOf('.') > 0;\n    }\n\n    return key.indexOf('.') > 0 ? key : undefined;\n  }\n});\n/* eslint-disable babel/no-invalid-this*/\n\nexport const define = (name, fn) => asn1.define(name, function () {\n  fn(this);\n});\n/* eslint-enable babel/no-invalid-this*/\n\nexport const decodeAsn1 = (encodedEntity, Model) => {\n  let decodedEntity;\n\n  try {\n    decodedEntity = Model.decode(Buffer.from(encodedEntity), 'der');\n  } catch (err) {\n    throw new DecodeAsn1FailedError(`Failed to decode ${Model.name}`, Model.name, {\n      originalError: err\n    });\n  }\n\n  const mapValue = value => {\n    // Convert any typed array, including Node's buffer, to Uint8Array\n    if (ArrayBuffer.isView(value)) {\n      return typedArrayToUint8Array(value);\n    } // Big number to array buffer\n\n\n    if (value && value.toArrayLike) {\n      return bnToUint8Array(value);\n    }\n\n    return value;\n  }; // Apply conversion to all properties deep within the entity\n\n\n  deepForEach(decodedEntity, (value, key, subject) => {\n    subject[key] = mapValue(value);\n  });\n  return mapValue(decodedEntity);\n};\nexport const encodeAsn1 = (decodedEntity, Model) => {\n  const mapValue = value => {\n    // Typed array to node buffer\n    if (value instanceof Uint8Array) {\n      return Buffer.from(value);\n    }\n\n    return value;\n  }; // Clone argument because we are going to mutate it\n\n\n  decodedEntity = cloneDeep(decodedEntity); // Apply conversion to all properties deep within the entity\n\n  decodedEntity = mapValue(decodedEntity);\n  deepForEach(decodedEntity, (value, key, subject) => {\n    subject[key] = mapValue(value);\n  });\n  let encodedEntity;\n\n  try {\n    encodedEntity = Model.encode(decodedEntity, 'der');\n  } catch (err) {\n    /* istanbul ignore next */\n    throw new EncodeAsn1FailedError(`Failed to encode ${Model.name}`, Model.name, {\n      originalError: err\n    });\n  } // Convert Node's buffer (a typed a array) to Uint8Array\n\n\n  return typedArrayToUint8Array(encodedEntity);\n};"]},"metadata":{},"sourceType":"module"}