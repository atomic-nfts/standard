{"ast":null,"code":"/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\nvar JpegImage = function jpegImage() {\n  \"use strict\";\n\n  var dctZigZag = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);\n  var dctCos1 = 4017; // cos(pi/16)\n\n  var dctSin1 = 799; // sin(pi/16)\n\n  var dctCos3 = 3406; // cos(3*pi/16)\n\n  var dctSin3 = 2276; // sin(3*pi/16)\n\n  var dctCos6 = 1567; // cos(6*pi/16)\n\n  var dctSin6 = 3784; // sin(6*pi/16)\n\n  var dctSqrt2 = 5793; // sqrt(2)\n\n  var dctSqrt1d2 = 2896; // sqrt(2) / 2\n\n  function constructor() {}\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0,\n        code = [],\n        i,\n        j,\n        length = 16;\n\n    while (length > 0 && !codeLengths[length - 1]) {\n      length--;\n    }\n\n    code.push({\n      children: [],\n      index: 0\n    });\n    var p = code[0],\n        q;\n\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n\n        while (p.index > 0) {\n          if (code.length === 0) throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n\n        p.index++;\n        code.push(p);\n\n        while (code.length <= i) {\n          code.push(q = {\n            children: [],\n            index: 0\n          });\n          p.children[p.index] = q.children;\n          p = q;\n        }\n\n        k++;\n      }\n\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {\n          children: [],\n          index: 0\n        });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH,\n        maxV = frame.maxV;\n    var startOffset = offset,\n        bitsData = 0,\n        bitsCount = 0;\n\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return bitsData >> bitsCount & 1;\n      }\n\n      bitsData = data[offset++];\n\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + (bitsData << 8 | nextByte).toString(16));\n        } // unstuff 0\n\n      }\n\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n\n    function decodeHuffman(tree) {\n      var node = tree,\n          bit;\n\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number') return node;\n        if (typeof node !== 'object') throw new Error(\"invalid huffman sequence\");\n      }\n\n      return null;\n    }\n\n    function receive(length) {\n      var n = 0;\n\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = n << 1 | bit;\n        length--;\n      }\n\n      return n;\n    }\n\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << length - 1) return n;\n      return n + (-1 << length) + 1;\n    }\n\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0] = component.pred += diff;\n      var k = 1;\n\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15,\n            r = rs >> 4;\n\n        if (s === 0) {\n          if (r < 15) break;\n          k += 16;\n          continue;\n        }\n\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n      zz[0] = component.pred += diff;\n    }\n\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n\n    var eobrun = 0;\n\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n\n      var k = spectralStart,\n          e = spectralEnd;\n\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15,\n            r = rs >> 4;\n\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n\n          k += 16;\n          continue;\n        }\n\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n\n    var successiveACState = 0,\n        successiveACNextValue;\n\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart,\n          e = spectralEnd,\n          r = 0;\n\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n\n        switch (successiveACState) {\n          case 0:\n            // initial state\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15,\n                r = rs >> 4;\n\n            if (s === 0) {\n              if (r < 15) {\n                eobrun = receive(r) + (1 << r);\n                successiveACState = 4;\n              } else {\n                r = 16;\n                successiveACState = 1;\n              }\n            } else {\n              if (s !== 1) throw new Error(\"invalid ACn encoding\");\n              successiveACNextValue = receiveAndExtend(s);\n              successiveACState = r ? 2 : 3;\n            }\n\n            continue;\n\n          case 1: // skipping r zero items\n\n          case 2:\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;else {\n              r--;\n              if (r === 0) successiveACState = successiveACState == 2 ? 3 : 0;\n            }\n            break;\n\n          case 3:\n            // set value for a zero item\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;else {\n              zz[z] = successiveACNextValue << successive;\n              successiveACState = 0;\n            }\n            break;\n\n          case 4:\n            // eob\n            if (zz[z]) zz[z] += (readBit() << successive) * direction;\n            break;\n        }\n\n        k++;\n      }\n\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0) successiveACState = 0;\n      }\n    }\n\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = mcu / mcusPerLine | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = mcu / component.blocksPerLine | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n\n    if (progressive) {\n      if (spectralStart === 0) decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;else decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0,\n        marker;\n    var mcuExpected;\n\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n\n    if (!resetInterval) resetInterval = mcuExpected;\n    var h, v;\n\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++) {\n        components[i].pred = 0;\n      }\n\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n\n          mcu++; // If we've reached our expected MCU's, stop decoding\n\n          if (mcu === mcuExpected) break;\n        }\n      } // find marker\n\n\n      bitsCount = 0;\n      marker = data[offset] << 8 | data[offset + 1];\n\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) {\n        // RSTx\n        offset += 2;\n      } else break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var R = new Int32Array(64),\n        r = new Uint8Array(64); // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i; // dequant\n\n      for (i = 0; i < 64; i++) {\n        p[i] = zz[i] * qt[i];\n      } // inverse DCT on rows\n\n\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i; // check for all-zero AC coefficients\n\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {\n          t = dctSqrt2 * p[0 + row] + 512 >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        } // stage 4\n\n\n        v0 = dctSqrt2 * p[0 + row] + 128 >> 8;\n        v1 = dctSqrt2 * p[4 + row] + 128 >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;\n        v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4; // stage 3\n\n        t = v0 - v1 + 1 >> 1;\n        v0 = v0 + v1 + 1 >> 1;\n        v1 = t;\n        t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\n        v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\n        v3 = t;\n        t = v4 - v6 + 1 >> 1;\n        v4 = v4 + v6 + 1 >> 1;\n        v6 = t;\n        t = v7 + v5 + 1 >> 1;\n        v5 = v7 - v5 + 1 >> 1;\n        v7 = t; // stage 2\n\n        t = v0 - v3 + 1 >> 1;\n        v0 = v0 + v3 + 1 >> 1;\n        v3 = t;\n        t = v1 - v2 + 1 >> 1;\n        v1 = v1 + v2 + 1 >> 1;\n        v2 = t;\n        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n        v7 = t;\n        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n        v6 = t; // stage 1\n\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      } // inverse DCT on columns\n\n\n      for (i = 0; i < 8; ++i) {\n        var col = i; // check for all-zero AC coefficients\n\n        if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {\n          t = dctSqrt2 * dataIn[i + 0] + 8192 >> 14;\n          p[0 * 8 + col] = t;\n          p[1 * 8 + col] = t;\n          p[2 * 8 + col] = t;\n          p[3 * 8 + col] = t;\n          p[4 * 8 + col] = t;\n          p[5 * 8 + col] = t;\n          p[6 * 8 + col] = t;\n          p[7 * 8 + col] = t;\n          continue;\n        } // stage 4\n\n\n        v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;\n        v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;\n        v2 = p[2 * 8 + col];\n        v3 = p[6 * 8 + col];\n        v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;\n        v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;\n        v5 = p[3 * 8 + col];\n        v6 = p[5 * 8 + col]; // stage 3\n\n        t = v0 - v1 + 1 >> 1;\n        v0 = v0 + v1 + 1 >> 1;\n        v1 = t;\n        t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\n        v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\n        v3 = t;\n        t = v4 - v6 + 1 >> 1;\n        v4 = v4 + v6 + 1 >> 1;\n        v6 = t;\n        t = v7 + v5 + 1 >> 1;\n        v5 = v7 - v5 + 1 >> 1;\n        v7 = t; // stage 2\n\n        t = v0 - v3 + 1 >> 1;\n        v0 = v0 + v3 + 1 >> 1;\n        v3 = t;\n        t = v1 - v2 + 1 >> 1;\n        v1 = v1 + v2 + 1 >> 1;\n        v2 = t;\n        t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n        v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n        v7 = t;\n        t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n        v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n        v6 = t; // stage 1\n\n        p[0 * 8 + col] = v0 + v7;\n        p[7 * 8 + col] = v0 - v7;\n        p[1 * 8 + col] = v1 + v6;\n        p[6 * 8 + col] = v1 - v6;\n        p[2 * 8 + col] = v2 + v5;\n        p[5 * 8 + col] = v2 - v5;\n        p[3 * 8 + col] = v3 + v4;\n        p[4 * 8 + col] = v3 - v4;\n      } // convert to 8-bit integers\n\n\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + (p[i] + 8 >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    var i, j;\n\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n\n      for (i = 0; i < 8; i++) {\n        lines.push(new Uint8Array(samplesPerLine));\n      }\n\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n        var offset = 0,\n            sample = blockCol << 3;\n\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n\n          for (i = 0; i < 8; i++) {\n            line[sample + i] = r[offset++];\n          }\n        }\n      }\n    }\n\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n\n      xhr.onload = function () {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload) this.onload();\n      }.bind(this);\n\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var offset = 0,\n          length = data.length;\n\n      function readUint16() {\n        var value = data[offset] << 8 | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n\n      function prepareComponents(frame) {\n        var maxH = 0,\n            maxV = 0;\n        var component, componentId;\n\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n\n              for (var j = 0; j < blocksPerLineForMcu; j++) {\n                row.push(new Int32Array(64));\n              }\n\n              blocks.push(row);\n            }\n\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [],\n          frames = [];\n      var huffmanTablesAC = [],\n          huffmanTablesDC = [];\n      var fileMarker = readUint16();\n\n      if (fileMarker != 0xFFD8) {\n        // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n\n      while (fileMarker != 0xFFD9) {\n        // EOI (End of image)\n        var i, j, l;\n\n        switch (fileMarker) {\n          case 0xFF00:\n            break;\n\n          case 0xFFE0: // APP0 (Application Specific)\n\n          case 0xFFE1: // APP1\n\n          case 0xFFE2: // APP2\n\n          case 0xFFE3: // APP3\n\n          case 0xFFE4: // APP4\n\n          case 0xFFE5: // APP5\n\n          case 0xFFE6: // APP6\n\n          case 0xFFE7: // APP7\n\n          case 0xFFE8: // APP8\n\n          case 0xFFE9: // APP9\n\n          case 0xFFEA: // APP10\n\n          case 0xFFEB: // APP11\n\n          case 0xFFEC: // APP12\n\n          case 0xFFED: // APP13\n\n          case 0xFFEE: // APP14\n\n          case 0xFFEF: // APP15\n\n          case 0xFFFE:\n            // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {\n                // 'JFIF\\x00'\n                jfif = {\n                  version: {\n                    major: appData[5],\n                    minor: appData[6]\n                  },\n                  densityUnits: appData[7],\n                  xDensity: appData[8] << 8 | appData[9],\n                  yDensity: appData[10] << 8 | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            } // TODO APP1 - Exif\n\n\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) {\n                // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: appData[7] << 8 | appData[8],\n                  flags1: appData[9] << 8 | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n\n            break;\n\n          case 0xFFDB:\n            // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              var tableData = new Int32Array(64);\n\n              if (quantizationTableSpec >> 4 === 0) {\n                // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if (quantizationTableSpec >> 4 === 1) {\n                //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else throw new Error(\"DQT: invalid table spec\");\n\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n\n          case 0xFFC2:\n            // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n\n            frame = {};\n            frame.extended = fileMarker === 0xFFC1;\n            frame.progressive = fileMarker === 0xFFC2;\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var componentsCount = data[offset++],\n                componentId;\n            var maxH = 0,\n                maxV = 0;\n\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4:\n            // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n\n              for (j = 0; j < 16; j++, offset++) {\n                codeLengthSum += codeLengths[j] = data[offset];\n              }\n\n              var huffmanValues = new Uint8Array(codeLengthSum);\n\n              for (j = 0; j < codeLengthSum; j++, offset++) {\n                huffmanValues[j] = data[offset];\n              }\n\n              i += 17 + codeLengthSum;\n              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n            }\n\n            break;\n\n          case 0xFFDD:\n            // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDA:\n            // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [],\n                component;\n\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n            offset += processed;\n            break;\n\n          case 0xFFFF:\n            // Fill bytes\n            if (data[offset] !== 0xFF) {\n              // Avoid skipping a valid marker.\n              offset--;\n            }\n\n            break;\n\n          default:\n            if (data[offset - 3] == 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n\n        fileMarker = readUint16();\n      }\n\n      if (frames.length != 1) throw new Error(\"only single frame JPEGs supported\"); // set each frame's components quantization table\n\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width,\n          scaleY = this.height / height;\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      var data = new Uint8Array(dataLength);\n\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | x * component1.scaleX * scaleX];\n              data[offset++] = Y;\n            }\n          }\n\n          break;\n\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | x * component1.scaleX * scaleX];\n              data[offset++] = Y;\n              Y = component2Line[0 | x * component2.scaleX * scaleX];\n              data[offset++] = Y;\n            }\n          }\n\n          break;\n\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true; // The adobe transform marker overrides any previous setting\n\n          if (this.adobe && this.adobe.transformCode) colorTransform = true;else if (typeof this.colorTransform !== 'undefined') colorTransform = !!this.colorTransform;\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            component3Line = component3.lines[0 | y * component3.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | x * component1.scaleX * scaleX];\n                G = component2Line[0 | x * component2.scaleX * scaleX];\n                B = component3Line[0 | x * component3.scaleX * scaleX];\n              } else {\n                Y = component1Line[0 | x * component1.scaleX * scaleX];\n                Cb = component2Line[0 | x * component2.scaleX * scaleX];\n                Cr = component3Line[0 | x * component3.scaleX * scaleX];\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n\n          break;\n\n        case 4:\n          if (!this.adobe) throw new Error('Unsupported color mode (4 components)'); // The default transform for four components is false\n\n          colorTransform = false; // The adobe transform marker overrides any previous setting\n\n          if (this.adobe && this.adobe.transformCode) colorTransform = true;else if (typeof this.colorTransform !== 'undefined') colorTransform = !!this.colorTransform;\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | y * component1.scaleY * scaleY];\n            component2Line = component2.lines[0 | y * component2.scaleY * scaleY];\n            component3Line = component3.lines[0 | y * component3.scaleY * scaleY];\n            component4Line = component4.lines[0 | y * component4.scaleY * scaleY];\n\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | x * component1.scaleX * scaleX];\n                M = component2Line[0 | x * component2.scaleX * scaleX];\n                Ye = component3Line[0 | x * component3.scaleX * scaleX];\n                K = component4Line[0 | x * component4.scaleX * scaleX];\n              } else {\n                Y = component1Line[0 | x * component1.scaleX * scaleX];\n                Cb = component2Line[0 | x * component2.scaleX * scaleX];\n                Cr = component3Line[0 | x * component3.scaleX * scaleX];\n                K = component4Line[0 | x * component4.scaleX * scaleX];\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = 255 - C;\n              data[offset++] = 255 - M;\n              data[offset++] = 255 - Ye;\n              data[offset++] = 255 - K;\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported color mode');\n      }\n\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width,\n          height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0,\n          j = 0,\n          x,\n          y;\n      var Y, K, C, M, R, G, B;\n\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n\n          break;\n\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n\n          break;\n\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n  return constructor;\n}();\n\nmodule.exports = decode;\n\nfunction decode(jpegData, opts) {\n  var defaultOpts = {\n    useTArray: false,\n    // \"undefined\" means \"Choose whether to transform colors based on the image’s color model.\"\n    colorTransform: undefined,\n    formatAsRGBA: true\n  };\n\n  if (opts) {\n    if (typeof opts === 'object') {\n      opts = {\n        useTArray: typeof opts.useTArray === 'undefined' ? defaultOpts.useTArray : opts.useTArray,\n        colorTransform: typeof opts.colorTransform === 'undefined' ? defaultOpts.colorTransform : opts.colorTransform,\n        formatAsRGBA: typeof opts.formatAsRGBA === 'undefined' ? defaultOpts.formatAsRGBA : opts.formatAsRGBA\n      };\n    } else {\n      // backwards compatiblity, before 0.3.5, we only had the useTArray param\n      opts = defaultOpts;\n      opts.useTArray = true;\n    }\n  } else {\n    opts = defaultOpts;\n  }\n\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.parse(arr);\n  decoder.colorTransform = opts.colorTransform;\n  var channels = opts.formatAsRGBA ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n\n  try {\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      data: opts.useTArray ? new Uint8Array(bytesNeeded) : new Buffer(bytesNeeded)\n    };\n  } catch (err) {\n    if (err instanceof RangeError) {\n      throw new Error(\"Could not allocate enough memory for the image. \" + \"Required: \" + bytesNeeded);\n    } else {\n      throw err;\n    }\n  }\n\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n  return image;\n}","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/jpeg-js/lib/decoder.js"],"names":["JpegImage","jpegImage","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","constructor","buildHuffmanTable","codeLengths","values","k","code","i","j","length","push","children","index","p","q","pop","Error","decodeScan","data","offset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","precision","samplesPerLine","scanLines","mcusPerLine","progressive","maxH","maxV","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","node","bit","receive","n","receiveAndExtend","decodeBaseline","component","zz","t","huffmanTableDC","diff","pred","rs","huffmanTableAC","s","r","z","decodeDCFirst","decodeDCSuccessive","eobrun","decodeACFirst","e","successiveACState","successiveACNextValue","decodeACSuccessive","direction","decodeMcu","decode","mcu","row","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","decodeBlock","blocksPerLine","componentsLength","decodeFn","marker","mcuExpected","blocksPerColumn","mcusPerColumn","buildComponentData","lines","R","Uint8Array","quantizeAndInverse","dataOut","dataIn","qt","quantizationTable","v0","v1","v2","v3","v4","v5","v6","v7","sample","scanLine","line","clampTo8bit","a","prototype","load","path","xhr","XMLHttpRequest","open","responseType","onload","response","mozResponseArrayBuffer","parse","bind","send","readUint16","value","readDataBlock","array","subarray","prepareComponents","componentId","hasOwnProperty","Math","ceil","blocksPerLineForMcu","blocksPerColumnForMcu","jfif","adobe","pixels","quantizationTables","frames","huffmanTablesAC","huffmanTablesDC","fileMarker","l","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","componentsOrder","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","scanLength","selectorsCount","tableSpec","successiveApproximation","processed","cp","width","height","scaleX","scaleY","getData","component1","component2","component3","component4","component1Line","component2Line","component3Line","component4Line","x","y","Y","Cb","Cr","K","C","M","Ye","G","B","colorTransform","dataLength","copyToImageData","imageData","formatAsRGBA","imageDataArray","module","exports","jpegData","opts","defaultOpts","useTArray","undefined","arr","decoder","channels","bytesNeeded","image","Buffer","err","RangeError"],"mappings":"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","sourcesContent":["/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = (function jpegImage() {\n  \"use strict\";\n  var dctZigZag = new Int32Array([\n     0,\n     1,  8,\n    16,  9,  2,\n     3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n     5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13,  6,\n     7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63\n  ]);\n\n  var dctCos1  =  4017   // cos(pi/16)\n  var dctSin1  =   799   // sin(pi/16)\n  var dctCos3  =  3406   // cos(3*pi/16)\n  var dctSin3  =  2276   // sin(3*pi/16)\n  var dctCos6  =  1567   // cos(6*pi/16)\n  var dctSin6  =  3784   // sin(6*pi/16)\n  var dctSqrt2 =  5793   // sqrt(2)\n  var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n  function constructor() {\n  }\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n      length--;\n    code.push({children: [], index: 0});\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          if (code.length === 0)\n            throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {children: [], index: 0});\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {children: [], index: 0});\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset,\n                      frame, components, resetInterval,\n                      spectralStart, spectralEnd,\n                      successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return (bitsData >> bitsCount) & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16));\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree, bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number')\n          return node;\n        if (typeof node !== 'object')\n          throw new Error(\"invalid huffman sequence\");\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = (n << 1) | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << (length - 1))\n        return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0]= (component.pred += diff);\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15)\n            break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n      zz[0] = (component.pred += diff);\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart, e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart, e = spectralEnd, r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n        switch (successiveACState) {\n        case 0: // initial state\n          var rs = decodeHuffman(component.huffmanTableAC);\n          var s = rs & 15, r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1)\n              throw new Error(\"invalid ACn encoding\");\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            r--;\n            if (r === 0)\n              successiveACState = successiveACState == 2 ? 3 : 0;\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0)\n          successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = (mcu / mcusPerLine) | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = (mcu / component.blocksPerLine) | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0)\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n      else\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++)\n        components[i].pred = 0;\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = (data[offset] << 8) | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n        offset += 2;\n      }\n      else\n        break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var R = new Int32Array(64), r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++)\n        p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n            p[7 + row] == 0) {\n          t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = (v0 - v1+ 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n            p[7*8 + col] == 0) {\n          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;\n          p[0*8 + col] = t;\n          p[1*8 + col] = t;\n          p[2*8 + col] = t;\n          p[3*8 + col] = t;\n          p[4*8 + col] = t;\n          p[5*8 + col] = t;\n          p[6*8 + col] = t;\n          p[7*8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n        v2 = p[2*8 + col];\n        v3 = p[6*8 + col];\n        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n        v5 = p[3*8 + col];\n        v6 = p[5*8 + col];\n\n        // stage 3\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0*8 + col] = v0 + v7;\n        p[7*8 + col] = v0 - v7;\n        p[1*8 + col] = v1 + v6;\n        p[6*8 + col] = v1 - v6;\n        p[2*8 + col] = v2 + v5;\n        p[5*8 + col] = v2 - v5;\n        p[3*8 + col] = v3 + v4;\n        p[4*8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + ((p[i] + 8) >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++)\n        lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n        var offset = 0, sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++)\n            line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var offset = 0, length = data.length;\n      function readUint16() {\n        var value = (data[offset] << 8) | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0, maxV = 0;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++)\n                row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [], frames = [];\n      var huffmanTablesAC = [], huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) { // EOI (End of image)\n        var i, j, l;\n        switch(fileMarker) {\n          case 0xFF00: break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE: // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                jfif = {\n                  version: { major: appData[5], minor: appData[6] },\n                  densityUnits: appData[7],\n                  xDensity: (appData[8] << 8) | appData[9],\n                  yDensity: (appData[10] << 8) | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: (appData[7] << 8) | appData[8],\n                  flags1: (appData[9] << 8) | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n\n          case 0xFFDB: // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              var tableData = new Int32Array(64);\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else\n                throw new Error(\"DQT: invalid table spec\");\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = (fileMarker === 0xFFC1);\n            frame.progressive = (fileMarker === 0xFFC2);\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var componentsCount = data[offset++], componentId;\n            var maxH = 0, maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4: // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++)\n                codeLengthSum += (codeLengths[j] = data[offset]);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++)\n                huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n\n              ((huffmanTableSpec >> 4) === 0 ?\n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n\n          case 0xFFDD: // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDA: // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [], component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset,\n              frame, components, resetInterval,\n              spectralStart, spectralEnd,\n              successiveApproximation >> 4, successiveApproximation & 15);\n            offset += processed;\n            break;\n\n          case 0xFFFF: // Fill bytes\n            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n\n          default:\n            if (data[offset - 3] == 0xFF &&\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1)\n        throw new Error(\"only single frame JPEGs supported\");\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width, scaleY = this.height / height;\n\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n              data[offset++] = Y;\n              Y = component2Line[0 | (x * component2.scaleX * scaleX)];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | (x * component1.scaleX * scaleX)];\n                G = component2Line[0 | (x * component2.scaleX * scaleX)];\n                B = component3Line[0 | (x * component3.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe)\n            throw new Error('Unsupported color mode (4 components)');\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | (x * component1.scaleX * scaleX)];\n                M = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255-C;\n              data[offset++] = 255-M;\n              data[offset++] = 255-Ye;\n              data[offset++] = 255-K;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width, height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0, j = 0, x, y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n\n  return constructor;\n})();\nmodule.exports = decode;\n\nfunction decode(jpegData, opts) {\n  var defaultOpts = {\n    useTArray: false,\n    // \"undefined\" means \"Choose whether to transform colors based on the image’s color model.\"\n    colorTransform: undefined,\n    formatAsRGBA: true\n  };\n  if (opts) {\n    if (typeof opts === 'object') {\n      opts = {\n        useTArray: (typeof opts.useTArray === 'undefined' ?\n                    defaultOpts.useTArray : opts.useTArray),\n        colorTransform: (typeof opts.colorTransform === 'undefined' ?\n                         defaultOpts.colorTransform : opts.colorTransform),\n        formatAsRGBA: (typeof opts.formatAsRGBA === 'undefined' ?\n                         defaultOpts.formatAsRGBA : opts.formatAsRGBA)\n      };\n    } else {\n      // backwards compatiblity, before 0.3.5, we only had the useTArray param\n      opts = defaultOpts;\n      opts.useTArray = true;\n    }\n  } else {\n    opts = defaultOpts;\n  }\n\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.parse(arr);\n  decoder.colorTransform = opts.colorTransform;\n\n  var channels = (opts.formatAsRGBA) ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n  try {\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      data: opts.useTArray ?\n        new Uint8Array(bytesNeeded) :\n        new Buffer(bytesNeeded)\n    };\n  } catch (err){\n    if (err instanceof RangeError){\n      throw new Error(\"Could not allocate enough memory for the image. \" +\n                      \"Required: \" + bytesNeeded);\n    } else {\n      throw err;\n    }\n  }\n\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n\n  return image;\n}\n"]},"metadata":{},"sourceType":"script"}