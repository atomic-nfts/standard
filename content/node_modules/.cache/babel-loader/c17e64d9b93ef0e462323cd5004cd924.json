{"ast":null,"code":"import { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey, SUPPORTED_KEY_TYPES } from './keys';\nimport { UnsupportedAlgorithmError, DecodeAsn1FailedError, AggregatedError } from '../../util/errors';\nexport const decomposePrivateKey = privateKeyAsn1 => {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  let decomposedKey;\n  const errors = {};\n\n  for (const keyType of SUPPORTED_KEY_TYPES.private) {\n    try {\n      decomposedKey = decomposeRawPrivateKey(keyType, privateKeyAsn1);\n      break;\n    } catch (err) {\n      if (err instanceof DecodeAsn1FailedError) {\n        errors[keyType] = err;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.private.join(', ')}`, errors, {\n      invalidInputKey: true\n    });\n  }\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposedKey;\n  return {\n    format: 'raw-der',\n    encryptionAlgorithm: null,\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}) => {\n  if (encryptionAlgorithm) {\n    throw new UnsupportedAlgorithmError('The RAW DER format does not support encryption');\n  }\n\n  return composeRawPrivateKey(keyAlgorithm, keyData);\n};\nexport const decomposePublicKey = publicKeyAsn1 => {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  let decomposedKey;\n  const errors = {};\n\n  for (const keyType of SUPPORTED_KEY_TYPES.public) {\n    try {\n      decomposedKey = decomposeRawPublicKey(keyType, publicKeyAsn1);\n      break;\n    } catch (err) {\n      /* istanbul ignore else */\n      if (err instanceof DecodeAsn1FailedError) {\n        errors[keyType] = err;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.public.join(', ')}`, errors, {\n      invalidInputKey: true\n    });\n  }\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposedKey;\n  return {\n    format: 'raw-der',\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePublicKey = ({\n  keyAlgorithm,\n  keyData\n}) => composeRawPublicKey(keyAlgorithm, keyData);","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/formats/raw/raw-der.js"],"names":["decomposeRawPrivateKey","composeRawPrivateKey","decomposeRawPublicKey","composeRawPublicKey","SUPPORTED_KEY_TYPES","UnsupportedAlgorithmError","DecodeAsn1FailedError","AggregatedError","decomposePrivateKey","privateKeyAsn1","decomposedKey","errors","keyType","private","err","join","invalidInputKey","keyAlgorithm","keyData","format","encryptionAlgorithm","composePrivateKey","decomposePublicKey","publicKeyAsn1","public","composePublicKey"],"mappings":"AAAA,SAASA,sBAAT,EAAiCC,oBAAjC,EAAuDC,qBAAvD,EAA8EC,mBAA9E,EAAmGC,mBAAnG,QAA8H,QAA9H;AACA,SAASC,yBAAT,EAAoCC,qBAApC,EAA2DC,eAA3D,QAAkF,mBAAlF;AACA,OAAO,MAAMC,mBAAmB,GAAGC,cAAc,IAAI;AACnD;AACA;AACA,MAAIC,aAAJ;AACA,QAAMC,MAAM,GAAG,EAAf;;AAEA,OAAK,MAAMC,OAAX,IAAsBR,mBAAmB,CAACS,OAA1C,EAAmD;AACjD,QAAI;AACFH,MAAAA,aAAa,GAAGV,sBAAsB,CAACY,OAAD,EAAUH,cAAV,CAAtC;AACA;AACD,KAHD,CAGE,OAAOK,GAAP,EAAY;AACZ,UAAIA,GAAG,YAAYR,qBAAnB,EAA0C;AACxCK,QAAAA,MAAM,CAACC,OAAD,CAAN,GAAkBE,GAAlB;AACD,OAFD,MAEO;AACL,cAAMA,GAAN;AACD;AACF;AACF;;AAED,MAAI,CAACJ,aAAL,EAAoB;AAClB,UAAM,IAAIH,eAAJ,CAAqB,gCAA+BH,mBAAmB,CAACS,OAApB,CAA4BE,IAA5B,CAAiC,IAAjC,CAAuC,EAA3F,EAA8FJ,MAA9F,EAAsG;AAC1GK,MAAAA,eAAe,EAAE;AADyF,KAAtG,CAAN;AAGD;;AAED,QAAM;AACJC,IAAAA,YADI;AAEJC,IAAAA;AAFI,MAGFR,aAHJ;AAIA,SAAO;AACLS,IAAAA,MAAM,EAAE,SADH;AAELC,IAAAA,mBAAmB,EAAE,IAFhB;AAGLH,IAAAA,YAHK;AAILC,IAAAA;AAJK,GAAP;AAMD,CAnCM;AAoCP,OAAO,MAAMG,iBAAiB,GAAG,CAAC;AAChCJ,EAAAA,YADgC;AAEhCC,EAAAA,OAFgC;AAGhCE,EAAAA;AAHgC,CAAD,KAI3B;AACJ,MAAIA,mBAAJ,EAAyB;AACvB,UAAM,IAAIf,yBAAJ,CAA8B,gDAA9B,CAAN;AACD;;AAED,SAAOJ,oBAAoB,CAACgB,YAAD,EAAeC,OAAf,CAA3B;AACD,CAVM;AAWP,OAAO,MAAMI,kBAAkB,GAAGC,aAAa,IAAI;AACjD;AACA;AACA,MAAIb,aAAJ;AACA,QAAMC,MAAM,GAAG,EAAf;;AAEA,OAAK,MAAMC,OAAX,IAAsBR,mBAAmB,CAACoB,MAA1C,EAAkD;AAChD,QAAI;AACFd,MAAAA,aAAa,GAAGR,qBAAqB,CAACU,OAAD,EAAUW,aAAV,CAArC;AACA;AACD,KAHD,CAGE,OAAOT,GAAP,EAAY;AACZ;AACA,UAAIA,GAAG,YAAYR,qBAAnB,EAA0C;AACxCK,QAAAA,MAAM,CAACC,OAAD,CAAN,GAAkBE,GAAlB;AACD,OAFD,MAEO;AACL,cAAMA,GAAN;AACD;AACF;AACF;;AAED,MAAI,CAACJ,aAAL,EAAoB;AAClB,UAAM,IAAIH,eAAJ,CAAqB,gCAA+BH,mBAAmB,CAACoB,MAApB,CAA2BT,IAA3B,CAAgC,IAAhC,CAAsC,EAA1F,EAA6FJ,MAA7F,EAAqG;AACzGK,MAAAA,eAAe,EAAE;AADwF,KAArG,CAAN;AAGD;;AAED,QAAM;AACJC,IAAAA,YADI;AAEJC,IAAAA;AAFI,MAGFR,aAHJ;AAIA,SAAO;AACLS,IAAAA,MAAM,EAAE,SADH;AAELF,IAAAA,YAFK;AAGLC,IAAAA;AAHK,GAAP;AAKD,CAnCM;AAoCP,OAAO,MAAMO,gBAAgB,GAAG,CAAC;AAC/BR,EAAAA,YAD+B;AAE/BC,EAAAA;AAF+B,CAAD,KAG1Bf,mBAAmB,CAACc,YAAD,EAAeC,OAAf,CAHlB","sourcesContent":["import { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey, SUPPORTED_KEY_TYPES } from './keys';\nimport { UnsupportedAlgorithmError, DecodeAsn1FailedError, AggregatedError } from '../../util/errors';\nexport const decomposePrivateKey = privateKeyAsn1 => {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  let decomposedKey;\n  const errors = {};\n\n  for (const keyType of SUPPORTED_KEY_TYPES.private) {\n    try {\n      decomposedKey = decomposeRawPrivateKey(keyType, privateKeyAsn1);\n      break;\n    } catch (err) {\n      if (err instanceof DecodeAsn1FailedError) {\n        errors[keyType] = err;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.private.join(', ')}`, errors, {\n      invalidInputKey: true\n    });\n  }\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposedKey;\n  return {\n    format: 'raw-der',\n    encryptionAlgorithm: null,\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}) => {\n  if (encryptionAlgorithm) {\n    throw new UnsupportedAlgorithmError('The RAW DER format does not support encryption');\n  }\n\n  return composeRawPrivateKey(keyAlgorithm, keyData);\n};\nexport const decomposePublicKey = publicKeyAsn1 => {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  let decomposedKey;\n  const errors = {};\n\n  for (const keyType of SUPPORTED_KEY_TYPES.public) {\n    try {\n      decomposedKey = decomposeRawPublicKey(keyType, publicKeyAsn1);\n      break;\n    } catch (err) {\n      /* istanbul ignore else */\n      if (err instanceof DecodeAsn1FailedError) {\n        errors[keyType] = err;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.public.join(', ')}`, errors, {\n      invalidInputKey: true\n    });\n  }\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposedKey;\n  return {\n    format: 'raw-der',\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePublicKey = ({\n  keyAlgorithm,\n  keyData\n}) => composeRawPublicKey(keyAlgorithm, keyData);"]},"metadata":{},"sourceType":"module"}