{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar Stream = require('stream');\n\nvar ChunkStream = module.exports = function () {\n  Stream.call(this);\n  this._buffers = [];\n  this._buffered = 0;\n  this._reads = [];\n  this._paused = false;\n  this._encoding = 'utf8';\n  this.writable = true;\n};\n\nutil.inherits(ChunkStream, Stream);\n\nChunkStream.prototype.read = function (length, callback) {\n  this._reads.push({\n    length: Math.abs(length),\n    // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n\n  process.nextTick(function () {\n    this._process(); // its paused and there is not enought data then ask for more\n\n\n    if (this._paused && this._reads.length > 0) {\n      this._paused = false;\n      this.emit('drain');\n    }\n  }.bind(this));\n};\n\nChunkStream.prototype.write = function (data, encoding) {\n  if (!this.writable) {\n    this.emit('error', new Error('Stream not writable'));\n    return false;\n  }\n\n  var dataBuffer;\n\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  } else {\n    dataBuffer = new Buffer(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n\n  this._buffered += dataBuffer.length;\n\n  this._process(); // ok if there are no more read requests\n\n\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function (data, encoding) {\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false; // already destroyed\n\n  if (!this._buffers) {\n    return;\n  } // enqueue or handle end\n\n\n  if (this._buffers.length === 0) {\n    this._end();\n  } else {\n    this._buffers.push(null);\n\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function () {\n  if (this._reads.length > 0) {\n    this.emit('error', new Error('There are some read requests waitng on finished stream'));\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function () {\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n  this.emit('close');\n};\n\nChunkStream.prototype._processReadAllowingLess = function (read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n  // first we need to peek into first buffer\n\n\n  var smallerBuf = this._buffers[0]; // ok there is more data than we need\n\n  if (smallerBuf.length > read.length) {\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n    read.func.call(this, smallerBuf.slice(0, read.length));\n  } else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n\n    this._buffers.shift(); // == smallerBuf\n\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function (read) {\n  this._reads.shift(); // == read\n\n\n  var pos = 0;\n  var count = 0;\n  var data = new Buffer(read.length); // create buffer for all data\n\n  while (pos < read.length) {\n    var buf = this._buffers[count++];\n    var len = Math.min(buf.length, read.length - pos);\n    buf.copy(data, pos, 0, len);\n    pos += len; // last buffer wasn't used all so just slice it and leave\n\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  } // remove all used buffers\n\n\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function () {\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n      var read = this._reads[0]; // read any data (but no more than length)\n\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n      } else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n        this._processRead(read);\n      } else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {\n      this._end();\n    }\n  } catch (ex) {\n    this.emit('error', ex);\n  }\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/pngjs-nozlib/lib/chunkstream.js"],"names":["util","require","Stream","ChunkStream","module","exports","call","_buffers","_buffered","_reads","_paused","_encoding","writable","inherits","prototype","read","length","callback","push","Math","abs","allowLess","func","process","nextTick","_process","emit","bind","write","data","encoding","Error","dataBuffer","Buffer","isBuffer","end","_end","destroySoon","destroy","_processReadAllowingLess","shift","smallerBuf","slice","_processRead","pos","count","buf","len","min","copy","splice","ex"],"mappings":"AAAA;;AAGA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAApB;;AAGA,IAAIE,WAAW,GAAGC,MAAM,CAACC,OAAP,GAAiB,YAAW;AAC5CH,EAAAA,MAAM,CAACI,IAAP,CAAY,IAAZ;AAEA,OAAKC,QAAL,GAAgB,EAAhB;AACA,OAAKC,SAAL,GAAiB,CAAjB;AAEA,OAAKC,MAAL,GAAc,EAAd;AACA,OAAKC,OAAL,GAAe,KAAf;AAEA,OAAKC,SAAL,GAAiB,MAAjB;AACA,OAAKC,QAAL,GAAgB,IAAhB;AACD,CAXD;;AAYAZ,IAAI,CAACa,QAAL,CAAcV,WAAd,EAA2BD,MAA3B;;AAGAC,WAAW,CAACW,SAAZ,CAAsBC,IAAtB,GAA6B,UAASC,MAAT,EAAiBC,QAAjB,EAA2B;AAEtD,OAAKR,MAAL,CAAYS,IAAZ,CAAiB;AACfF,IAAAA,MAAM,EAAEG,IAAI,CAACC,GAAL,CAASJ,MAAT,CADO;AACY;AAC3BK,IAAAA,SAAS,EAAEL,MAAM,GAAG,CAFL;AAGfM,IAAAA,IAAI,EAAEL;AAHS,GAAjB;;AAMAM,EAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1B,SAAKC,QAAL,GAD0B,CAG1B;;;AACA,QAAI,KAAKf,OAAL,IAAgB,KAAKD,MAAL,CAAYO,MAAZ,GAAqB,CAAzC,EAA4C;AAC1C,WAAKN,OAAL,GAAe,KAAf;AAEA,WAAKgB,IAAL,CAAU,OAAV;AACD;AACF,GATgB,CASfC,IATe,CASV,IATU,CAAjB;AAUD,CAlBD;;AAoBAxB,WAAW,CAACW,SAAZ,CAAsBc,KAAtB,GAA8B,UAASC,IAAT,EAAeC,QAAf,EAAyB;AAErD,MAAI,CAAC,KAAKlB,QAAV,EAAoB;AAClB,SAAKc,IAAL,CAAU,OAAV,EAAmB,IAAIK,KAAJ,CAAU,qBAAV,CAAnB;AACA,WAAO,KAAP;AACD;;AAED,MAAIC,UAAJ;;AACA,MAAIC,MAAM,CAACC,QAAP,CAAgBL,IAAhB,CAAJ,EAA2B;AACzBG,IAAAA,UAAU,GAAGH,IAAb;AACD,GAFD,MAGK;AACHG,IAAAA,UAAU,GAAG,IAAIC,MAAJ,CAAWJ,IAAX,EAAiBC,QAAQ,IAAI,KAAKnB,SAAlC,CAAb;AACD;;AAED,OAAKJ,QAAL,CAAcW,IAAd,CAAmBc,UAAnB;;AACA,OAAKxB,SAAL,IAAkBwB,UAAU,CAAChB,MAA7B;;AAEA,OAAKS,QAAL,GAlBqD,CAoBrD;;;AACA,MAAI,KAAKhB,MAAL,IAAe,KAAKA,MAAL,CAAYO,MAAZ,KAAuB,CAA1C,EAA6C;AAC3C,SAAKN,OAAL,GAAe,IAAf;AACD;;AAED,SAAO,KAAKE,QAAL,IAAiB,CAAC,KAAKF,OAA9B;AACD,CA1BD;;AA4BAP,WAAW,CAACW,SAAZ,CAAsBqB,GAAtB,GAA4B,UAASN,IAAT,EAAeC,QAAf,EAAyB;AAEnD,MAAID,IAAJ,EAAU;AACR,SAAKD,KAAL,CAAWC,IAAX,EAAiBC,QAAjB;AACD;;AAED,OAAKlB,QAAL,GAAgB,KAAhB,CANmD,CAQnD;;AACA,MAAI,CAAC,KAAKL,QAAV,EAAoB;AAClB;AACD,GAXkD,CAanD;;;AACA,MAAI,KAAKA,QAAL,CAAcS,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,SAAKoB,IAAL;AACD,GAFD,MAGK;AACH,SAAK7B,QAAL,CAAcW,IAAd,CAAmB,IAAnB;;AACA,SAAKO,QAAL;AACD;AACF,CArBD;;AAuBAtB,WAAW,CAACW,SAAZ,CAAsBuB,WAAtB,GAAoClC,WAAW,CAACW,SAAZ,CAAsBqB,GAA1D;;AAEAhC,WAAW,CAACW,SAAZ,CAAsBsB,IAAtB,GAA6B,YAAW;AAEtC,MAAI,KAAK3B,MAAL,CAAYO,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,SAAKU,IAAL,CAAU,OAAV,EACE,IAAIK,KAAJ,CAAU,wDAAV,CADF;AAGD;;AAED,OAAKO,OAAL;AACD,CATD;;AAWAnC,WAAW,CAACW,SAAZ,CAAsBwB,OAAtB,GAAgC,YAAW;AAEzC,MAAI,CAAC,KAAK/B,QAAV,EAAoB;AAClB;AACD;;AAED,OAAKK,QAAL,GAAgB,KAAhB;AACA,OAAKH,MAAL,GAAc,IAAd;AACA,OAAKF,QAAL,GAAgB,IAAhB;AAEA,OAAKmB,IAAL,CAAU,OAAV;AACD,CAXD;;AAaAvB,WAAW,CAACW,SAAZ,CAAsByB,wBAAtB,GAAiD,UAASxB,IAAT,EAAe;AAC9D;AACA,OAAKN,MAAL,CAAY+B,KAAZ,GAF8D,CAEzC;AAErB;;;AACA,MAAIC,UAAU,GAAG,KAAKlC,QAAL,CAAc,CAAd,CAAjB,CAL8D,CAO9D;;AACA,MAAIkC,UAAU,CAACzB,MAAX,GAAoBD,IAAI,CAACC,MAA7B,EAAqC;AAEnC,SAAKR,SAAL,IAAkBO,IAAI,CAACC,MAAvB;AACA,SAAKT,QAAL,CAAc,CAAd,IAAmBkC,UAAU,CAACC,KAAX,CAAiB3B,IAAI,CAACC,MAAtB,CAAnB;AAEAD,IAAAA,IAAI,CAACO,IAAL,CAAUhB,IAAV,CAAe,IAAf,EAAqBmC,UAAU,CAACC,KAAX,CAAiB,CAAjB,EAAoB3B,IAAI,CAACC,MAAzB,CAArB;AAED,GAPD,MAQK;AACH;AACA,SAAKR,SAAL,IAAkBiC,UAAU,CAACzB,MAA7B;;AACA,SAAKT,QAAL,CAAciC,KAAd,GAHG,CAGoB;;;AAEvBzB,IAAAA,IAAI,CAACO,IAAL,CAAUhB,IAAV,CAAe,IAAf,EAAqBmC,UAArB;AACD;AACF,CAvBD;;AAyBAtC,WAAW,CAACW,SAAZ,CAAsB6B,YAAtB,GAAqC,UAAS5B,IAAT,EAAe;AAClD,OAAKN,MAAL,CAAY+B,KAAZ,GADkD,CAC7B;;;AAErB,MAAII,GAAG,GAAG,CAAV;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIhB,IAAI,GAAG,IAAII,MAAJ,CAAWlB,IAAI,CAACC,MAAhB,CAAX,CALkD,CAOlD;;AACA,SAAO4B,GAAG,GAAG7B,IAAI,CAACC,MAAlB,EAA0B;AAExB,QAAI8B,GAAG,GAAG,KAAKvC,QAAL,CAAcsC,KAAK,EAAnB,CAAV;AACA,QAAIE,GAAG,GAAG5B,IAAI,CAAC6B,GAAL,CAASF,GAAG,CAAC9B,MAAb,EAAqBD,IAAI,CAACC,MAAL,GAAc4B,GAAnC,CAAV;AAEAE,IAAAA,GAAG,CAACG,IAAJ,CAASpB,IAAT,EAAee,GAAf,EAAoB,CAApB,EAAuBG,GAAvB;AACAH,IAAAA,GAAG,IAAIG,GAAP,CANwB,CAQxB;;AACA,QAAIA,GAAG,KAAKD,GAAG,CAAC9B,MAAhB,EAAwB;AACtB,WAAKT,QAAL,CAAc,EAAEsC,KAAhB,IAAyBC,GAAG,CAACJ,KAAJ,CAAUK,GAAV,CAAzB;AACD;AACF,GApBiD,CAsBlD;;;AACA,MAAIF,KAAK,GAAG,CAAZ,EAAe;AACb,SAAKtC,QAAL,CAAc2C,MAAd,CAAqB,CAArB,EAAwBL,KAAxB;AACD;;AAED,OAAKrC,SAAL,IAAkBO,IAAI,CAACC,MAAvB;AAEAD,EAAAA,IAAI,CAACO,IAAL,CAAUhB,IAAV,CAAe,IAAf,EAAqBuB,IAArB;AACD,CA9BD;;AAgCA1B,WAAW,CAACW,SAAZ,CAAsBW,QAAtB,GAAiC,YAAW;AAE1C,MAAI;AACF;AACA,WAAO,KAAKjB,SAAL,GAAiB,CAAjB,IAAsB,KAAKC,MAA3B,IAAqC,KAAKA,MAAL,CAAYO,MAAZ,GAAqB,CAAjE,EAAoE;AAElE,UAAID,IAAI,GAAG,KAAKN,MAAL,CAAY,CAAZ,CAAX,CAFkE,CAIlE;;AACA,UAAIM,IAAI,CAACM,SAAT,EAAoB;AAClB,aAAKkB,wBAAL,CAA8BxB,IAA9B;AAED,OAHD,MAIK,IAAI,KAAKP,SAAL,IAAkBO,IAAI,CAACC,MAA3B,EAAmC;AACtC;AAEA,aAAK2B,YAAL,CAAkB5B,IAAlB;AACD,OAJI,MAKA;AACH;AACA;AACA;AACD;AACF;;AAED,QAAI,KAAKR,QAAL,IAAiB,KAAKA,QAAL,CAAcS,MAAd,GAAuB,CAAxC,IAA6C,KAAKT,QAAL,CAAc,CAAd,MAAqB,IAAtE,EAA4E;AAC1E,WAAK6B,IAAL;AACD;AACF,GA1BD,CA2BA,OAAOe,EAAP,EAAW;AACT,SAAKzB,IAAL,CAAU,OAAV,EAAmByB,EAAnB;AACD;AACF,CAhCD","sourcesContent":["'use strict';\n\n\nvar util = require('util');\nvar Stream = require('stream');\n\n\nvar ChunkStream = module.exports = function() {\n  Stream.call(this);\n\n  this._buffers = [];\n  this._buffered = 0;\n\n  this._reads = [];\n  this._paused = false;\n\n  this._encoding = 'utf8';\n  this.writable = true;\n};\nutil.inherits(ChunkStream, Stream);\n\n\nChunkStream.prototype.read = function(length, callback) {\n\n  this._reads.push({\n    length: Math.abs(length),  // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n\n  process.nextTick(function() {\n    this._process();\n\n    // its paused and there is not enought data then ask for more\n    if (this._paused && this._reads.length > 0) {\n      this._paused = false;\n\n      this.emit('drain');\n    }\n  }.bind(this));\n};\n\nChunkStream.prototype.write = function(data, encoding) {\n\n  if (!this.writable) {\n    this.emit('error', new Error('Stream not writable'));\n    return false;\n  }\n\n  var dataBuffer;\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  }\n  else {\n    dataBuffer = new Buffer(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n  this._buffered += dataBuffer.length;\n\n  this._process();\n\n  // ok if there are no more read requests\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function(data, encoding) {\n\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false;\n\n  // already destroyed\n  if (!this._buffers) {\n    return;\n  }\n\n  // enqueue or handle end\n  if (this._buffers.length === 0) {\n    this._end();\n  }\n  else {\n    this._buffers.push(null);\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function() {\n\n  if (this._reads.length > 0) {\n    this.emit('error',\n      new Error('There are some read requests waitng on finished stream')\n    );\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function() {\n\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n\n  this.emit('close');\n};\n\nChunkStream.prototype._processReadAllowingLess = function(read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n\n  // first we need to peek into first buffer\n  var smallerBuf = this._buffers[0];\n\n  // ok there is more data than we need\n  if (smallerBuf.length > read.length) {\n\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n\n    read.func.call(this, smallerBuf.slice(0, read.length));\n\n  }\n  else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n    this._buffers.shift(); // == smallerBuf\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function(read) {\n  this._reads.shift(); // == read\n\n  var pos = 0;\n  var count = 0;\n  var data = new Buffer(read.length);\n\n  // create buffer for all data\n  while (pos < read.length) {\n\n    var buf = this._buffers[count++];\n    var len = Math.min(buf.length, read.length - pos);\n\n    buf.copy(data, pos, 0, len);\n    pos += len;\n\n    // last buffer wasn't used all so just slice it and leave\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  }\n\n  // remove all used buffers\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function() {\n\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n\n      var read = this._reads[0];\n\n      // read any data (but no more than length)\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n\n      }\n      else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n\n        this._processRead(read);\n      }\n      else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {\n      this._end();\n    }\n  }\n  catch (ex) {\n    this.emit('error', ex);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}