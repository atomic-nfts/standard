{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey, SUPPORTED_KEY_TYPES } from './keys';\nimport { UnsupportedAlgorithmError, DecodeAsn1FailedError, AggregatedError } from '../../util/errors';\nexport var decomposePrivateKey = function decomposePrivateKey(privateKeyAsn1) {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  var decomposedKey;\n  var errors = {};\n\n  var _iterator = _createForOfIteratorHelper(SUPPORTED_KEY_TYPES.private),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var keyType = _step.value;\n\n      try {\n        decomposedKey = decomposeRawPrivateKey(keyType, privateKeyAsn1);\n        break;\n      } catch (err) {\n        if (err instanceof DecodeAsn1FailedError) {\n          errors[keyType] = err;\n        } else {\n          throw err;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(\"The input key is not one of: \".concat(SUPPORTED_KEY_TYPES.private.join(', ')), errors, {\n      invalidInputKey: true\n    });\n  }\n\n  var _decomposedKey = decomposedKey,\n      keyAlgorithm = _decomposedKey.keyAlgorithm,\n      keyData = _decomposedKey.keyData;\n  return {\n    format: 'raw-der',\n    encryptionAlgorithm: null,\n    keyAlgorithm: keyAlgorithm,\n    keyData: keyData\n  };\n};\nexport var composePrivateKey = function composePrivateKey(_ref) {\n  var keyAlgorithm = _ref.keyAlgorithm,\n      keyData = _ref.keyData,\n      encryptionAlgorithm = _ref.encryptionAlgorithm;\n\n  if (encryptionAlgorithm) {\n    throw new UnsupportedAlgorithmError('The RAW DER format does not support encryption');\n  }\n\n  return composeRawPrivateKey(keyAlgorithm, keyData);\n};\nexport var decomposePublicKey = function decomposePublicKey(publicKeyAsn1) {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  var decomposedKey;\n  var errors = {};\n\n  var _iterator2 = _createForOfIteratorHelper(SUPPORTED_KEY_TYPES.public),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var keyType = _step2.value;\n\n      try {\n        decomposedKey = decomposeRawPublicKey(keyType, publicKeyAsn1);\n        break;\n      } catch (err) {\n        /* istanbul ignore else */\n        if (err instanceof DecodeAsn1FailedError) {\n          errors[keyType] = err;\n        } else {\n          throw err;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(\"The input key is not one of: \".concat(SUPPORTED_KEY_TYPES.public.join(', ')), errors, {\n      invalidInputKey: true\n    });\n  }\n\n  var _decomposedKey2 = decomposedKey,\n      keyAlgorithm = _decomposedKey2.keyAlgorithm,\n      keyData = _decomposedKey2.keyData;\n  return {\n    format: 'raw-der',\n    keyAlgorithm: keyAlgorithm,\n    keyData: keyData\n  };\n};\nexport var composePublicKey = function composePublicKey(_ref2) {\n  var keyAlgorithm = _ref2.keyAlgorithm,\n      keyData = _ref2.keyData;\n  return composeRawPublicKey(keyAlgorithm, keyData);\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/formats/raw/raw-der.js"],"names":["decomposeRawPrivateKey","composeRawPrivateKey","decomposeRawPublicKey","composeRawPublicKey","SUPPORTED_KEY_TYPES","UnsupportedAlgorithmError","DecodeAsn1FailedError","AggregatedError","decomposePrivateKey","privateKeyAsn1","decomposedKey","errors","private","keyType","err","join","invalidInputKey","keyAlgorithm","keyData","format","encryptionAlgorithm","composePrivateKey","decomposePublicKey","publicKeyAsn1","public","composePublicKey"],"mappings":"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","sourcesContent":["import { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey, SUPPORTED_KEY_TYPES } from './keys';\nimport { UnsupportedAlgorithmError, DecodeAsn1FailedError, AggregatedError } from '../../util/errors';\nexport const decomposePrivateKey = privateKeyAsn1 => {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  let decomposedKey;\n  const errors = {};\n\n  for (const keyType of SUPPORTED_KEY_TYPES.private) {\n    try {\n      decomposedKey = decomposeRawPrivateKey(keyType, privateKeyAsn1);\n      break;\n    } catch (err) {\n      if (err instanceof DecodeAsn1FailedError) {\n        errors[keyType] = err;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.private.join(', ')}`, errors, {\n      invalidInputKey: true\n    });\n  }\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposedKey;\n  return {\n    format: 'raw-der',\n    encryptionAlgorithm: null,\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}) => {\n  if (encryptionAlgorithm) {\n    throw new UnsupportedAlgorithmError('The RAW DER format does not support encryption');\n  }\n\n  return composeRawPrivateKey(keyAlgorithm, keyData);\n};\nexport const decomposePublicKey = publicKeyAsn1 => {\n  // Iterate over all supported key types, until one succeeds\n  // Construct an errors object along the way with all the failed decode attempts\n  let decomposedKey;\n  const errors = {};\n\n  for (const keyType of SUPPORTED_KEY_TYPES.public) {\n    try {\n      decomposedKey = decomposeRawPublicKey(keyType, publicKeyAsn1);\n      break;\n    } catch (err) {\n      /* istanbul ignore else */\n      if (err instanceof DecodeAsn1FailedError) {\n        errors[keyType] = err;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  if (!decomposedKey) {\n    throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.public.join(', ')}`, errors, {\n      invalidInputKey: true\n    });\n  }\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposedKey;\n  return {\n    format: 'raw-der',\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePublicKey = ({\n  keyAlgorithm,\n  keyData\n}) => composeRawPublicKey(keyAlgorithm, keyData);"]},"metadata":{},"sourceType":"module"}