{"ast":null,"code":"/*! multi-integer-range (c) 2015 Soichiro Miki */\n\"use strict\";\n\nvar MultiRange = function () {\n  /**\n   * Creates a new MultiRange object.\n   */\n  function MultiRange(data) {\n    function isArray(x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    }\n\n    this.ranges = [];\n\n    if (typeof data === 'string') {\n      this.parseString(data);\n    } else if (typeof data === 'number') {\n      this.appendRange(data, data);\n    } else if (data instanceof MultiRange) {\n      this.ranges = data.getRanges();\n    } else if (isArray(data)) {\n      for (var _i = 0, _a = data; _i < _a.length; _i++) {\n        var item = _a[_i];\n\n        if (isArray(item)) {\n          if (item.length === 2) {\n            this.appendRange(item[0], item[1]);\n          } else {\n            throw new TypeError('Invalid array initializer');\n          }\n        } else if (typeof item === 'number') {\n          this.append(item);\n        } else {\n          throw new TypeError('Invalid array initialzer');\n        }\n      }\n    } else if (data !== undefined) {\n      throw new TypeError('Invalid input');\n    }\n  }\n  /**\n   * Parses the initialize string and build the range data.\n   * Override this if you need to customize the parsing strategy.\n   */\n\n\n  MultiRange.prototype.parseString = function (data) {\n    function toInt(str) {\n      var m = str.match(/^\\(?(\\-?\\d+)/);\n      return parseInt(m[1], 10);\n    }\n\n    var s = data.replace(/\\s/g, '');\n    if (!s.length) return;\n    var match;\n\n    for (var _i = 0, _a = s.split(','); _i < _a.length; _i++) {\n      var r = _a[_i];\n\n      if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))$/)) {\n        var val = toInt(match[1]);\n        this.appendRange(val, val);\n      } else if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))?\\-(\\d+|\\(\\-?\\d+\\))?$/)) {\n        var min = match[1] === undefined ? -Infinity : toInt(match[1]);\n        var max = match[2] === undefined ? +Infinity : toInt(match[2]);\n        this.appendRange(min, max);\n      } else {\n        throw new SyntaxError('Invalid input');\n      }\n    }\n\n    ;\n  };\n  /**\n   * Clones this instance.\n   */\n\n\n  MultiRange.prototype.clone = function () {\n    return new MultiRange(this);\n  };\n  /**\n   * Appends to this instance.\n   * @parasm value The data to append.\n   */\n\n\n  MultiRange.prototype.append = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var r = _a[_i];\n        this.appendRange(r[0], r[1]);\n      }\n\n      return this;\n    } else {\n      return this.append(new MultiRange(value));\n    }\n  };\n  /**\n   * Appends a specified range of integers to this isntance.\n   * @param min The minimum value of the range to append.\n   * @param max The minimum value of the range to append.\n   */\n\n\n  MultiRange.prototype.appendRange = function (min, max) {\n    var newRange = [min, max];\n\n    if (newRange[0] > newRange[1]) {\n      newRange = [newRange[1], newRange[0]];\n    }\n\n    if (newRange[0] === Infinity && newRange[1] === Infinity || newRange[0] === -Infinity && newRange[1] === -Infinity) {\n      throw new RangeError('Infinity can be used only within an unbounded range segment');\n    }\n\n    var overlap = this.findOverlap(newRange);\n    this.ranges.splice(overlap.lo, overlap.count, overlap.union);\n    return this;\n  };\n  /**\n   * Subtracts from this instance.\n   * @param value The data to subtract.\n   */\n\n\n  MultiRange.prototype.subtract = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var r = _a[_i];\n        this.subtractRange(r[0], r[1]);\n      }\n\n      return this;\n    } else {\n      return this.subtract(new MultiRange(value));\n    }\n  };\n  /**\n   * Subtracts a specified range of integers from this instance.\n   * @param min The minimum value of the range to subtract.\n   * @param max The minimum value of the range to subtract.\n   */\n\n\n  MultiRange.prototype.subtractRange = function (min, max) {\n    var newRange = [min, max];\n\n    if (newRange[0] > newRange[1]) {\n      newRange = [newRange[1], newRange[0]];\n    }\n\n    var overlap = this.findOverlap(newRange);\n\n    if (overlap.count > 0) {\n      var remain = [];\n\n      if (this.ranges[overlap.lo][0] < newRange[0]) {\n        remain.push([this.ranges[overlap.lo][0], newRange[0] - 1]);\n      }\n\n      if (newRange[1] < this.ranges[overlap.lo + overlap.count - 1][1]) {\n        remain.push([newRange[1] + 1, this.ranges[overlap.lo + overlap.count - 1][1]]);\n      }\n\n      this.ranges.splice.apply(this.ranges, [overlap.lo, overlap.count].concat(remain));\n    }\n\n    return this;\n  };\n  /**\n   * Remove integers which are not included in the given ranges (aka intersection).\n   * @param value The data to calculate the intersetion.\n   */\n\n\n  MultiRange.prototype.intersect = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      var result = [];\n      var jstart = 0; // used for optimization\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        var r1 = this.ranges[i];\n\n        for (var j = jstart; j < value.ranges.length; j++) {\n          var r2 = value.ranges[j];\n\n          if (r1[0] <= r2[1] && r1[1] >= r2[0]) {\n            jstart = j;\n            var min = Math.max(r1[0], r2[0]);\n            var max = Math.min(r1[1], r2[1]);\n            result.push([min, max]);\n          } else if (r1[1] < r2[0]) {\n            break;\n          }\n        }\n      }\n\n      this.ranges = result;\n      return this;\n    } else {\n      return this.intersect(new MultiRange(value));\n    }\n  };\n  /**\n   * Determines how the given range overlaps or touches the existing ranges.\n   * This is a helper method that calculates how an append/subtract operation\n   * affects the existing range members.\n   * @param target The range array to test.\n   * @return An object containing information about how the given range\n   * overlaps or touches this instance.\n   */\n\n\n  MultiRange.prototype.findOverlap = function (target) {\n    //   a        b  c     d         e  f       g h i   j k  l       m\n    //--------------------------------------------------------------------\n    //   |----(0)----|     |---(1)---|  |---(2)---|          |--(3)--|\n    //            |------------(A)--------------|\n    //                                            |-(B)-|\n    //                                              |-(C)-|\n    //\n    // (0)-(3) represent the existing ranges (this.ranges),\n    // and (A)-(C) are the ranges being passed to this function.\n    //\n    // A pseudocode findOverlap(A) returns { lo: 0, count: 3, union: <a-h> },\n    // meaning (A) overlaps the 3 existing ranges from index 0.\n    //\n    // findOverlap(B) returns { lo: 2, count: 1, union: <f-j> },\n    // meaning (B) \"touches\" one range element, (2).\n    //\n    // findOverlap(C) returns { lo: 3, count: 0, union: <i-k> }\n    // meaning (C) is between (2) and (3) but overlaps/touches neither of them.\n    for (var hi = this.ranges.length - 1; hi >= 0; hi--) {\n      var r = this.ranges[hi];\n      var union = void 0;\n\n      if (union = this.calcUnion(r, target)) {\n        var count = 1;\n        var tmp = void 0;\n\n        while (hi - count >= 0 && (tmp = this.calcUnion(union, this.ranges[hi - count]))) {\n          union = tmp;\n          count++;\n        } // The given target touches or overlaps one or more of the existing ranges\n\n\n        return {\n          lo: hi + 1 - count,\n          count: count,\n          union: union\n        };\n      } else if (r[1] < target[0]) {\n        // The given target does not touch nor overlap the existing ranges\n        return {\n          lo: hi + 1,\n          count: 0,\n          union: target\n        };\n      }\n    } // The given target is smaller than the smallest existing range\n\n\n    return {\n      lo: 0,\n      count: 0,\n      union: target\n    };\n  };\n  /**\n   * Calculates the union of two specified ranges.\n   * @param a Range A\n   * @param b Range B\n   * @return Union of a and b. Null if a and b do not touch nor intersect.\n   */\n\n\n  MultiRange.prototype.calcUnion = function (a, b) {\n    if (a[1] + 1 < b[0] || a[0] - 1 > b[1]) {\n      return null; // cannot make union\n    }\n\n    return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];\n  };\n  /**\n   * Exports the whole range data as an array of arrays.\n   */\n\n\n  MultiRange.prototype.getRanges = function () {\n    var result = [];\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      result.push([r[0], r[1]]);\n    }\n\n    return result;\n  };\n  /**\n   * Checks if the instance contains the specified value.\n   * @param value Value to be checked\n   * @return True if the specified value is included in the instance.\n   */\n\n\n  MultiRange.prototype.has = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      var s = 0;\n      var len = this.ranges.length;\n\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var tr = _a[_i];\n        var i = void 0;\n\n        for (i = s; i < len; i++) {\n          var my = this.ranges[i];\n          if (tr[0] >= my[0] && tr[1] <= my[1] && tr[1] >= my[0] && tr[1] <= my[1]) break;\n        }\n\n        if (i === len) return false;\n      }\n\n      return true;\n    } else {\n      return this.has(new MultiRange(value));\n    }\n  };\n  /**\n   * Checks if the instance contains the range specified by the two parameters.\n   * @param min The minimum value of the range to subtract.\n   * @param max The minimum value of the range to subtract.\n   * @return True if the specified value is included in the instance.\n   */\n\n\n  MultiRange.prototype.hasRange = function (min, max) {\n    return this.has(new MultiRange([[min, max]]));\n  };\n  /**\n   * Returns the number of range segments.\n   * For example, the segmentLength of `2-5,7,9-11' is 3.\n   * Returns 0 for an empty instance.\n   * @return The number of segments.\n   */\n\n\n  MultiRange.prototype.segmentLength = function () {\n    return this.ranges.length;\n  };\n  /**\n   * Calculates how many numbers are effectively included in this instance.\n   * (i.e. '1-10,51-60,90' returns 21)\n   * @return The number of integer values in this instance.\n   *    Returns `Infinity` for unbounded ranges.\n   */\n\n\n  MultiRange.prototype.length = function () {\n    if (this.isUnbounded()) return Infinity;\n    var result = 0;\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      result += r[1] - r[0] + 1;\n    }\n\n    return result;\n  };\n  /**\n   * Checks if two instances of MultiRange are identical.\n   * @param cmp The data to compare.\n   * @return True if cmp is exactly the same as this instance.\n   */\n\n\n  MultiRange.prototype.equals = function (cmp) {\n    if (cmp === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (cmp instanceof MultiRange) {\n      if (cmp === this) return true;\n      if (this.ranges.length !== cmp.ranges.length) return false;\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (this.ranges[i][0] !== cmp.ranges[i][0] || this.ranges[i][1] !== cmp.ranges[i][1]) return false;\n      }\n\n      return true;\n    } else {\n      return this.equals(new MultiRange(cmp));\n    }\n  };\n  /**\n   * Checks if the current instance is unbounded (i.e., infinite).\n   */\n\n\n  MultiRange.prototype.isUnbounded = function () {\n    return this.ranges.length > 0 && (this.ranges[0][0] === -Infinity || this.ranges[this.ranges.length - 1][1] === Infinity);\n  };\n  /**\n   * Returns the minimum number contained in this insntance. Can be -Infinity or undefined.\n   */\n\n\n  MultiRange.prototype.min = function () {\n    if (this.ranges.length === 0) return undefined;\n    return this.ranges[0][0];\n  };\n  /**\n   * Returns the maximum number contained in this insntance. Can be +Infinity or undefined.\n   */\n\n\n  MultiRange.prototype.max = function () {\n    if (this.ranges.length === 0) return undefined;\n    return this.ranges[this.ranges.length - 1][1];\n  };\n  /**\n   * Removes the smallest integer from this instance and returns that integer.\n   */\n\n\n  MultiRange.prototype.shift = function () {\n    var min = this.min();\n    if (min === -Infinity) throw new RangeError('shift() was invoked on an unbounded MultiRange which contains -Infinity');\n    if (min !== undefined) this.subtract(min);\n    return min;\n  };\n  /**\n   * Removes the largest integer from this instance and returns that integer.\n   */\n\n\n  MultiRange.prototype.pop = function () {\n    var max = this.max();\n    if (max === Infinity) throw new RangeError('pop() was invoked on an unbounded MultiRange which contains +Infinity');\n    if (max !== undefined) this.subtract(max);\n    return max;\n  };\n  /**\n   * Returns the string respresentation of this MultiRange.\n   */\n\n\n  MultiRange.prototype.toString = function () {\n    function wrap(i) {\n      return i >= 0 ? String(i) : \"(\" + i + \")\";\n    }\n\n    var ranges = [];\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n\n      if (r[0] === -Infinity) {\n        if (r[1] === Infinity) {\n          ranges.push('-');\n        } else {\n          ranges.push(\"-\" + wrap(r[1]));\n        }\n      } else if (r[1] === Infinity) {\n        ranges.push(wrap(r[0]) + \"-\");\n      } else if (r[0] == r[1]) {\n        ranges.push(wrap(r[0]));\n      } else {\n        ranges.push(wrap(r[0]) + \"-\" + wrap(r[1]));\n      }\n    }\n\n    return ranges.join(',');\n  };\n  /**\n   * Builds an array of integer which holds all elements in this MultiRange.\n   * Note that this may be slow and memory-consuming for large ranges such as '1-10000'.\n   */\n\n\n  MultiRange.prototype.toArray = function () {\n    if (this.isUnbounded()) {\n      throw new RangeError('You cannot build an array from an unbounded range');\n    }\n\n    var result = new Array(this.length());\n    var idx = 0;\n\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n\n      for (var n = r[0]; n <= r[1]; n++) {\n        result[idx++] = n;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Returns ES6-compatible iterator.\n   */\n\n\n  MultiRange.prototype.getIterator = function () {\n    var _this = this;\n\n    if (this.isUnbounded()) {\n      throw new RangeError('Unbounded ranges cannot be iterated over');\n    }\n\n    var i = 0,\n        curRange = this.ranges[i],\n        j = curRange ? curRange[0] : undefined;\n    return {\n      next: function () {\n        if (!curRange) return {\n          done: true\n        };\n        var ret = j;\n\n        if (++j > curRange[1]) {\n          curRange = _this.ranges[++i];\n          j = curRange ? curRange[0] : undefined;\n        }\n\n        return {\n          value: ret\n        };\n      }\n    };\n  };\n\n  return MultiRange;\n}();\n\nexports.MultiRange = MultiRange; // Set ES6 iterator, if Symbol.iterator is defined\n\n/* istanbul ignore else */\n\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  MultiRange.prototype[Symbol.iterator] = MultiRange.prototype.getIterator;\n} // A shorthand function to get a new MultiRange instance\n\n\nfunction multirange(data) {\n  return new MultiRange(data);\n}\n\nexports.multirange = multirange;","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/multi-integer-range/lib/multi-integer-range.js"],"names":["MultiRange","data","isArray","x","Object","prototype","toString","call","ranges","parseString","appendRange","getRanges","_i","_a","length","item","TypeError","append","undefined","toInt","str","m","match","parseInt","s","replace","split","r","val","min","Infinity","max","SyntaxError","clone","value","newRange","RangeError","overlap","findOverlap","splice","lo","count","union","subtract","subtractRange","remain","push","apply","concat","intersect","result","jstart","i","r1","j","r2","Math","target","hi","calcUnion","tmp","a","b","has","len","tr","my","hasRange","segmentLength","isUnbounded","equals","cmp","shift","pop","wrap","String","join","toArray","Array","idx","n","getIterator","_this","curRange","next","done","ret","exports","Symbol","iterator","multirange"],"mappings":"AAAA;AACA;;AACA,IAAIA,UAAU,GAAI,YAAY;AAC1B;AACJ;AACA;AACI,WAASA,UAAT,CAAoBC,IAApB,EAA0B;AACtB,aAASC,OAAT,CAAiBC,CAAjB,EAAoB;AAChB,aAAOC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BJ,CAA/B,MAAsC,gBAA7C;AACH;;AACD,SAAKK,MAAL,GAAc,EAAd;;AACA,QAAI,OAAOP,IAAP,KAAgB,QAApB,EAA8B;AAC1B,WAAKQ,WAAL,CAAiBR,IAAjB;AACH,KAFD,MAGK,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC/B,WAAKS,WAAL,CAAiBT,IAAjB,EAAuBA,IAAvB;AACH,KAFI,MAGA,IAAIA,IAAI,YAAYD,UAApB,EAAgC;AACjC,WAAKQ,MAAL,GAAcP,IAAI,CAACU,SAAL,EAAd;AACH,KAFI,MAGA,IAAIT,OAAO,CAACD,IAAD,CAAX,EAAmB;AACpB,WAAK,IAAIW,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGZ,IAAtB,EAA4BW,EAAE,GAAGC,EAAE,CAACC,MAApC,EAA4CF,EAAE,EAA9C,EAAkD;AAC9C,YAAIG,IAAI,GAAGF,EAAE,CAACD,EAAD,CAAb;;AACA,YAAIV,OAAO,CAACa,IAAD,CAAX,EAAmB;AACf,cAAIA,IAAI,CAACD,MAAL,KAAgB,CAApB,EAAuB;AACnB,iBAAKJ,WAAL,CAAiBK,IAAI,CAAC,CAAD,CAArB,EAA0BA,IAAI,CAAC,CAAD,CAA9B;AACH,WAFD,MAGK;AACD,kBAAM,IAAIC,SAAJ,CAAc,2BAAd,CAAN;AACH;AACJ,SAPD,MAQK,IAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC/B,eAAKE,MAAL,CAAYF,IAAZ;AACH,SAFI,MAGA;AACD,gBAAM,IAAIC,SAAJ,CAAc,0BAAd,CAAN;AACH;AACJ;AACJ,KAlBI,MAmBA,IAAIf,IAAI,KAAKiB,SAAb,EAAwB;AACzB,YAAM,IAAIF,SAAJ,CAAc,eAAd,CAAN;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIhB,EAAAA,UAAU,CAACK,SAAX,CAAqBI,WAArB,GAAmC,UAAUR,IAAV,EAAgB;AAC/C,aAASkB,KAAT,CAAeC,GAAf,EAAoB;AAChB,UAAIC,CAAC,GAAGD,GAAG,CAACE,KAAJ,CAAU,cAAV,CAAR;AACA,aAAOC,QAAQ,CAACF,CAAC,CAAC,CAAD,CAAF,EAAO,EAAP,CAAf;AACH;;AACD,QAAIG,CAAC,GAAGvB,IAAI,CAACwB,OAAL,CAAa,KAAb,EAAoB,EAApB,CAAR;AACA,QAAI,CAACD,CAAC,CAACV,MAAP,EACI;AACJ,QAAIQ,KAAJ;;AACA,SAAK,IAAIV,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGW,CAAC,CAACE,KAAF,CAAQ,GAAR,CAAtB,EAAoCd,EAAE,GAAGC,EAAE,CAACC,MAA5C,EAAoDF,EAAE,EAAtD,EAA0D;AACtD,UAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;;AACA,UAAIU,KAAK,GAAGK,CAAC,CAACL,KAAF,CAAQ,oBAAR,CAAZ,EAA2C;AACvC,YAAIM,GAAG,GAAGT,KAAK,CAACG,KAAK,CAAC,CAAD,CAAN,CAAf;AACA,aAAKZ,WAAL,CAAiBkB,GAAjB,EAAsBA,GAAtB;AACH,OAHD,MAIK,IAAIN,KAAK,GAAGK,CAAC,CAACL,KAAF,CAAQ,wCAAR,CAAZ,EAA+D;AAChE,YAAIO,GAAG,GAAGP,KAAK,CAAC,CAAD,CAAL,KAAaJ,SAAb,GAAyB,CAACY,QAA1B,GAAqCX,KAAK,CAACG,KAAK,CAAC,CAAD,CAAN,CAApD;AACA,YAAIS,GAAG,GAAGT,KAAK,CAAC,CAAD,CAAL,KAAaJ,SAAb,GAAyB,CAACY,QAA1B,GAAqCX,KAAK,CAACG,KAAK,CAAC,CAAD,CAAN,CAApD;AACA,aAAKZ,WAAL,CAAiBmB,GAAjB,EAAsBE,GAAtB;AACH,OAJI,MAKA;AACD,cAAM,IAAIC,WAAJ,CAAgB,eAAhB,CAAN;AACH;AACJ;;AACD;AACH,GAzBD;AA0BA;AACJ;AACA;;;AACIhC,EAAAA,UAAU,CAACK,SAAX,CAAqB4B,KAArB,GAA6B,YAAY;AACrC,WAAO,IAAIjC,UAAJ,CAAe,IAAf,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;;;AACIA,EAAAA,UAAU,CAACK,SAAX,CAAqBY,MAArB,GAA8B,UAAUiB,KAAV,EAAiB;AAC3C,QAAIA,KAAK,KAAKhB,SAAd,EAAyB;AACrB,YAAM,IAAIF,SAAJ,CAAc,eAAd,CAAN;AACH,KAFD,MAGK,IAAIkB,KAAK,YAAYlC,UAArB,EAAiC;AAClC,WAAK,IAAIY,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGqB,KAAK,CAAC1B,MAA5B,EAAoCI,EAAE,GAAGC,EAAE,CAACC,MAA5C,EAAoDF,EAAE,EAAtD,EAA0D;AACtD,YAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;AACA,aAAKF,WAAL,CAAiBiB,CAAC,CAAC,CAAD,CAAlB,EAAuBA,CAAC,CAAC,CAAD,CAAxB;AACH;;AACD,aAAO,IAAP;AACH,KANI,MAOA;AACD,aAAO,KAAKV,MAAL,CAAY,IAAIjB,UAAJ,CAAekC,KAAf,CAAZ,CAAP;AACH;AACJ,GAdD;AAeA;AACJ;AACA;AACA;AACA;;;AACIlC,EAAAA,UAAU,CAACK,SAAX,CAAqBK,WAArB,GAAmC,UAAUmB,GAAV,EAAeE,GAAf,EAAoB;AACnD,QAAII,QAAQ,GAAG,CAACN,GAAD,EAAME,GAAN,CAAf;;AACA,QAAII,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAA1B,EAA+B;AAC3BA,MAAAA,QAAQ,GAAG,CAACA,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAX;AACH;;AACD,QAAIA,QAAQ,CAAC,CAAD,CAAR,KAAgBL,QAAhB,IAA4BK,QAAQ,CAAC,CAAD,CAAR,KAAgBL,QAA5C,IACAK,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAACL,QAAjB,IAA6BK,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAACL,QADlD,EAC4D;AACxD,YAAM,IAAIM,UAAJ,CAAe,6DAAf,CAAN;AACH;;AACD,QAAIC,OAAO,GAAG,KAAKC,WAAL,CAAiBH,QAAjB,CAAd;AACA,SAAK3B,MAAL,CAAY+B,MAAZ,CAAmBF,OAAO,CAACG,EAA3B,EAA+BH,OAAO,CAACI,KAAvC,EAA8CJ,OAAO,CAACK,KAAtD;AACA,WAAO,IAAP;AACH,GAZD;AAaA;AACJ;AACA;AACA;;;AACI1C,EAAAA,UAAU,CAACK,SAAX,CAAqBsC,QAArB,GAAgC,UAAUT,KAAV,EAAiB;AAC7C,QAAIA,KAAK,KAAKhB,SAAd,EAAyB;AACrB,YAAM,IAAIF,SAAJ,CAAc,eAAd,CAAN;AACH,KAFD,MAGK,IAAIkB,KAAK,YAAYlC,UAArB,EAAiC;AAClC,WAAK,IAAIY,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGqB,KAAK,CAAC1B,MAA5B,EAAoCI,EAAE,GAAGC,EAAE,CAACC,MAA5C,EAAoDF,EAAE,EAAtD,EAA0D;AACtD,YAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;AACA,aAAKgC,aAAL,CAAmBjB,CAAC,CAAC,CAAD,CAApB,EAAyBA,CAAC,CAAC,CAAD,CAA1B;AACH;;AACD,aAAO,IAAP;AACH,KANI,MAOA;AACD,aAAO,KAAKgB,QAAL,CAAc,IAAI3C,UAAJ,CAAekC,KAAf,CAAd,CAAP;AACH;AACJ,GAdD;AAeA;AACJ;AACA;AACA;AACA;;;AACIlC,EAAAA,UAAU,CAACK,SAAX,CAAqBuC,aAArB,GAAqC,UAAUf,GAAV,EAAeE,GAAf,EAAoB;AACrD,QAAII,QAAQ,GAAG,CAACN,GAAD,EAAME,GAAN,CAAf;;AACA,QAAII,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAA1B,EAA+B;AAC3BA,MAAAA,QAAQ,GAAG,CAACA,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAtB,CAAX;AACH;;AACD,QAAIE,OAAO,GAAG,KAAKC,WAAL,CAAiBH,QAAjB,CAAd;;AACA,QAAIE,OAAO,CAACI,KAAR,GAAgB,CAApB,EAAuB;AACnB,UAAII,MAAM,GAAG,EAAb;;AACA,UAAI,KAAKrC,MAAL,CAAY6B,OAAO,CAACG,EAApB,EAAwB,CAAxB,IAA6BL,QAAQ,CAAC,CAAD,CAAzC,EAA8C;AAC1CU,QAAAA,MAAM,CAACC,IAAP,CAAY,CAAC,KAAKtC,MAAL,CAAY6B,OAAO,CAACG,EAApB,EAAwB,CAAxB,CAAD,EAA6BL,QAAQ,CAAC,CAAD,CAAR,GAAc,CAA3C,CAAZ;AACH;;AACD,UAAIA,QAAQ,CAAC,CAAD,CAAR,GAAc,KAAK3B,MAAL,CAAY6B,OAAO,CAACG,EAAR,GAAaH,OAAO,CAACI,KAArB,GAA6B,CAAzC,EAA4C,CAA5C,CAAlB,EAAkE;AAC9DI,QAAAA,MAAM,CAACC,IAAP,CAAY,CAACX,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAf,EAAkB,KAAK3B,MAAL,CAAY6B,OAAO,CAACG,EAAR,GAAaH,OAAO,CAACI,KAArB,GAA6B,CAAzC,EAA4C,CAA5C,CAAlB,CAAZ;AACH;;AACD,WAAKjC,MAAL,CAAY+B,MAAZ,CAAmBQ,KAAnB,CAAyB,KAAKvC,MAA9B,EAAsC,CAAC6B,OAAO,CAACG,EAAT,EAAaH,OAAO,CAACI,KAArB,EAA4BO,MAA5B,CAAmCH,MAAnC,CAAtC;AACH;;AACD,WAAO,IAAP;AACH,GAjBD;AAkBA;AACJ;AACA;AACA;;;AACI7C,EAAAA,UAAU,CAACK,SAAX,CAAqB4C,SAArB,GAAiC,UAAUf,KAAV,EAAiB;AAC9C,QAAIA,KAAK,KAAKhB,SAAd,EAAyB;AACrB,YAAM,IAAIF,SAAJ,CAAc,eAAd,CAAN;AACH,KAFD,MAGK,IAAIkB,KAAK,YAAYlC,UAArB,EAAiC;AAClC,UAAIkD,MAAM,GAAG,EAAb;AACA,UAAIC,MAAM,GAAG,CAAb,CAFkC,CAElB;;AAChB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,MAAL,CAAYM,MAAhC,EAAwCsC,CAAC,EAAzC,EAA6C;AACzC,YAAIC,EAAE,GAAG,KAAK7C,MAAL,CAAY4C,CAAZ,CAAT;;AACA,aAAK,IAAIE,CAAC,GAAGH,MAAb,EAAqBG,CAAC,GAAGpB,KAAK,CAAC1B,MAAN,CAAaM,MAAtC,EAA8CwC,CAAC,EAA/C,EAAmD;AAC/C,cAAIC,EAAE,GAAGrB,KAAK,CAAC1B,MAAN,CAAa8C,CAAb,CAAT;;AACA,cAAID,EAAE,CAAC,CAAD,CAAF,IAASE,EAAE,CAAC,CAAD,CAAX,IAAkBF,EAAE,CAAC,CAAD,CAAF,IAASE,EAAE,CAAC,CAAD,CAAjC,EAAsC;AAClCJ,YAAAA,MAAM,GAAGG,CAAT;AACA,gBAAIzB,GAAG,GAAG2B,IAAI,CAACzB,GAAL,CAASsB,EAAE,CAAC,CAAD,CAAX,EAAgBE,EAAE,CAAC,CAAD,CAAlB,CAAV;AACA,gBAAIxB,GAAG,GAAGyB,IAAI,CAAC3B,GAAL,CAASwB,EAAE,CAAC,CAAD,CAAX,EAAgBE,EAAE,CAAC,CAAD,CAAlB,CAAV;AACAL,YAAAA,MAAM,CAACJ,IAAP,CAAY,CAACjB,GAAD,EAAME,GAAN,CAAZ;AACH,WALD,MAMK,IAAIsB,EAAE,CAAC,CAAD,CAAF,GAAQE,EAAE,CAAC,CAAD,CAAd,EAAmB;AACpB;AACH;AACJ;AACJ;;AACD,WAAK/C,MAAL,GAAc0C,MAAd;AACA,aAAO,IAAP;AACH,KApBI,MAqBA;AACD,aAAO,KAAKD,SAAL,CAAe,IAAIjD,UAAJ,CAAekC,KAAf,CAAf,CAAP;AACH;AACJ,GA5BD;AA6BA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIlC,EAAAA,UAAU,CAACK,SAAX,CAAqBiC,WAArB,GAAmC,UAAUmB,MAAV,EAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAK,IAAIC,EAAE,GAAG,KAAKlD,MAAL,CAAYM,MAAZ,GAAqB,CAAnC,EAAsC4C,EAAE,IAAI,CAA5C,EAA+CA,EAAE,EAAjD,EAAqD;AACjD,UAAI/B,CAAC,GAAG,KAAKnB,MAAL,CAAYkD,EAAZ,CAAR;AACA,UAAIhB,KAAK,GAAG,KAAK,CAAjB;;AACA,UAAIA,KAAK,GAAG,KAAKiB,SAAL,CAAehC,CAAf,EAAkB8B,MAAlB,CAAZ,EAAuC;AACnC,YAAIhB,KAAK,GAAG,CAAZ;AACA,YAAImB,GAAG,GAAG,KAAK,CAAf;;AACA,eAAQF,EAAE,GAAGjB,KAAL,IAAc,CAAf,KAAsBmB,GAAG,GAAG,KAAKD,SAAL,CAAejB,KAAf,EAAsB,KAAKlC,MAAL,CAAYkD,EAAE,GAAGjB,KAAjB,CAAtB,CAA5B,CAAP,EAAoF;AAChFC,UAAAA,KAAK,GAAGkB,GAAR;AACAnB,UAAAA,KAAK;AACR,SANkC,CAOnC;;;AACA,eAAO;AAAED,UAAAA,EAAE,EAAEkB,EAAE,GAAG,CAAL,GAASjB,KAAf;AAAsBA,UAAAA,KAAK,EAAEA,KAA7B;AAAoCC,UAAAA,KAAK,EAAEA;AAA3C,SAAP;AACH,OATD,MAUK,IAAIf,CAAC,CAAC,CAAD,CAAD,GAAO8B,MAAM,CAAC,CAAD,CAAjB,EAAsB;AACvB;AACA,eAAO;AAAEjB,UAAAA,EAAE,EAAEkB,EAAE,GAAG,CAAX;AAAcjB,UAAAA,KAAK,EAAE,CAArB;AAAwBC,UAAAA,KAAK,EAAEe;AAA/B,SAAP;AACH;AACJ,KApCgD,CAqCjD;;;AACA,WAAO;AAAEjB,MAAAA,EAAE,EAAE,CAAN;AAASC,MAAAA,KAAK,EAAE,CAAhB;AAAmBC,MAAAA,KAAK,EAAEe;AAA1B,KAAP;AACH,GAvCD;AAwCA;AACJ;AACA;AACA;AACA;AACA;;;AACIzD,EAAAA,UAAU,CAACK,SAAX,CAAqBsD,SAArB,GAAiC,UAAUE,CAAV,EAAaC,CAAb,EAAgB;AAC7C,QAAID,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP,GAAWC,CAAC,CAAC,CAAD,CAAZ,IAAmBD,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP,GAAWC,CAAC,CAAC,CAAD,CAAnC,EAAwC;AACpC,aAAO,IAAP,CADoC,CACvB;AAChB;;AACD,WAAO,CAACN,IAAI,CAAC3B,GAAL,CAASgC,CAAC,CAAC,CAAD,CAAV,EAAeC,CAAC,CAAC,CAAD,CAAhB,CAAD,EAAuBN,IAAI,CAACzB,GAAL,CAAS8B,CAAC,CAAC,CAAD,CAAV,EAAeC,CAAC,CAAC,CAAD,CAAhB,CAAvB,CAAP;AACH,GALD;AAMA;AACJ;AACA;;;AACI9D,EAAAA,UAAU,CAACK,SAAX,CAAqBM,SAArB,GAAiC,YAAY;AACzC,QAAIuC,MAAM,GAAG,EAAb;;AACA,SAAK,IAAItC,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKL,MAA3B,EAAmCI,EAAE,GAAGC,EAAE,CAACC,MAA3C,EAAmDF,EAAE,EAArD,EAAyD;AACrD,UAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;AACAsC,MAAAA,MAAM,CAACJ,IAAP,CAAY,CAACnB,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,CAAZ;AACH;;AACD,WAAOuB,MAAP;AACH,GAPD;AAQA;AACJ;AACA;AACA;AACA;;;AACIlD,EAAAA,UAAU,CAACK,SAAX,CAAqB0D,GAArB,GAA2B,UAAU7B,KAAV,EAAiB;AACxC,QAAIA,KAAK,KAAKhB,SAAd,EAAyB;AACrB,YAAM,IAAIF,SAAJ,CAAc,eAAd,CAAN;AACH,KAFD,MAGK,IAAIkB,KAAK,YAAYlC,UAArB,EAAiC;AAClC,UAAIwB,CAAC,GAAG,CAAR;AACA,UAAIwC,GAAG,GAAG,KAAKxD,MAAL,CAAYM,MAAtB;;AACA,WAAK,IAAIF,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGqB,KAAK,CAAC1B,MAA5B,EAAoCI,EAAE,GAAGC,EAAE,CAACC,MAA5C,EAAoDF,EAAE,EAAtD,EAA0D;AACtD,YAAIqD,EAAE,GAAGpD,EAAE,CAACD,EAAD,CAAX;AACA,YAAIwC,CAAC,GAAG,KAAK,CAAb;;AACA,aAAKA,CAAC,GAAG5B,CAAT,EAAY4B,CAAC,GAAGY,GAAhB,EAAqBZ,CAAC,EAAtB,EAA0B;AACtB,cAAIc,EAAE,GAAG,KAAK1D,MAAL,CAAY4C,CAAZ,CAAT;AACA,cAAIa,EAAE,CAAC,CAAD,CAAF,IAASC,EAAE,CAAC,CAAD,CAAX,IAAkBD,EAAE,CAAC,CAAD,CAAF,IAASC,EAAE,CAAC,CAAD,CAA7B,IAAoCD,EAAE,CAAC,CAAD,CAAF,IAASC,EAAE,CAAC,CAAD,CAA/C,IAAsDD,EAAE,CAAC,CAAD,CAAF,IAASC,EAAE,CAAC,CAAD,CAArE,EACI;AACP;;AACD,YAAId,CAAC,KAAKY,GAAV,EACI,OAAO,KAAP;AACP;;AACD,aAAO,IAAP;AACH,KAfI,MAgBA;AACD,aAAO,KAAKD,GAAL,CAAS,IAAI/D,UAAJ,CAAekC,KAAf,CAAT,CAAP;AACH;AACJ,GAvBD;AAwBA;AACJ;AACA;AACA;AACA;AACA;;;AACIlC,EAAAA,UAAU,CAACK,SAAX,CAAqB8D,QAArB,GAAgC,UAAUtC,GAAV,EAAeE,GAAf,EAAoB;AAChD,WAAO,KAAKgC,GAAL,CAAS,IAAI/D,UAAJ,CAAe,CAAC,CAAC6B,GAAD,EAAME,GAAN,CAAD,CAAf,CAAT,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACI/B,EAAAA,UAAU,CAACK,SAAX,CAAqB+D,aAArB,GAAqC,YAAY;AAC7C,WAAO,KAAK5D,MAAL,CAAYM,MAAnB;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACId,EAAAA,UAAU,CAACK,SAAX,CAAqBS,MAArB,GAA8B,YAAY;AACtC,QAAI,KAAKuD,WAAL,EAAJ,EACI,OAAOvC,QAAP;AACJ,QAAIoB,MAAM,GAAG,CAAb;;AACA,SAAK,IAAItC,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKL,MAA3B,EAAmCI,EAAE,GAAGC,EAAE,CAACC,MAA3C,EAAmDF,EAAE,EAArD,EAAyD;AACrD,UAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;AACAsC,MAAAA,MAAM,IAAIvB,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAc,CAAxB;AACH;;AACD,WAAOuB,MAAP;AACH,GATD;AAUA;AACJ;AACA;AACA;AACA;;;AACIlD,EAAAA,UAAU,CAACK,SAAX,CAAqBiE,MAArB,GAA8B,UAAUC,GAAV,EAAe;AACzC,QAAIA,GAAG,KAAKrD,SAAZ,EAAuB;AACnB,YAAM,IAAIF,SAAJ,CAAc,eAAd,CAAN;AACH,KAFD,MAGK,IAAIuD,GAAG,YAAYvE,UAAnB,EAA+B;AAChC,UAAIuE,GAAG,KAAK,IAAZ,EACI,OAAO,IAAP;AACJ,UAAI,KAAK/D,MAAL,CAAYM,MAAZ,KAAuByD,GAAG,CAAC/D,MAAJ,CAAWM,MAAtC,EACI,OAAO,KAAP;;AACJ,WAAK,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,MAAL,CAAYM,MAAhC,EAAwCsC,CAAC,EAAzC,EAA6C;AACzC,YAAI,KAAK5C,MAAL,CAAY4C,CAAZ,EAAe,CAAf,MAAsBmB,GAAG,CAAC/D,MAAJ,CAAW4C,CAAX,EAAc,CAAd,CAAtB,IAA0C,KAAK5C,MAAL,CAAY4C,CAAZ,EAAe,CAAf,MAAsBmB,GAAG,CAAC/D,MAAJ,CAAW4C,CAAX,EAAc,CAAd,CAApE,EACI,OAAO,KAAP;AACP;;AACD,aAAO,IAAP;AACH,KAVI,MAWA;AACD,aAAO,KAAKkB,MAAL,CAAY,IAAItE,UAAJ,CAAeuE,GAAf,CAAZ,CAAP;AACH;AACJ,GAlBD;AAmBA;AACJ;AACA;;;AACIvE,EAAAA,UAAU,CAACK,SAAX,CAAqBgE,WAArB,GAAmC,YAAY;AAC3C,WAAQ,KAAK7D,MAAL,CAAYM,MAAZ,GAAqB,CAArB,KACA,KAAKN,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,CAACsB,QAAvB,IACA,KAAKtB,MAAL,CAAY,KAAKA,MAAL,CAAYM,MAAZ,GAAqB,CAAjC,EAAoC,CAApC,MAA2CgB,QAF3C,CAAR;AAGH,GAJD;AAKA;AACJ;AACA;;;AACI9B,EAAAA,UAAU,CAACK,SAAX,CAAqBwB,GAArB,GAA2B,YAAY;AACnC,QAAI,KAAKrB,MAAL,CAAYM,MAAZ,KAAuB,CAA3B,EACI,OAAOI,SAAP;AACJ,WAAO,KAAKV,MAAL,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAJD;AAKA;AACJ;AACA;;;AACIR,EAAAA,UAAU,CAACK,SAAX,CAAqB0B,GAArB,GAA2B,YAAY;AACnC,QAAI,KAAKvB,MAAL,CAAYM,MAAZ,KAAuB,CAA3B,EACI,OAAOI,SAAP;AACJ,WAAO,KAAKV,MAAL,CAAY,KAAKA,MAAL,CAAYM,MAAZ,GAAqB,CAAjC,EAAoC,CAApC,CAAP;AACH,GAJD;AAKA;AACJ;AACA;;;AACId,EAAAA,UAAU,CAACK,SAAX,CAAqBmE,KAArB,GAA6B,YAAY;AACrC,QAAI3C,GAAG,GAAG,KAAKA,GAAL,EAAV;AACA,QAAIA,GAAG,KAAK,CAACC,QAAb,EACI,MAAM,IAAIM,UAAJ,CAAe,yEAAf,CAAN;AACJ,QAAIP,GAAG,KAAKX,SAAZ,EACI,KAAKyB,QAAL,CAAcd,GAAd;AACJ,WAAOA,GAAP;AACH,GAPD;AAQA;AACJ;AACA;;;AACI7B,EAAAA,UAAU,CAACK,SAAX,CAAqBoE,GAArB,GAA2B,YAAY;AACnC,QAAI1C,GAAG,GAAG,KAAKA,GAAL,EAAV;AACA,QAAIA,GAAG,KAAKD,QAAZ,EACI,MAAM,IAAIM,UAAJ,CAAe,uEAAf,CAAN;AACJ,QAAIL,GAAG,KAAKb,SAAZ,EACI,KAAKyB,QAAL,CAAcZ,GAAd;AACJ,WAAOA,GAAP;AACH,GAPD;AAQA;AACJ;AACA;;;AACI/B,EAAAA,UAAU,CAACK,SAAX,CAAqBC,QAArB,GAAgC,YAAY;AACxC,aAASoE,IAAT,CAActB,CAAd,EAAiB;AACb,aAAQA,CAAC,IAAI,CAAL,GAASuB,MAAM,CAACvB,CAAD,CAAf,GAAqB,MAAMA,CAAN,GAAU,GAAvC;AACH;;AACD,QAAI5C,MAAM,GAAG,EAAb;;AACA,SAAK,IAAII,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKL,MAA3B,EAAmCI,EAAE,GAAGC,EAAE,CAACC,MAA3C,EAAmDF,EAAE,EAArD,EAAyD;AACrD,UAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;;AACA,UAAIe,CAAC,CAAC,CAAD,CAAD,KAAS,CAACG,QAAd,EAAwB;AACpB,YAAIH,CAAC,CAAC,CAAD,CAAD,KAASG,QAAb,EAAuB;AACnBtB,UAAAA,MAAM,CAACsC,IAAP,CAAY,GAAZ;AACH,SAFD,MAGK;AACDtC,UAAAA,MAAM,CAACsC,IAAP,CAAY,MAAM4B,IAAI,CAAC/C,CAAC,CAAC,CAAD,CAAF,CAAtB;AACH;AACJ,OAPD,MAQK,IAAIA,CAAC,CAAC,CAAD,CAAD,KAASG,QAAb,EAAuB;AACxBtB,QAAAA,MAAM,CAACsC,IAAP,CAAY4B,IAAI,CAAC/C,CAAC,CAAC,CAAD,CAAF,CAAJ,GAAa,GAAzB;AACH,OAFI,MAGA,IAAIA,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAb,EAAkB;AACnBnB,QAAAA,MAAM,CAACsC,IAAP,CAAY4B,IAAI,CAAC/C,CAAC,CAAC,CAAD,CAAF,CAAhB;AACH,OAFI,MAGA;AACDnB,QAAAA,MAAM,CAACsC,IAAP,CAAY4B,IAAI,CAAC/C,CAAC,CAAC,CAAD,CAAF,CAAJ,GAAa,GAAb,GAAmB+C,IAAI,CAAC/C,CAAC,CAAC,CAAD,CAAF,CAAnC;AACH;AACJ;;AACD,WAAOnB,MAAM,CAACoE,IAAP,CAAY,GAAZ,CAAP;AACH,GA1BD;AA2BA;AACJ;AACA;AACA;;;AACI5E,EAAAA,UAAU,CAACK,SAAX,CAAqBwE,OAArB,GAA+B,YAAY;AACvC,QAAI,KAAKR,WAAL,EAAJ,EAAwB;AACpB,YAAM,IAAIjC,UAAJ,CAAe,mDAAf,CAAN;AACH;;AACD,QAAIc,MAAM,GAAG,IAAI4B,KAAJ,CAAU,KAAKhE,MAAL,EAAV,CAAb;AACA,QAAIiE,GAAG,GAAG,CAAV;;AACA,SAAK,IAAInE,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKL,MAA3B,EAAmCI,EAAE,GAAGC,EAAE,CAACC,MAA3C,EAAmDF,EAAE,EAArD,EAAyD;AACrD,UAAIe,CAAC,GAAGd,EAAE,CAACD,EAAD,CAAV;;AACA,WAAK,IAAIoE,CAAC,GAAGrD,CAAC,CAAC,CAAD,CAAd,EAAmBqD,CAAC,IAAIrD,CAAC,CAAC,CAAD,CAAzB,EAA8BqD,CAAC,EAA/B,EAAmC;AAC/B9B,QAAAA,MAAM,CAAC6B,GAAG,EAAJ,CAAN,GAAgBC,CAAhB;AACH;AACJ;;AACD,WAAO9B,MAAP;AACH,GAbD;AAcA;AACJ;AACA;;;AACIlD,EAAAA,UAAU,CAACK,SAAX,CAAqB4E,WAArB,GAAmC,YAAY;AAC3C,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKb,WAAL,EAAJ,EAAwB;AACpB,YAAM,IAAIjC,UAAJ,CAAe,0CAAf,CAAN;AACH;;AACD,QAAIgB,CAAC,GAAG,CAAR;AAAA,QAAW+B,QAAQ,GAAG,KAAK3E,MAAL,CAAY4C,CAAZ,CAAtB;AAAA,QAAsCE,CAAC,GAAG6B,QAAQ,GAAGA,QAAQ,CAAC,CAAD,CAAX,GAAiBjE,SAAnE;AACA,WAAO;AACHkE,MAAAA,IAAI,EAAE,YAAY;AACd,YAAI,CAACD,QAAL,EACI,OAAO;AAAEE,UAAAA,IAAI,EAAE;AAAR,SAAP;AACJ,YAAIC,GAAG,GAAGhC,CAAV;;AACA,YAAI,EAAEA,CAAF,GAAM6B,QAAQ,CAAC,CAAD,CAAlB,EAAuB;AACnBA,UAAAA,QAAQ,GAAGD,KAAK,CAAC1E,MAAN,CAAa,EAAE4C,CAAf,CAAX;AACAE,UAAAA,CAAC,GAAG6B,QAAQ,GAAGA,QAAQ,CAAC,CAAD,CAAX,GAAiBjE,SAA7B;AACH;;AACD,eAAO;AAAEgB,UAAAA,KAAK,EAAEoD;AAAT,SAAP;AACH;AAVE,KAAP;AAYH,GAlBD;;AAmBA,SAAOtF,UAAP;AACH,CAhdiB,EAAlB;;AAidAuF,OAAO,CAACvF,UAAR,GAAqBA,UAArB,C,CACA;;AACA;;AACA,IAAI,OAAOwF,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AACrEzF,EAAAA,UAAU,CAACK,SAAX,CAAqBmF,MAAM,CAACC,QAA5B,IAAwCzF,UAAU,CAACK,SAAX,CAAqB4E,WAA7D;AACH,C,CACD;;;AACA,SAASS,UAAT,CAAoBzF,IAApB,EAA0B;AACtB,SAAO,IAAID,UAAJ,CAAeC,IAAf,CAAP;AACH;;AACDsF,OAAO,CAACG,UAAR,GAAqBA,UAArB","sourcesContent":["/*! multi-integer-range (c) 2015 Soichiro Miki */\n\"use strict\";\nvar MultiRange = (function () {\n    /**\n     * Creates a new MultiRange object.\n     */\n    function MultiRange(data) {\n        function isArray(x) {\n            return Object.prototype.toString.call(x) === '[object Array]';\n        }\n        this.ranges = [];\n        if (typeof data === 'string') {\n            this.parseString(data);\n        }\n        else if (typeof data === 'number') {\n            this.appendRange(data, data);\n        }\n        else if (data instanceof MultiRange) {\n            this.ranges = data.getRanges();\n        }\n        else if (isArray(data)) {\n            for (var _i = 0, _a = data; _i < _a.length; _i++) {\n                var item = _a[_i];\n                if (isArray(item)) {\n                    if (item.length === 2) {\n                        this.appendRange(item[0], item[1]);\n                    }\n                    else {\n                        throw new TypeError('Invalid array initializer');\n                    }\n                }\n                else if (typeof item === 'number') {\n                    this.append(item);\n                }\n                else {\n                    throw new TypeError('Invalid array initialzer');\n                }\n            }\n        }\n        else if (data !== undefined) {\n            throw new TypeError('Invalid input');\n        }\n    }\n    /**\n     * Parses the initialize string and build the range data.\n     * Override this if you need to customize the parsing strategy.\n     */\n    MultiRange.prototype.parseString = function (data) {\n        function toInt(str) {\n            var m = str.match(/^\\(?(\\-?\\d+)/);\n            return parseInt(m[1], 10);\n        }\n        var s = data.replace(/\\s/g, '');\n        if (!s.length)\n            return;\n        var match;\n        for (var _i = 0, _a = s.split(','); _i < _a.length; _i++) {\n            var r = _a[_i];\n            if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))$/)) {\n                var val = toInt(match[1]);\n                this.appendRange(val, val);\n            }\n            else if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))?\\-(\\d+|\\(\\-?\\d+\\))?$/)) {\n                var min = match[1] === undefined ? -Infinity : toInt(match[1]);\n                var max = match[2] === undefined ? +Infinity : toInt(match[2]);\n                this.appendRange(min, max);\n            }\n            else {\n                throw new SyntaxError('Invalid input');\n            }\n        }\n        ;\n    };\n    /**\n     * Clones this instance.\n     */\n    MultiRange.prototype.clone = function () {\n        return new MultiRange(this);\n    };\n    /**\n     * Appends to this instance.\n     * @parasm value The data to append.\n     */\n    MultiRange.prototype.append = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n                var r = _a[_i];\n                this.appendRange(r[0], r[1]);\n            }\n            return this;\n        }\n        else {\n            return this.append(new MultiRange(value));\n        }\n    };\n    /**\n     * Appends a specified range of integers to this isntance.\n     * @param min The minimum value of the range to append.\n     * @param max The minimum value of the range to append.\n     */\n    MultiRange.prototype.appendRange = function (min, max) {\n        var newRange = [min, max];\n        if (newRange[0] > newRange[1]) {\n            newRange = [newRange[1], newRange[0]];\n        }\n        if (newRange[0] === Infinity && newRange[1] === Infinity ||\n            newRange[0] === -Infinity && newRange[1] === -Infinity) {\n            throw new RangeError('Infinity can be used only within an unbounded range segment');\n        }\n        var overlap = this.findOverlap(newRange);\n        this.ranges.splice(overlap.lo, overlap.count, overlap.union);\n        return this;\n    };\n    /**\n     * Subtracts from this instance.\n     * @param value The data to subtract.\n     */\n    MultiRange.prototype.subtract = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n                var r = _a[_i];\n                this.subtractRange(r[0], r[1]);\n            }\n            return this;\n        }\n        else {\n            return this.subtract(new MultiRange(value));\n        }\n    };\n    /**\n     * Subtracts a specified range of integers from this instance.\n     * @param min The minimum value of the range to subtract.\n     * @param max The minimum value of the range to subtract.\n     */\n    MultiRange.prototype.subtractRange = function (min, max) {\n        var newRange = [min, max];\n        if (newRange[0] > newRange[1]) {\n            newRange = [newRange[1], newRange[0]];\n        }\n        var overlap = this.findOverlap(newRange);\n        if (overlap.count > 0) {\n            var remain = [];\n            if (this.ranges[overlap.lo][0] < newRange[0]) {\n                remain.push([this.ranges[overlap.lo][0], newRange[0] - 1]);\n            }\n            if (newRange[1] < this.ranges[overlap.lo + overlap.count - 1][1]) {\n                remain.push([newRange[1] + 1, this.ranges[overlap.lo + overlap.count - 1][1]]);\n            }\n            this.ranges.splice.apply(this.ranges, [overlap.lo, overlap.count].concat(remain));\n        }\n        return this;\n    };\n    /**\n     * Remove integers which are not included in the given ranges (aka intersection).\n     * @param value The data to calculate the intersetion.\n     */\n    MultiRange.prototype.intersect = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            var result = [];\n            var jstart = 0; // used for optimization\n            for (var i = 0; i < this.ranges.length; i++) {\n                var r1 = this.ranges[i];\n                for (var j = jstart; j < value.ranges.length; j++) {\n                    var r2 = value.ranges[j];\n                    if (r1[0] <= r2[1] && r1[1] >= r2[0]) {\n                        jstart = j;\n                        var min = Math.max(r1[0], r2[0]);\n                        var max = Math.min(r1[1], r2[1]);\n                        result.push([min, max]);\n                    }\n                    else if (r1[1] < r2[0]) {\n                        break;\n                    }\n                }\n            }\n            this.ranges = result;\n            return this;\n        }\n        else {\n            return this.intersect(new MultiRange(value));\n        }\n    };\n    /**\n     * Determines how the given range overlaps or touches the existing ranges.\n     * This is a helper method that calculates how an append/subtract operation\n     * affects the existing range members.\n     * @param target The range array to test.\n     * @return An object containing information about how the given range\n     * overlaps or touches this instance.\n     */\n    MultiRange.prototype.findOverlap = function (target) {\n        //   a        b  c     d         e  f       g h i   j k  l       m\n        //--------------------------------------------------------------------\n        //   |----(0)----|     |---(1)---|  |---(2)---|          |--(3)--|\n        //            |------------(A)--------------|\n        //                                            |-(B)-|\n        //                                              |-(C)-|\n        //\n        // (0)-(3) represent the existing ranges (this.ranges),\n        // and (A)-(C) are the ranges being passed to this function.\n        //\n        // A pseudocode findOverlap(A) returns { lo: 0, count: 3, union: <a-h> },\n        // meaning (A) overlaps the 3 existing ranges from index 0.\n        //\n        // findOverlap(B) returns { lo: 2, count: 1, union: <f-j> },\n        // meaning (B) \"touches\" one range element, (2).\n        //\n        // findOverlap(C) returns { lo: 3, count: 0, union: <i-k> }\n        // meaning (C) is between (2) and (3) but overlaps/touches neither of them.\n        for (var hi = this.ranges.length - 1; hi >= 0; hi--) {\n            var r = this.ranges[hi];\n            var union = void 0;\n            if (union = this.calcUnion(r, target)) {\n                var count = 1;\n                var tmp = void 0;\n                while ((hi - count >= 0) && (tmp = this.calcUnion(union, this.ranges[hi - count]))) {\n                    union = tmp;\n                    count++;\n                }\n                // The given target touches or overlaps one or more of the existing ranges\n                return { lo: hi + 1 - count, count: count, union: union };\n            }\n            else if (r[1] < target[0]) {\n                // The given target does not touch nor overlap the existing ranges\n                return { lo: hi + 1, count: 0, union: target };\n            }\n        }\n        // The given target is smaller than the smallest existing range\n        return { lo: 0, count: 0, union: target };\n    };\n    /**\n     * Calculates the union of two specified ranges.\n     * @param a Range A\n     * @param b Range B\n     * @return Union of a and b. Null if a and b do not touch nor intersect.\n     */\n    MultiRange.prototype.calcUnion = function (a, b) {\n        if (a[1] + 1 < b[0] || a[0] - 1 > b[1]) {\n            return null; // cannot make union\n        }\n        return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];\n    };\n    /**\n     * Exports the whole range data as an array of arrays.\n     */\n    MultiRange.prototype.getRanges = function () {\n        var result = [];\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            result.push([r[0], r[1]]);\n        }\n        return result;\n    };\n    /**\n     * Checks if the instance contains the specified value.\n     * @param value Value to be checked\n     * @return True if the specified value is included in the instance.\n     */\n    MultiRange.prototype.has = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            var s = 0;\n            var len = this.ranges.length;\n            for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n                var tr = _a[_i];\n                var i = void 0;\n                for (i = s; i < len; i++) {\n                    var my = this.ranges[i];\n                    if (tr[0] >= my[0] && tr[1] <= my[1] && tr[1] >= my[0] && tr[1] <= my[1])\n                        break;\n                }\n                if (i === len)\n                    return false;\n            }\n            return true;\n        }\n        else {\n            return this.has(new MultiRange(value));\n        }\n    };\n    /**\n     * Checks if the instance contains the range specified by the two parameters.\n     * @param min The minimum value of the range to subtract.\n     * @param max The minimum value of the range to subtract.\n     * @return True if the specified value is included in the instance.\n     */\n    MultiRange.prototype.hasRange = function (min, max) {\n        return this.has(new MultiRange([[min, max]]));\n    };\n    /**\n     * Returns the number of range segments.\n     * For example, the segmentLength of `2-5,7,9-11' is 3.\n     * Returns 0 for an empty instance.\n     * @return The number of segments.\n     */\n    MultiRange.prototype.segmentLength = function () {\n        return this.ranges.length;\n    };\n    /**\n     * Calculates how many numbers are effectively included in this instance.\n     * (i.e. '1-10,51-60,90' returns 21)\n     * @return The number of integer values in this instance.\n     *    Returns `Infinity` for unbounded ranges.\n     */\n    MultiRange.prototype.length = function () {\n        if (this.isUnbounded())\n            return Infinity;\n        var result = 0;\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            result += r[1] - r[0] + 1;\n        }\n        return result;\n    };\n    /**\n     * Checks if two instances of MultiRange are identical.\n     * @param cmp The data to compare.\n     * @return True if cmp is exactly the same as this instance.\n     */\n    MultiRange.prototype.equals = function (cmp) {\n        if (cmp === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (cmp instanceof MultiRange) {\n            if (cmp === this)\n                return true;\n            if (this.ranges.length !== cmp.ranges.length)\n                return false;\n            for (var i = 0; i < this.ranges.length; i++) {\n                if (this.ranges[i][0] !== cmp.ranges[i][0] || this.ranges[i][1] !== cmp.ranges[i][1])\n                    return false;\n            }\n            return true;\n        }\n        else {\n            return this.equals(new MultiRange(cmp));\n        }\n    };\n    /**\n     * Checks if the current instance is unbounded (i.e., infinite).\n     */\n    MultiRange.prototype.isUnbounded = function () {\n        return (this.ranges.length > 0\n            && (this.ranges[0][0] === -Infinity ||\n                this.ranges[this.ranges.length - 1][1] === Infinity));\n    };\n    /**\n     * Returns the minimum number contained in this insntance. Can be -Infinity or undefined.\n     */\n    MultiRange.prototype.min = function () {\n        if (this.ranges.length === 0)\n            return undefined;\n        return this.ranges[0][0];\n    };\n    /**\n     * Returns the maximum number contained in this insntance. Can be +Infinity or undefined.\n     */\n    MultiRange.prototype.max = function () {\n        if (this.ranges.length === 0)\n            return undefined;\n        return this.ranges[this.ranges.length - 1][1];\n    };\n    /**\n     * Removes the smallest integer from this instance and returns that integer.\n     */\n    MultiRange.prototype.shift = function () {\n        var min = this.min();\n        if (min === -Infinity)\n            throw new RangeError('shift() was invoked on an unbounded MultiRange which contains -Infinity');\n        if (min !== undefined)\n            this.subtract(min);\n        return min;\n    };\n    /**\n     * Removes the largest integer from this instance and returns that integer.\n     */\n    MultiRange.prototype.pop = function () {\n        var max = this.max();\n        if (max === Infinity)\n            throw new RangeError('pop() was invoked on an unbounded MultiRange which contains +Infinity');\n        if (max !== undefined)\n            this.subtract(max);\n        return max;\n    };\n    /**\n     * Returns the string respresentation of this MultiRange.\n     */\n    MultiRange.prototype.toString = function () {\n        function wrap(i) {\n            return (i >= 0 ? String(i) : \"(\" + i + \")\");\n        }\n        var ranges = [];\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            if (r[0] === -Infinity) {\n                if (r[1] === Infinity) {\n                    ranges.push('-');\n                }\n                else {\n                    ranges.push(\"-\" + wrap(r[1]));\n                }\n            }\n            else if (r[1] === Infinity) {\n                ranges.push(wrap(r[0]) + \"-\");\n            }\n            else if (r[0] == r[1]) {\n                ranges.push(wrap(r[0]));\n            }\n            else {\n                ranges.push(wrap(r[0]) + \"-\" + wrap(r[1]));\n            }\n        }\n        return ranges.join(',');\n    };\n    /**\n     * Builds an array of integer which holds all elements in this MultiRange.\n     * Note that this may be slow and memory-consuming for large ranges such as '1-10000'.\n     */\n    MultiRange.prototype.toArray = function () {\n        if (this.isUnbounded()) {\n            throw new RangeError('You cannot build an array from an unbounded range');\n        }\n        var result = new Array(this.length());\n        var idx = 0;\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            for (var n = r[0]; n <= r[1]; n++) {\n                result[idx++] = n;\n            }\n        }\n        return result;\n    };\n    /**\n     * Returns ES6-compatible iterator.\n     */\n    MultiRange.prototype.getIterator = function () {\n        var _this = this;\n        if (this.isUnbounded()) {\n            throw new RangeError('Unbounded ranges cannot be iterated over');\n        }\n        var i = 0, curRange = this.ranges[i], j = curRange ? curRange[0] : undefined;\n        return {\n            next: function () {\n                if (!curRange)\n                    return { done: true };\n                var ret = j;\n                if (++j > curRange[1]) {\n                    curRange = _this.ranges[++i];\n                    j = curRange ? curRange[0] : undefined;\n                }\n                return { value: ret };\n            }\n        };\n    };\n    return MultiRange;\n}());\nexports.MultiRange = MultiRange;\n// Set ES6 iterator, if Symbol.iterator is defined\n/* istanbul ignore else */\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n    MultiRange.prototype[Symbol.iterator] = MultiRange.prototype.getIterator;\n}\n// A shorthand function to get a new MultiRange instance\nfunction multirange(data) {\n    return new MultiRange(data);\n}\nexports.multirange = multirange;\n"]},"metadata":{},"sourceType":"script"}