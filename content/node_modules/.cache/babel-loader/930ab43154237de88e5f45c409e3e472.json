{"ast":null,"code":"import { maybeDecryptPemBody, maybeEncryptPemBody } from './encryption';\nimport { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey } from './keys';\nimport { uint8ArrayToBinaryString, binaryStringToUint8Array } from '../../util/binary';\nimport { decodePem, encodePem } from '../../util/pem-encoder';\nimport { DecodePemFailedError, UnsupportedAlgorithmError } from '../../util/errors';\nimport { KEY_TYPES } from '../../util/key-types';\n\nconst getKeyType = pemType => {\n  const match = /^(\\S+?) (PUBLIC|PRIVATE) KEY$/.exec(pemType);\n  return match && match[1].toLocaleLowerCase();\n};\n\nconst getPemType = keyAlgorithm => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n  return keyType && keyType.toUpperCase();\n};\n\nexport const decomposePrivateKey = (pem, options) => {\n  let decodedPem;\n\n  try {\n    decodedPem = decodePem(pem, '* PRIVATE KEY');\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Decrypt pem if encrypted\n\n\n  const {\n    pemBody,\n    encryptionAlgorithm\n  } = maybeDecryptPemBody(decodedPem, options.password); // Extract the key type from it\n\n  const keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposeRawPrivateKey(keyType, pemBody);\n  return {\n    format: 'raw-pem',\n    keyAlgorithm,\n    keyData,\n    encryptionAlgorithm\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}, options) => {\n  // Compose the key\n  const rawKey = composeRawPrivateKey(keyAlgorithm, keyData); // Extract the pem type\n\n  const pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Encrypt pem if password was specified\n\n\n  const {\n    pemBody,\n    pemHeaders\n  } = maybeEncryptPemBody(rawKey, encryptionAlgorithm, options.password); // Finally build pem\n\n  return encodePem({\n    type: `${pemKeyType} PRIVATE KEY`,\n    body: uint8ArrayToBinaryString(pemBody),\n    ...pemHeaders\n  });\n};\nexport const decomposePublicKey = pem => {\n  // Decode pem\n  let decodedPem;\n\n  try {\n    decodedPem = decodePem(pem);\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Extract the key type from it\n\n\n  const keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  const pemBody = binaryStringToUint8Array(decodedPem.body);\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposeRawPublicKey(keyType, pemBody);\n  return {\n    format: 'raw-pem',\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePublicKey = ({\n  keyAlgorithm,\n  keyData\n}) => {\n  // Compose the key\n  const rawKey = composeRawPublicKey(keyAlgorithm, keyData); // Extract the pem type\n\n  const pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Finally build pem\n\n\n  return encodePem({\n    type: `${pemKeyType} PUBLIC KEY`,\n    body: uint8ArrayToBinaryString(rawKey)\n  });\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/formats/raw/raw-pem.js"],"names":["maybeDecryptPemBody","maybeEncryptPemBody","decomposeRawPrivateKey","composeRawPrivateKey","decomposeRawPublicKey","composeRawPublicKey","uint8ArrayToBinaryString","binaryStringToUint8Array","decodePem","encodePem","DecodePemFailedError","UnsupportedAlgorithmError","KEY_TYPES","getKeyType","pemType","match","exec","toLocaleLowerCase","getPemType","keyAlgorithm","keyType","id","toUpperCase","decomposePrivateKey","pem","options","decodedPem","err","invalidInputKey","pemBody","encryptionAlgorithm","password","type","keyData","format","composePrivateKey","rawKey","pemKeyType","pemHeaders","body","decomposePublicKey","composePublicKey"],"mappings":"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","sourcesContent":["import { maybeDecryptPemBody, maybeEncryptPemBody } from './encryption';\nimport { decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey } from './keys';\nimport { uint8ArrayToBinaryString, binaryStringToUint8Array } from '../../util/binary';\nimport { decodePem, encodePem } from '../../util/pem-encoder';\nimport { DecodePemFailedError, UnsupportedAlgorithmError } from '../../util/errors';\nimport { KEY_TYPES } from '../../util/key-types';\n\nconst getKeyType = pemType => {\n  const match = /^(\\S+?) (PUBLIC|PRIVATE) KEY$/.exec(pemType);\n  return match && match[1].toLocaleLowerCase();\n};\n\nconst getPemType = keyAlgorithm => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n  return keyType && keyType.toUpperCase();\n};\n\nexport const decomposePrivateKey = (pem, options) => {\n  let decodedPem;\n\n  try {\n    decodedPem = decodePem(pem, '* PRIVATE KEY');\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Decrypt pem if encrypted\n\n\n  const {\n    pemBody,\n    encryptionAlgorithm\n  } = maybeDecryptPemBody(decodedPem, options.password); // Extract the key type from it\n\n  const keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposeRawPrivateKey(keyType, pemBody);\n  return {\n    format: 'raw-pem',\n    keyAlgorithm,\n    keyData,\n    encryptionAlgorithm\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}, options) => {\n  // Compose the key\n  const rawKey = composeRawPrivateKey(keyAlgorithm, keyData); // Extract the pem type\n\n  const pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Encrypt pem if password was specified\n\n\n  const {\n    pemBody,\n    pemHeaders\n  } = maybeEncryptPemBody(rawKey, encryptionAlgorithm, options.password); // Finally build pem\n\n  return encodePem({\n    type: `${pemKeyType} PRIVATE KEY`,\n    body: uint8ArrayToBinaryString(pemBody),\n    ...pemHeaders\n  });\n};\nexport const decomposePublicKey = pem => {\n  // Decode pem\n  let decodedPem;\n\n  try {\n    decodedPem = decodePem(pem);\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodePemFailedError;\n    throw err;\n  } // Extract the key type from it\n\n\n  const keyType = getKeyType(decodedPem.type);\n  /* istanbul ignore if */\n\n  if (!keyType) {\n    throw new DecodePemFailedError('Unable to extract key type from PEM', {\n      invalidInputKey: true\n    });\n  } // Finally decompose the key within it\n\n\n  const pemBody = binaryStringToUint8Array(decodedPem.body);\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposeRawPublicKey(keyType, pemBody);\n  return {\n    format: 'raw-pem',\n    keyAlgorithm,\n    keyData\n  };\n};\nexport const composePublicKey = ({\n  keyAlgorithm,\n  keyData\n}) => {\n  // Compose the key\n  const rawKey = composeRawPublicKey(keyAlgorithm, keyData); // Extract the pem type\n\n  const pemKeyType = getPemType(keyAlgorithm);\n  /* istanbul ignore if */\n\n  if (!pemKeyType) {\n    throw new UnsupportedAlgorithmError('Unable to extract pem type from key algorithm');\n  } // Finally build pem\n\n\n  return encodePem({\n    type: `${pemKeyType} PUBLIC KEY`,\n    body: uint8ArrayToBinaryString(rawKey)\n  });\n};"]},"metadata":{},"sourceType":"module"}