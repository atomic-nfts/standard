{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionUploader = void 0;\n\nvar transaction_1 = __importDefault(require(\"./transaction\"));\n\nvar ArweaveUtils = __importStar(require(\"./utils\"));\n\nvar error_1 = require(\"./error\");\n\nvar merkle_1 = require(\"./merkle\"); // Maximum amount of chunks we will upload in the body.\n\n\nvar MAX_CHUNKS_IN_BODY = 1; // We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\n\nvar FATAL_CHUNK_UPLOAD_ERRORS = [\"invalid_json\", \"chunk_too_big\", \"data_path_too_big\", \"offset_too_big\", \"data_size_too_big\", \"chunk_proof_ratio_not_attractive\", \"invalid_proof\"]; // Amount we will delay on receiving an error response but do want to continue.\n\nvar ERROR_DELAY = 1000 * 40;\n\nvar TransactionUploader = /*#__PURE__*/function () {\n  function TransactionUploader(api, transaction) {\n    _classCallCheck(this, TransactionUploader);\n\n    this.api = api;\n    this.chunkIndex = 0;\n    this.txPosted = false;\n    this.lastRequestTimeEnd = 0;\n    this.totalErrors = 0; // Not serialized.\n\n    this.lastResponseStatus = 0;\n    this.lastResponseError = \"\";\n\n    if (!transaction.id) {\n      throw new Error(\"Transaction is not signed\");\n    }\n\n    if (!transaction.chunks) {\n      throw new Error(\"Transaction chunks not prepared\");\n    } // Make a copy of transaction, zeroing the data so we can serialize.\n\n\n    this.data = transaction.data;\n    this.transaction = new transaction_1.default(Object.assign({}, transaction, {\n      data: new Uint8Array(0)\n    }));\n  }\n\n  _createClass(TransactionUploader, [{\n    key: \"isComplete\",\n    get: function get() {\n      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;\n    }\n  }, {\n    key: \"totalChunks\",\n    get: function get() {\n      return this.transaction.chunks.chunks.length;\n    }\n  }, {\n    key: \"uploadedChunks\",\n    get: function get() {\n      return this.chunkIndex;\n    }\n  }, {\n    key: \"pctComplete\",\n    get: function get() {\n      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);\n    }\n    /**\n     * Uploads the next part of the transaction.\n     * On the first call this posts the transaction\n     * itself and on any subsequent calls uploads the\n     * next chunk until it completes.\n     */\n\n  }, {\n    key: \"uploadChunk\",\n    value: function () {\n      var _uploadChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var delay, chunk, chunkOk, resp;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.isComplete) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Upload is already complete\");\n\n              case 2:\n                if (this.lastResponseError !== \"\") {\n                  this.totalErrors++;\n                } else {\n                  this.totalErrors = 0;\n                } // We have been trying for about an hour receiving an\n                // error every time, so eventually bail.\n\n\n                if (!(this.totalErrors === 100)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Unable to complete upload: \".concat(this.lastResponseStatus, \": \").concat(this.lastResponseError));\n\n              case 5:\n                delay = this.lastResponseError === \"\" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n\n                if (!(delay > 0)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n                delay = delay - delay * Math.random() * 0.3;\n                _context.next = 10;\n                return new Promise(function (res) {\n                  return setTimeout(res, delay);\n                });\n\n              case 10:\n                this.lastResponseError = \"\";\n\n                if (this.txPosted) {\n                  _context.next = 15;\n                  break;\n                }\n\n                _context.next = 14;\n                return this.postTransaction();\n\n              case 14:\n                return _context.abrupt(\"return\");\n\n              case 15:\n                chunk = this.transaction.getChunk(this.chunkIndex, this.data);\n                _context.next = 18;\n                return merkle_1.validatePath(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n\n              case 18:\n                chunkOk = _context.sent;\n\n                if (chunkOk) {\n                  _context.next = 21;\n                  break;\n                }\n\n                throw new Error(\"Unable to validate chunk \".concat(this.chunkIndex));\n\n              case 21:\n                _context.next = 23;\n                return this.api.post(\"chunk\", this.transaction.getChunk(this.chunkIndex, this.data)).catch(function (e) {\n                  console.error(e.message);\n                  return {\n                    status: -1,\n                    data: {\n                      error: e.message\n                    }\n                  };\n                });\n\n              case 23:\n                resp = _context.sent;\n                this.lastRequestTimeEnd = Date.now();\n                this.lastResponseStatus = resp.status;\n\n                if (!(this.lastResponseStatus == 200)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                this.chunkIndex++;\n                _context.next = 33;\n                break;\n\n              case 30:\n                this.lastResponseError = error_1.getError(resp);\n\n                if (!FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n                  _context.next = 33;\n                  break;\n                }\n\n                throw new Error(\"Fatal error uploading chunk \".concat(this.chunkIndex, \": \").concat(this.lastResponseError));\n\n              case 33:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function uploadChunk() {\n        return _uploadChunk.apply(this, arguments);\n      }\n\n      return uploadChunk;\n    }()\n    /**\n     * Reconstructs an upload from its serialized state and data.\n     * Checks if data matches the expected data_root.\n     *\n     * @param serialized\n     * @param data\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        chunkIndex: this.chunkIndex,\n        transaction: this.transaction,\n        lastRequestTimeEnd: this.lastRequestTimeEnd,\n        lastResponseStatus: this.lastResponseStatus,\n        lastResponseError: this.lastResponseError,\n        txPosted: this.txPosted\n      };\n    } // POST to /tx\n\n  }, {\n    key: \"postTransaction\",\n    value: function () {\n      var _postTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var uploadInBody, _resp, resp;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n\n                if (!uploadInBody) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                // Post the transaction with data.\n                this.transaction.data = this.data;\n                _context2.next = 5;\n                return this.api.post(\"tx\", this.transaction).catch(function (e) {\n                  console.error(e);\n                  return {\n                    status: -1,\n                    data: {\n                      error: e.message\n                    }\n                  };\n                });\n\n              case 5:\n                _resp = _context2.sent;\n                this.lastRequestTimeEnd = Date.now();\n                this.lastResponseStatus = _resp.status;\n                this.transaction.data = new Uint8Array(0);\n\n                if (!(_resp.status >= 200 && _resp.status < 300)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                // We are complete.\n                this.txPosted = true;\n                this.chunkIndex = MAX_CHUNKS_IN_BODY;\n                return _context2.abrupt(\"return\");\n\n              case 13:\n                this.lastResponseError = error_1.getError(_resp);\n                throw new Error(\"Unable to upload transaction: \".concat(_resp.status, \", \").concat(this.lastResponseError));\n\n              case 15:\n                _context2.next = 17;\n                return this.api.post(\"tx\", this.transaction);\n\n              case 17:\n                resp = _context2.sent;\n                this.lastRequestTimeEnd = Date.now();\n                this.lastResponseStatus = resp.status;\n\n                if (resp.status >= 200 && resp.status < 300) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                this.lastResponseError = error_1.getError(resp);\n                throw new Error(\"Unable to upload transaction: \".concat(resp.status, \", \").concat(this.lastResponseError));\n\n              case 23:\n                this.txPosted = true;\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function postTransaction() {\n        return _postTransaction.apply(this, arguments);\n      }\n\n      return postTransaction;\n    }()\n  }], [{\n    key: \"fromSerialized\",\n    value: function () {\n      var _fromSerialized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(api, serialized, data) {\n        var upload;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!serialized || typeof serialized.chunkIndex !== \"number\" || typeof serialized.transaction !== \"object\")) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Serialized object does not match expected format.\");\n\n              case 2:\n                // Everything looks ok, reconstruct the TransactionUpload,\n                // prepare the chunks again and verify the data_root matches\n                upload = new TransactionUploader(api, new transaction_1.default(serialized.transaction)); // Copy the serialized upload information, and data passed in.\n\n                upload.chunkIndex = serialized.chunkIndex;\n                upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n                upload.lastResponseError = serialized.lastResponseError;\n                upload.lastResponseStatus = serialized.lastResponseStatus;\n                upload.txPosted = serialized.txPosted;\n                upload.data = data;\n                _context3.next = 11;\n                return upload.transaction.prepareChunks(data);\n\n              case 11:\n                if (!(upload.transaction.data_root !== serialized.transaction.data_root)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw new Error(\"Data mismatch: Uploader doesn't match provided data.\");\n\n              case 13:\n                return _context3.abrupt(\"return\", upload);\n\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function fromSerialized(_x, _x2, _x3) {\n        return _fromSerialized.apply(this, arguments);\n      }\n\n      return fromSerialized;\n    }()\n    /**\n     * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n     *\n     * @param api\n     * @param id\n     * @param data\n     */\n\n  }, {\n    key: \"fromTransactionId\",\n    value: function () {\n      var _fromTransactionId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(api, id) {\n        var resp, transaction, serialized;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return api.get(\"tx/\".concat(id));\n\n              case 2:\n                resp = _context4.sent;\n\n                if (!(resp.status !== 200)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Tx \".concat(id, \" not found: \").concat(resp.status));\n\n              case 5:\n                transaction = resp.data;\n                transaction.data = new Uint8Array(0);\n                serialized = {\n                  txPosted: true,\n                  chunkIndex: 0,\n                  lastResponseError: \"\",\n                  lastRequestTimeEnd: 0,\n                  lastResponseStatus: 0,\n                  transaction: transaction\n                };\n                return _context4.abrupt(\"return\", serialized);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function fromTransactionId(_x4, _x5) {\n        return _fromTransactionId.apply(this, arguments);\n      }\n\n      return fromTransactionId;\n    }()\n  }]);\n\n  return TransactionUploader;\n}();\n\nexports.TransactionUploader = TransactionUploader;","map":{"version":3,"sources":["../../../../src/common/lib/transaction-uploader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionUploader = void 0;\nconst transaction_1 = __importDefault(require(\"./transaction\"));\nconst ArweaveUtils = __importStar(require(\"./utils\"));\nconst error_1 = require(\"./error\");\nconst merkle_1 = require(\"./merkle\");\n// Maximum amount of chunks we will upload in the body.\nconst MAX_CHUNKS_IN_BODY = 1;\n// We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\n    \"invalid_json\",\n    \"chunk_too_big\",\n    \"data_path_too_big\",\n    \"offset_too_big\",\n    \"data_size_too_big\",\n    \"chunk_proof_ratio_not_attractive\",\n    \"invalid_proof\",\n];\n// Amount we will delay on receiving an error response but do want to continue.\nconst ERROR_DELAY = 1000 * 40;\nclass TransactionUploader {\n    constructor(api, transaction) {\n        this.api = api;\n        this.chunkIndex = 0;\n        this.txPosted = false;\n        this.lastRequestTimeEnd = 0;\n        this.totalErrors = 0; // Not serialized.\n        this.lastResponseStatus = 0;\n        this.lastResponseError = \"\";\n        if (!transaction.id) {\n            throw new Error(`Transaction is not signed`);\n        }\n        if (!transaction.chunks) {\n            throw new Error(`Transaction chunks not prepared`);\n        }\n        // Make a copy of transaction, zeroing the data so we can serialize.\n        this.data = transaction.data;\n        this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));\n    }\n    get isComplete() {\n        return (this.txPosted &&\n            this.chunkIndex === this.transaction.chunks.chunks.length);\n    }\n    get totalChunks() {\n        return this.transaction.chunks.chunks.length;\n    }\n    get uploadedChunks() {\n        return this.chunkIndex;\n    }\n    get pctComplete() {\n        return Math.trunc((this.uploadedChunks / this.totalChunks) * 100);\n    }\n    /**\n     * Uploads the next part of the transaction.\n     * On the first call this posts the transaction\n     * itself and on any subsequent calls uploads the\n     * next chunk until it completes.\n     */\n    async uploadChunk() {\n        if (this.isComplete) {\n            throw new Error(`Upload is already complete`);\n        }\n        if (this.lastResponseError !== \"\") {\n            this.totalErrors++;\n        }\n        else {\n            this.totalErrors = 0;\n        }\n        // We have been trying for about an hour receiving an\n        // error every time, so eventually bail.\n        if (this.totalErrors === 100) {\n            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n        }\n        let delay = this.lastResponseError === \"\"\n            ? 0\n            : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n        if (delay > 0) {\n            // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n            delay = delay - delay * Math.random() * 0.3;\n            await new Promise((res) => setTimeout(res, delay));\n        }\n        this.lastResponseError = \"\";\n        if (!this.txPosted) {\n            await this.postTransaction();\n            return;\n        }\n        const chunk = this.transaction.getChunk(this.chunkIndex, this.data);\n        const chunkOk = await merkle_1.validatePath(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n        if (!chunkOk) {\n            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n        }\n        // Catch network errors and turn them into objects with status -1 and an error message.\n        const resp = await this.api\n            .post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data))\n            .catch((e) => {\n            console.error(e.message);\n            return { status: -1, data: { error: e.message } };\n        });\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (this.lastResponseStatus == 200) {\n            this.chunkIndex++;\n        }\n        else {\n            this.lastResponseError = error_1.getError(resp);\n            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n                throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n            }\n        }\n    }\n    /**\n     * Reconstructs an upload from its serialized state and data.\n     * Checks if data matches the expected data_root.\n     *\n     * @param serialized\n     * @param data\n     */\n    static async fromSerialized(api, serialized, data) {\n        if (!serialized ||\n            typeof serialized.chunkIndex !== \"number\" ||\n            typeof serialized.transaction !== \"object\") {\n            throw new Error(`Serialized object does not match expected format.`);\n        }\n        // Everything looks ok, reconstruct the TransactionUpload,\n        // prepare the chunks again and verify the data_root matches\n        const upload = new TransactionUploader(api, new transaction_1.default(serialized.transaction));\n        // Copy the serialized upload information, and data passed in.\n        upload.chunkIndex = serialized.chunkIndex;\n        upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n        upload.lastResponseError = serialized.lastResponseError;\n        upload.lastResponseStatus = serialized.lastResponseStatus;\n        upload.txPosted = serialized.txPosted;\n        upload.data = data;\n        await upload.transaction.prepareChunks(data);\n        if (upload.transaction.data_root !== serialized.transaction.data_root) {\n            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n        }\n        return upload;\n    }\n    /**\n     * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n     *\n     * @param api\n     * @param id\n     * @param data\n     */\n    static async fromTransactionId(api, id) {\n        const resp = await api.get(`tx/${id}`);\n        if (resp.status !== 200) {\n            throw new Error(`Tx ${id} not found: ${resp.status}`);\n        }\n        const transaction = resp.data;\n        transaction.data = new Uint8Array(0);\n        const serialized = {\n            txPosted: true,\n            chunkIndex: 0,\n            lastResponseError: \"\",\n            lastRequestTimeEnd: 0,\n            lastResponseStatus: 0,\n            transaction,\n        };\n        return serialized;\n    }\n    toJSON() {\n        return {\n            chunkIndex: this.chunkIndex,\n            transaction: this.transaction,\n            lastRequestTimeEnd: this.lastRequestTimeEnd,\n            lastResponseStatus: this.lastResponseStatus,\n            lastResponseError: this.lastResponseError,\n            txPosted: this.txPosted,\n        };\n    }\n    // POST to /tx\n    async postTransaction() {\n        const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n        if (uploadInBody) {\n            // Post the transaction with data.\n            this.transaction.data = this.data;\n            const resp = await this.api.post(`tx`, this.transaction).catch((e) => {\n                console.error(e);\n                return { status: -1, data: { error: e.message } };\n            });\n            this.lastRequestTimeEnd = Date.now();\n            this.lastResponseStatus = resp.status;\n            this.transaction.data = new Uint8Array(0);\n            if (resp.status >= 200 && resp.status < 300) {\n                // We are complete.\n                this.txPosted = true;\n                this.chunkIndex = MAX_CHUNKS_IN_BODY;\n                return;\n            }\n            this.lastResponseError = error_1.getError(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        // Post the transaction with no data.\n        const resp = await this.api.post(`tx`, this.transaction);\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (!(resp.status >= 200 && resp.status < 300)) {\n            this.lastResponseError = error_1.getError(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        this.txPosted = true;\n    }\n}\nexports.TransactionUploader = TransactionUploader;\n//# sourceMappingURL=transaction-uploader.js.map"]},"metadata":{},"sourceType":"script"}