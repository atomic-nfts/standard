{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tag = void 0;\n\nconst ArweaveUtils = require(\"./utils\");\n\nconst deepHash_1 = require(\"./deepHash\");\n\nconst merkle_1 = require(\"./merkle\");\n\nclass BaseObject {\n  get(field, options) {\n    if (!Object.getOwnPropertyNames(this).includes(field)) {\n      throw new Error(`Field \"${field}\" is not a property of the Arweave Transaction class.`);\n    } // Handle fields that are Uint8Arrays.\n    // To maintain compat we encode them to b64url\n    // if decode option is not specificed.\n\n\n    if (this[field] instanceof Uint8Array) {\n      if (options && options.decode && options.string) {\n        return ArweaveUtils.bufferToString(this[field]);\n      }\n\n      if (options && options.decode && !options.string) {\n        return this[field];\n      }\n\n      return ArweaveUtils.bufferTob64Url(this[field]);\n    }\n\n    if (options && options.decode == true) {\n      if (options && options.string) {\n        return ArweaveUtils.b64UrlToString(this[field]);\n      }\n\n      return ArweaveUtils.b64UrlToBuffer(this[field]);\n    }\n\n    return this[field];\n  }\n\n}\n\nclass Tag extends BaseObject {\n  constructor(name, value, decode = false) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n\n}\n\nexports.Tag = Tag;\n\nclass Transaction extends BaseObject {\n  constructor(attributes = {}) {\n    super();\n    this.format = 2;\n    this.id = \"\";\n    this.last_tx = \"\";\n    this.owner = \"\";\n    this.tags = [];\n    this.target = \"\";\n    this.quantity = \"0\";\n    this.data_size = \"0\";\n    this.data = new Uint8Array();\n    this.data_root = \"\";\n    this.reward = \"0\";\n    this.signature = \"\";\n    Object.assign(this, attributes); // If something passes in a Tx that has been toJSON'ed and back,\n    // or where the data was filled in from /tx/data endpoint.\n    // data will be b64url encoded, so decode it.\n\n    if (typeof this.data === \"string\") {\n      this.data = ArweaveUtils.b64UrlToBuffer(this.data);\n    }\n\n    if (attributes.tags) {\n      this.tags = attributes.tags.map(tag => {\n        return new Tag(tag.name, tag.value);\n      });\n    }\n  }\n\n  addTag(name, value) {\n    this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));\n  }\n\n  toJSON() {\n    return {\n      format: this.format,\n      id: this.id,\n      last_tx: this.last_tx,\n      owner: this.owner,\n      tags: this.tags,\n      target: this.target,\n      quantity: this.quantity,\n      data: ArweaveUtils.bufferTob64Url(this.data),\n      data_size: this.data_size,\n      data_root: this.data_root,\n      data_tree: this.data_tree,\n      reward: this.reward,\n      signature: this.signature\n    };\n  }\n\n  setOwner(owner) {\n    this.owner = owner;\n  }\n\n  setSignature({\n    id,\n    owner,\n    tags,\n    signature\n  }) {\n    this.id = id;\n    this.owner = owner;\n    if (tags) this.tags = tags;\n    this.signature = signature;\n  }\n\n  async prepareChunks(data) {\n    // Note: we *do not* use `this.data`, the caller may be\n    // operating on a transaction with an zero length data field.\n    // This function computes the chunks for the data passed in and\n    // assigns the result to this transaction. It should not read the\n    // data *from* this transaction.\n    if (!this.chunks && data.byteLength > 0) {\n      this.chunks = await merkle_1.generateTransactionChunks(data);\n      this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);\n    }\n\n    if (!this.chunks && data.byteLength === 0) {\n      this.chunks = {\n        chunks: [],\n        data_root: new Uint8Array(),\n        proofs: []\n      };\n      this.data_root = \"\";\n    }\n  } // Returns a chunk in a format suitable for posting to /chunk.\n  // Similar to `prepareChunks()` this does not operate `this.data`,\n  // instead using the data passed in.\n\n\n  getChunk(idx, data) {\n    if (!this.chunks) {\n      throw new Error(`Chunks have not been prepared`);\n    }\n\n    const proof = this.chunks.proofs[idx];\n    const chunk = this.chunks.chunks[idx];\n    return {\n      data_root: this.data_root,\n      data_size: this.data_size,\n      data_path: ArweaveUtils.bufferTob64Url(proof.proof),\n      offset: proof.offset.toString(),\n      chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))\n    };\n  }\n\n  async getSignatureData() {\n    switch (this.format) {\n      case 1:\n        let tags = this.tags.reduce((accumulator, tag) => {\n          return ArweaveUtils.concatBuffers([accumulator, tag.get(\"name\", {\n            decode: true,\n            string: false\n          }), tag.get(\"value\", {\n            decode: true,\n            string: false\n          })]);\n        }, new Uint8Array());\n        return ArweaveUtils.concatBuffers([this.get(\"owner\", {\n          decode: true,\n          string: false\n        }), this.get(\"target\", {\n          decode: true,\n          string: false\n        }), this.get(\"data\", {\n          decode: true,\n          string: false\n        }), ArweaveUtils.stringToBuffer(this.quantity), ArweaveUtils.stringToBuffer(this.reward), this.get(\"last_tx\", {\n          decode: true,\n          string: false\n        }), tags]);\n\n      case 2:\n        await this.prepareChunks(this.data);\n        const tagList = this.tags.map(tag => [tag.get(\"name\", {\n          decode: true,\n          string: false\n        }), tag.get(\"value\", {\n          decode: true,\n          string: false\n        })]);\n        return await deepHash_1.default([ArweaveUtils.stringToBuffer(this.format.toString()), this.get(\"owner\", {\n          decode: true,\n          string: false\n        }), this.get(\"target\", {\n          decode: true,\n          string: false\n        }), ArweaveUtils.stringToBuffer(this.quantity), ArweaveUtils.stringToBuffer(this.reward), this.get(\"last_tx\", {\n          decode: true,\n          string: false\n        }), tagList, ArweaveUtils.stringToBuffer(this.data_size), this.get(\"data_root\", {\n          decode: true,\n          string: false\n        })]);\n\n      default:\n        throw new Error(`Unexpected transaction format: ${this.format}`);\n    }\n  }\n\n}\n\nexports.default = Transaction;","map":{"version":3,"sources":["../../../../src/common/lib/transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tag = void 0;\nconst ArweaveUtils = require(\"./utils\");\nconst deepHash_1 = require(\"./deepHash\");\nconst merkle_1 = require(\"./merkle\");\nclass BaseObject {\n    get(field, options) {\n        if (!Object.getOwnPropertyNames(this).includes(field)) {\n            throw new Error(`Field \"${field}\" is not a property of the Arweave Transaction class.`);\n        }\n        // Handle fields that are Uint8Arrays.\n        // To maintain compat we encode them to b64url\n        // if decode option is not specificed.\n        if (this[field] instanceof Uint8Array) {\n            if (options && options.decode && options.string) {\n                return ArweaveUtils.bufferToString(this[field]);\n            }\n            if (options && options.decode && !options.string) {\n                return this[field];\n            }\n            return ArweaveUtils.bufferTob64Url(this[field]);\n        }\n        if (options && options.decode == true) {\n            if (options && options.string) {\n                return ArweaveUtils.b64UrlToString(this[field]);\n            }\n            return ArweaveUtils.b64UrlToBuffer(this[field]);\n        }\n        return this[field];\n    }\n}\nclass Tag extends BaseObject {\n    constructor(name, value, decode = false) {\n        super();\n        this.name = name;\n        this.value = value;\n    }\n}\nexports.Tag = Tag;\nclass Transaction extends BaseObject {\n    constructor(attributes = {}) {\n        super();\n        this.format = 2;\n        this.id = \"\";\n        this.last_tx = \"\";\n        this.owner = \"\";\n        this.tags = [];\n        this.target = \"\";\n        this.quantity = \"0\";\n        this.data_size = \"0\";\n        this.data = new Uint8Array();\n        this.data_root = \"\";\n        this.reward = \"0\";\n        this.signature = \"\";\n        Object.assign(this, attributes);\n        // If something passes in a Tx that has been toJSON'ed and back,\n        // or where the data was filled in from /tx/data endpoint.\n        // data will be b64url encoded, so decode it.\n        if (typeof this.data === \"string\") {\n            this.data = ArweaveUtils.b64UrlToBuffer(this.data);\n        }\n        if (attributes.tags) {\n            this.tags = attributes.tags.map((tag) => {\n                return new Tag(tag.name, tag.value);\n            });\n        }\n    }\n    addTag(name, value) {\n        this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));\n    }\n    toJSON() {\n        return {\n            format: this.format,\n            id: this.id,\n            last_tx: this.last_tx,\n            owner: this.owner,\n            tags: this.tags,\n            target: this.target,\n            quantity: this.quantity,\n            data: ArweaveUtils.bufferTob64Url(this.data),\n            data_size: this.data_size,\n            data_root: this.data_root,\n            data_tree: this.data_tree,\n            reward: this.reward,\n            signature: this.signature,\n        };\n    }\n    setOwner(owner) {\n        this.owner = owner;\n    }\n    setSignature({ id, owner, tags, signature, }) {\n        this.id = id;\n        this.owner = owner;\n        if (tags)\n            this.tags = tags;\n        this.signature = signature;\n    }\n    async prepareChunks(data) {\n        // Note: we *do not* use `this.data`, the caller may be\n        // operating on a transaction with an zero length data field.\n        // This function computes the chunks for the data passed in and\n        // assigns the result to this transaction. It should not read the\n        // data *from* this transaction.\n        if (!this.chunks && data.byteLength > 0) {\n            this.chunks = await merkle_1.generateTransactionChunks(data);\n            this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);\n        }\n        if (!this.chunks && data.byteLength === 0) {\n            this.chunks = {\n                chunks: [],\n                data_root: new Uint8Array(),\n                proofs: [],\n            };\n            this.data_root = \"\";\n        }\n    }\n    // Returns a chunk in a format suitable for posting to /chunk.\n    // Similar to `prepareChunks()` this does not operate `this.data`,\n    // instead using the data passed in.\n    getChunk(idx, data) {\n        if (!this.chunks) {\n            throw new Error(`Chunks have not been prepared`);\n        }\n        const proof = this.chunks.proofs[idx];\n        const chunk = this.chunks.chunks[idx];\n        return {\n            data_root: this.data_root,\n            data_size: this.data_size,\n            data_path: ArweaveUtils.bufferTob64Url(proof.proof),\n            offset: proof.offset.toString(),\n            chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange)),\n        };\n    }\n    async getSignatureData() {\n        switch (this.format) {\n            case 1:\n                let tags = this.tags.reduce((accumulator, tag) => {\n                    return ArweaveUtils.concatBuffers([\n                        accumulator,\n                        tag.get(\"name\", { decode: true, string: false }),\n                        tag.get(\"value\", { decode: true, string: false }),\n                    ]);\n                }, new Uint8Array());\n                return ArweaveUtils.concatBuffers([\n                    this.get(\"owner\", { decode: true, string: false }),\n                    this.get(\"target\", { decode: true, string: false }),\n                    this.get(\"data\", { decode: true, string: false }),\n                    ArweaveUtils.stringToBuffer(this.quantity),\n                    ArweaveUtils.stringToBuffer(this.reward),\n                    this.get(\"last_tx\", { decode: true, string: false }),\n                    tags,\n                ]);\n            case 2:\n                await this.prepareChunks(this.data);\n                const tagList = this.tags.map((tag) => [\n                    tag.get(\"name\", { decode: true, string: false }),\n                    tag.get(\"value\", { decode: true, string: false }),\n                ]);\n                return await deepHash_1.default([\n                    ArweaveUtils.stringToBuffer(this.format.toString()),\n                    this.get(\"owner\", { decode: true, string: false }),\n                    this.get(\"target\", { decode: true, string: false }),\n                    ArweaveUtils.stringToBuffer(this.quantity),\n                    ArweaveUtils.stringToBuffer(this.reward),\n                    this.get(\"last_tx\", { decode: true, string: false }),\n                    tagList,\n                    ArweaveUtils.stringToBuffer(this.data_size),\n                    this.get(\"data_root\", { decode: true, string: false }),\n                ]);\n            default:\n                throw new Error(`Unexpected transaction format: ${this.format}`);\n        }\n    }\n}\nexports.default = Transaction;\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}