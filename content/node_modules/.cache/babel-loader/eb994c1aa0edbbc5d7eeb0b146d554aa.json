{"ast":null,"code":"\"use strict\"; // The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = require(\"./compile.js\");\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"];\n  var vars = [];\n  var thunkName = proc.funcName + \"_cwise_thunk\"; //Build thunk\n\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"));\n  var typesig = [];\n  var string_typesig = [];\n  var proc_args = [[\"array\", proc.arrayArgs[0], \".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n  Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? \",\" + proc.arrayBlockIndices[0] + \")\" : \")\"].join(\"\")];\n  var shapeLengthConditions = [],\n      shapeConditions = []; // Process array arguments\n\n  for (var i = 0; i < proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i];\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\", \"r\", j, \"=array\", j, \".order\"].join(\"\"));\n    typesig.push(\"t\" + j);\n    typesig.push(\"r\" + j);\n    string_typesig.push(\"t\" + j);\n    string_typesig.push(\"r\" + j + \".join()\");\n    proc_args.push(\"array\" + j + \".data\");\n    proc_args.push(\"array\" + j + \".stride\");\n    proc_args.push(\"array\" + j + \".offset|0\");\n\n    if (i > 0) {\n      // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[i]) + \"]\");\n    }\n  } // Check for shape equality\n\n\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\");\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\");\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\");\n    code.push(\"}\");\n  } // Process scalar arguments\n\n\n  for (var i = 0; i < proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i]);\n  } // Check for cached function (and if not present, generate it)\n\n\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"));\n  vars.push(\"proc=CACHED[type]\");\n  code.push(\"var \" + vars.join(\",\"));\n  code.push([\"if(!proc){\", \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\", \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"));\n\n  if (proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\");\n  } //Compile thunk\n\n\n  var thunk = new Function(\"compile\", code.join(\"\\n\"));\n  return thunk(compile.bind(undefined, proc));\n}\n\nmodule.exports = createThunk;","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/cwise-compiler/lib/thunk.js"],"names":["compile","require","createThunk","proc","code","vars","thunkName","funcName","push","shimArgs","join","typesig","string_typesig","proc_args","arrayArgs","Math","max","arrayBlockIndices","shapeLengthConditions","shapeConditions","i","length","j","abs","scalarArgs","debug","console","log","thunk","Function","bind","undefined","module","exports"],"mappings":"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","sourcesContent":["\"use strict\"\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = require(\"./compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\n  var shapeLengthConditions = [], shapeConditions = []\n  // Process array arguments\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\n    code.push(\"}\")\n  }\n  // Process scalar arguments\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n"]},"metadata":{},"sourceType":"script"}