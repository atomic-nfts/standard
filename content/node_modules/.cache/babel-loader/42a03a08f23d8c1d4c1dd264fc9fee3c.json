{"ast":null,"code":"'use strict';\n\nvar interlaceUtils = require('./interlace');\n\nvar paethPredictor = require('./paeth-predictor');\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n\n  return byteWidth;\n}\n\nvar Filter = module.exports = function (bitmapInfo, dependencies) {\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n  this._imageIndex = 0;\n  this._images = [];\n\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  } else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  } // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n\n\n  if (depth === 8) {\n    this._xComparison = bpp;\n  } else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  } else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function () {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function (rawData, unfilteredLine, byteWidth) {\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function (rawData) {\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  } else {\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n  currentImage.lineIndex++;\n\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  } else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  } else {\n    this._lastLine = null;\n    this.complete();\n  }\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/pngjs-nozlib/lib/filter-parse.js"],"names":["interlaceUtils","require","paethPredictor","getByteWidth","width","bpp","depth","byteWidth","Math","ceil","Filter","module","exports","bitmapInfo","dependencies","height","interlace","read","write","complete","_imageIndex","_images","passes","getImagePasses","i","length","push","lineIndex","_xComparison","prototype","start","_reverseFilterLine","bind","_unFilterType1","rawData","unfilteredLine","xComparison","xBiggerThan","x","rawByte","f1Left","_unFilterType2","lastLine","_lastLine","f2Up","_unFilterType3","f3Up","f3Left","f3Add","floor","_unFilterType4","f4Up","f4Left","f4UpLeft","f4Add","filter","currentImage","slice","Buffer","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nvar interlaceUtils = require('./interlace');\nvar paethPredictor = require('./paeth-predictor');\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\n\nvar Filter = module.exports = function(bitmapInfo, dependencies) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  }\n  else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  }\n  else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  }\n  else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function() {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {\n\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function(rawData) {\n\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  }\n  else {\n\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  }\n  else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  }\n  else {\n    this._lastLine = null;\n    this.complete();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}