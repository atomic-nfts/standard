{"ast":null,"code":"import { decodeAsn1, encodeAsn1 } from '../../util/asn1-encoder';\nimport { RsaPrivateKey, RsaPublicKey, EcPrivateKey } from '../../util/asn1-entities';\nimport { decodeEcPoint, encodeEcPoint, validateEcD } from '../../util/ec';\nimport { UnsupportedAlgorithmError } from '../../util/errors';\nimport { OIDS, FLIPPED_OIDS } from '../../util/oids';\nimport { KEY_TYPES } from '../../util/key-types';\nexport const SUPPORTED_KEY_TYPES = {\n  private: ['rsa', 'ec'],\n  public: ['rsa']\n};\nexport const decomposeRsaPrivateKey = rsaPrivateKeyAsn1 => {\n  const {\n    version,\n    ...keyData\n  } = decodeAsn1(rsaPrivateKeyAsn1, RsaPrivateKey);\n  return {\n    keyAlgorithm: {\n      id: 'rsa-encryption'\n    },\n    keyData\n  };\n};\nexport const composeRsaPrivateKey = (keyAlgorithm, keyData) => {\n  const otherPrimeInfos = keyData.otherPrimeInfos;\n  const hasMultiplePrimes = otherPrimeInfos && otherPrimeInfos.length > 0;\n  const rsaPrivateKey = { ...keyData,\n    version: hasMultiplePrimes ? 1 : 0,\n    otherPrimeInfos: hasMultiplePrimes ? otherPrimeInfos : undefined\n  };\n  return encodeAsn1(rsaPrivateKey, RsaPrivateKey);\n};\nexport const decomposeRsaPublicKey = rsaPublicKeyAsn1 => {\n  const {\n    version,\n    ...keyData\n  } = decodeAsn1(rsaPublicKeyAsn1, RsaPublicKey);\n  return {\n    keyAlgorithm: {\n      id: 'rsa-encryption'\n    },\n    keyData\n  };\n};\nexport const composeRsaPublicKey = (keyAlgorithm, keyData) => encodeAsn1(keyData, RsaPublicKey);\nexport const decomposeEcPrivateKey = ecPrivateKeyAsn1 => {\n  const ecPrivateKey = decodeAsn1(ecPrivateKeyAsn1, EcPrivateKey); // Validate parameters & publicKey\n\n  /* istanbul ignore if */\n\n  if (!ecPrivateKey.parameters) {\n    throw new UnsupportedAlgorithmError('Missing parameters from ECPrivateKey');\n  }\n  /* istanbul ignore if */\n\n\n  if (ecPrivateKey.parameters.type !== 'namedCurve') {\n    throw new UnsupportedAlgorithmError('Only EC named curves are supported');\n  }\n  /* istanbul ignore if */\n\n\n  if (!ecPrivateKey.publicKey) {\n    throw new UnsupportedAlgorithmError('Missing publicKey from ECPrivateKey');\n  } // Ensure that the named curve is supported\n\n\n  const namedCurve = OIDS[ecPrivateKey.parameters.value];\n\n  if (!namedCurve) {\n    throw new UnsupportedAlgorithmError(`Unsupported named curve OID '${ecPrivateKey.parameters.value}'`);\n  } // Validate & encode point (public key)\n\n\n  const {\n    x,\n    y\n  } = decodeEcPoint(namedCurve, ecPrivateKey.publicKey.data);\n  return {\n    keyAlgorithm: {\n      id: 'ec-public-key',\n      namedCurve\n    },\n    keyData: {\n      d: ecPrivateKey.privateKey,\n      x,\n      y\n    }\n  };\n};\nexport const composeEcPrivateKey = (keyAlgorithm, keyData) => {\n  // Validate named curve\n  const namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];\n\n  if (!namedCurveOid) {\n    throw new UnsupportedAlgorithmError(`Unsupported named curve '${keyAlgorithm.namedCurve}'`);\n  } // Validate D value (private key)\n\n\n  const privateKey = validateEcD(keyAlgorithm.namedCurve, keyData.d); // Encode point (public key)\n\n  const publicKey = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);\n  const ecPrivateKey = {\n    version: 1,\n    privateKey,\n    parameters: {\n      type: 'namedCurve',\n      value: namedCurveOid\n    },\n    publicKey: {\n      unused: 0,\n      data: publicKey\n    }\n  };\n  return encodeAsn1(ecPrivateKey, EcPrivateKey);\n};\nexport const decomposeRawPrivateKey = (keyType, privateKeyAsn1) => {\n  switch (keyType) {\n    case 'rsa':\n      return decomposeRsaPrivateKey(privateKeyAsn1);\n\n    case 'ec':\n      return decomposeEcPrivateKey(privateKeyAsn1);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key type '${keyType}'`);\n  }\n};\nexport const composeRawPrivateKey = (keyAlgorithm, keyData) => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n\n  switch (keyType) {\n    case 'rsa':\n      return composeRsaPrivateKey(keyAlgorithm, keyData);\n\n    case 'ec':\n      return composeEcPrivateKey(keyAlgorithm, keyData);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);\n  }\n};\nexport const decomposeRawPublicKey = (keyType, publicKeyAsn1) => {\n  switch (keyType) {\n    case 'rsa':\n      return decomposeRsaPublicKey(publicKeyAsn1);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key type '${keyType}'`);\n  }\n};\nexport const composeRawPublicKey = (keyAlgorithm, keyData) => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n\n  switch (keyType) {\n    case 'rsa':\n      return composeRsaPublicKey(keyAlgorithm, keyData);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);\n  }\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/formats/raw/keys.js"],"names":["decodeAsn1","encodeAsn1","RsaPrivateKey","RsaPublicKey","EcPrivateKey","decodeEcPoint","encodeEcPoint","validateEcD","UnsupportedAlgorithmError","OIDS","FLIPPED_OIDS","KEY_TYPES","SUPPORTED_KEY_TYPES","private","public","decomposeRsaPrivateKey","rsaPrivateKeyAsn1","version","keyData","keyAlgorithm","id","composeRsaPrivateKey","otherPrimeInfos","hasMultiplePrimes","length","rsaPrivateKey","undefined","decomposeRsaPublicKey","rsaPublicKeyAsn1","composeRsaPublicKey","decomposeEcPrivateKey","ecPrivateKeyAsn1","ecPrivateKey","parameters","type","publicKey","namedCurve","value","x","y","data","d","privateKey","composeEcPrivateKey","namedCurveOid","unused","decomposeRawPrivateKey","keyType","privateKeyAsn1","composeRawPrivateKey","decomposeRawPublicKey","publicKeyAsn1","composeRawPublicKey"],"mappings":"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","sourcesContent":["import { decodeAsn1, encodeAsn1 } from '../../util/asn1-encoder';\nimport { RsaPrivateKey, RsaPublicKey, EcPrivateKey } from '../../util/asn1-entities';\nimport { decodeEcPoint, encodeEcPoint, validateEcD } from '../../util/ec';\nimport { UnsupportedAlgorithmError } from '../../util/errors';\nimport { OIDS, FLIPPED_OIDS } from '../../util/oids';\nimport { KEY_TYPES } from '../../util/key-types';\nexport const SUPPORTED_KEY_TYPES = {\n  private: ['rsa', 'ec'],\n  public: ['rsa']\n};\nexport const decomposeRsaPrivateKey = rsaPrivateKeyAsn1 => {\n  const {\n    version,\n    ...keyData\n  } = decodeAsn1(rsaPrivateKeyAsn1, RsaPrivateKey);\n  return {\n    keyAlgorithm: {\n      id: 'rsa-encryption'\n    },\n    keyData\n  };\n};\nexport const composeRsaPrivateKey = (keyAlgorithm, keyData) => {\n  const otherPrimeInfos = keyData.otherPrimeInfos;\n  const hasMultiplePrimes = otherPrimeInfos && otherPrimeInfos.length > 0;\n  const rsaPrivateKey = { ...keyData,\n    version: hasMultiplePrimes ? 1 : 0,\n    otherPrimeInfos: hasMultiplePrimes ? otherPrimeInfos : undefined\n  };\n  return encodeAsn1(rsaPrivateKey, RsaPrivateKey);\n};\nexport const decomposeRsaPublicKey = rsaPublicKeyAsn1 => {\n  const {\n    version,\n    ...keyData\n  } = decodeAsn1(rsaPublicKeyAsn1, RsaPublicKey);\n  return {\n    keyAlgorithm: {\n      id: 'rsa-encryption'\n    },\n    keyData\n  };\n};\nexport const composeRsaPublicKey = (keyAlgorithm, keyData) => encodeAsn1(keyData, RsaPublicKey);\nexport const decomposeEcPrivateKey = ecPrivateKeyAsn1 => {\n  const ecPrivateKey = decodeAsn1(ecPrivateKeyAsn1, EcPrivateKey); // Validate parameters & publicKey\n\n  /* istanbul ignore if */\n\n  if (!ecPrivateKey.parameters) {\n    throw new UnsupportedAlgorithmError('Missing parameters from ECPrivateKey');\n  }\n  /* istanbul ignore if */\n\n\n  if (ecPrivateKey.parameters.type !== 'namedCurve') {\n    throw new UnsupportedAlgorithmError('Only EC named curves are supported');\n  }\n  /* istanbul ignore if */\n\n\n  if (!ecPrivateKey.publicKey) {\n    throw new UnsupportedAlgorithmError('Missing publicKey from ECPrivateKey');\n  } // Ensure that the named curve is supported\n\n\n  const namedCurve = OIDS[ecPrivateKey.parameters.value];\n\n  if (!namedCurve) {\n    throw new UnsupportedAlgorithmError(`Unsupported named curve OID '${ecPrivateKey.parameters.value}'`);\n  } // Validate & encode point (public key)\n\n\n  const {\n    x,\n    y\n  } = decodeEcPoint(namedCurve, ecPrivateKey.publicKey.data);\n  return {\n    keyAlgorithm: {\n      id: 'ec-public-key',\n      namedCurve\n    },\n    keyData: {\n      d: ecPrivateKey.privateKey,\n      x,\n      y\n    }\n  };\n};\nexport const composeEcPrivateKey = (keyAlgorithm, keyData) => {\n  // Validate named curve\n  const namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];\n\n  if (!namedCurveOid) {\n    throw new UnsupportedAlgorithmError(`Unsupported named curve '${keyAlgorithm.namedCurve}'`);\n  } // Validate D value (private key)\n\n\n  const privateKey = validateEcD(keyAlgorithm.namedCurve, keyData.d); // Encode point (public key)\n\n  const publicKey = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);\n  const ecPrivateKey = {\n    version: 1,\n    privateKey,\n    parameters: {\n      type: 'namedCurve',\n      value: namedCurveOid\n    },\n    publicKey: {\n      unused: 0,\n      data: publicKey\n    }\n  };\n  return encodeAsn1(ecPrivateKey, EcPrivateKey);\n};\nexport const decomposeRawPrivateKey = (keyType, privateKeyAsn1) => {\n  switch (keyType) {\n    case 'rsa':\n      return decomposeRsaPrivateKey(privateKeyAsn1);\n\n    case 'ec':\n      return decomposeEcPrivateKey(privateKeyAsn1);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key type '${keyType}'`);\n  }\n};\nexport const composeRawPrivateKey = (keyAlgorithm, keyData) => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n\n  switch (keyType) {\n    case 'rsa':\n      return composeRsaPrivateKey(keyAlgorithm, keyData);\n\n    case 'ec':\n      return composeEcPrivateKey(keyAlgorithm, keyData);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);\n  }\n};\nexport const decomposeRawPublicKey = (keyType, publicKeyAsn1) => {\n  switch (keyType) {\n    case 'rsa':\n      return decomposeRsaPublicKey(publicKeyAsn1);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key type '${keyType}'`);\n  }\n};\nexport const composeRawPublicKey = (keyAlgorithm, keyData) => {\n  const keyType = KEY_TYPES[keyAlgorithm.id];\n\n  switch (keyType) {\n    case 'rsa':\n      return composeRsaPublicKey(keyAlgorithm, keyData);\n\n    default:\n      throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);\n  }\n};"]},"metadata":{},"sourceType":"module"}