{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst error_1 = require(\"./lib/error\");\n\nconst ArweaveUtils = require(\"./lib/utils\");\n\nclass Chunks {\n  constructor(api) {\n    this.api = api;\n  }\n\n  async getTransactionOffset(id) {\n    const resp = await this.api.get(`tx/${id}/offset`);\n\n    if (resp.status === 200) {\n      return resp.data;\n    }\n\n    throw new Error(`Unable to get transaction offset: ${error_1.getError(resp)}`);\n  }\n\n  async getChunk(offset) {\n    const resp = await this.api.get(`chunk/${offset}`);\n\n    if (resp.status === 200) {\n      return resp.data;\n    }\n\n    throw new Error(`Unable to get chunk: ${error_1.getError(resp)}`);\n  }\n\n  async getChunkData(offset) {\n    const chunk = await this.getChunk(offset);\n    const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n    return buf;\n  }\n\n  firstChunkOffset(offsetResponse) {\n    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n  }\n\n  async downloadChunkedData(id) {\n    const offsetResponse = await this.getTransactionOffset(id);\n    const size = parseInt(offsetResponse.size);\n    const endOffset = parseInt(offsetResponse.offset);\n    const startOffset = endOffset - size + 1;\n    const data = new Uint8Array(size);\n    let byte = 0;\n\n    while (startOffset + byte < endOffset) {\n      const chunkData = await this.getChunkData(startOffset + byte);\n      data.set(chunkData, byte);\n      byte += chunkData.length;\n    }\n\n    return data;\n  }\n\n}\n\nexports.default = Chunks;","map":{"version":3,"sources":["../../../src/common/chunks.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAaA,MAAqB,MAArB,CAA2B;AACzB,EAAA,WAAA,CAAoB,GAApB,EAA4B;AAAR,SAAA,GAAA,GAAA,GAAA;AAAY;;AAEN,QAApB,oBAAoB,CAAC,EAAD,EAAW;AACnC,UAAM,IAAI,GAAG,MAAM,KAAK,GAAL,CAAS,GAAT,CAAa,MAAM,EAAE,SAArB,CAAnB;;AACA,QAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,aAAO,IAAI,CAAC,IAAZ;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,qCAAqC,OAAA,CAAA,QAAA,CAAS,IAAT,CAAc,EAA7D,CAAN;AACD;;AAEa,QAAR,QAAQ,CACZ,MADY,EACoB;AAEhC,UAAM,IAAI,GAAG,MAAM,KAAK,GAAL,CAAS,GAAT,CAAa,SAAS,MAAM,EAA5B,CAAnB;;AACA,QAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,aAAO,IAAI,CAAC,IAAZ;AACD;;AACD,UAAM,IAAI,KAAJ,CAAU,wBAAwB,OAAA,CAAA,QAAA,CAAS,IAAT,CAAc,EAAhD,CAAN;AACD;;AAEiB,QAAZ,YAAY,CAAC,MAAD,EAAiC;AACjD,UAAM,KAAK,GAAG,MAAM,KAAK,QAAL,CAAc,MAAd,CAApB;AACA,UAAM,GAAG,GAAG,YAAY,CAAC,cAAb,CAA4B,KAAK,CAAC,KAAlC,CAAZ;AACA,WAAO,GAAP;AACD;;AAED,EAAA,gBAAgB,CAAC,cAAD,EAA0C;AACxD,WAAO,QAAQ,CAAC,cAAc,CAAC,MAAhB,CAAR,GAAkC,QAAQ,CAAC,cAAc,CAAC,IAAhB,CAA1C,GAAkE,CAAzE;AACD;;AAEwB,QAAnB,mBAAmB,CAAC,EAAD,EAAW;AAClC,UAAM,cAAc,GAAG,MAAM,KAAK,oBAAL,CAA0B,EAA1B,CAA7B;AAEA,UAAM,IAAI,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAhB,CAArB;AACA,UAAM,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,MAAhB,CAA1B;AACA,UAAM,WAAW,GAAG,SAAS,GAAG,IAAZ,GAAmB,CAAvC;AAEA,UAAM,IAAI,GAAG,IAAI,UAAJ,CAAe,IAAf,CAAb;AACA,QAAI,IAAI,GAAG,CAAX;;AAEA,WAAO,WAAW,GAAG,IAAd,GAAqB,SAA5B,EAAuC;AACrC,YAAM,SAAS,GAAG,MAAM,KAAK,YAAL,CAAkB,WAAW,GAAG,IAAhC,CAAxB;AACA,MAAA,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,IAApB;AACA,MAAA,IAAI,IAAI,SAAS,CAAC,MAAlB;AACD;;AAED,WAAO,IAAP;AACD;;AAhDwB;;AAA3B,OAAA,CAAA,OAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = require(\"./lib/error\");\nconst ArweaveUtils = require(\"./lib/utils\");\nclass Chunks {\n    constructor(api) {\n        this.api = api;\n    }\n    async getTransactionOffset(id) {\n        const resp = await this.api.get(`tx/${id}/offset`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get transaction offset: ${error_1.getError(resp)}`);\n    }\n    async getChunk(offset) {\n        const resp = await this.api.get(`chunk/${offset}`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get chunk: ${error_1.getError(resp)}`);\n    }\n    async getChunkData(offset) {\n        const chunk = await this.getChunk(offset);\n        const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n        return buf;\n    }\n    firstChunkOffset(offsetResponse) {\n        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n    }\n    async downloadChunkedData(id) {\n        const offsetResponse = await this.getTransactionOffset(id);\n        const size = parseInt(offsetResponse.size);\n        const endOffset = parseInt(offsetResponse.offset);\n        const startOffset = endOffset - size + 1;\n        const data = new Uint8Array(size);\n        let byte = 0;\n        while (startOffset + byte < endOffset) {\n            const chunkData = await this.getChunkData(startOffset + byte);\n            data.set(chunkData, byte);\n            byte += chunkData.length;\n        }\n        return data;\n    }\n}\nexports.default = Chunks;\n//# sourceMappingURL=chunks.js.map"]},"metadata":{},"sourceType":"script"}