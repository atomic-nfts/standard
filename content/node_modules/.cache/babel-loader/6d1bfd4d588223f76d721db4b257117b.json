{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ArweaveUtils = require(\"../utils\");\n\nclass WebCryptoDriver {\n  constructor() {\n    this.keyLength = 4096;\n    this.publicExponent = 0x10001;\n    this.hashAlgorithm = \"sha256\";\n\n    if (!this.detectWebCrypto()) {\n      throw new Error(\"SubtleCrypto not available!\");\n    }\n\n    this.driver = crypto.subtle;\n  }\n\n  async generateJWK() {\n    let cryptoKey = await this.driver.generateKey({\n      name: \"RSA-PSS\",\n      modulusLength: 4096,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, true, [\"sign\"]);\n    let jwk = await this.driver.exportKey(\"jwk\", cryptoKey.privateKey);\n    return {\n      kty: jwk.kty,\n      e: jwk.e,\n      n: jwk.n,\n      d: jwk.d,\n      p: jwk.p,\n      q: jwk.q,\n      dp: jwk.dp,\n      dq: jwk.dq,\n      qi: jwk.qi\n    };\n  }\n\n  async sign(jwk, data, {\n    saltLength\n  } = {}) {\n    let signature = await this.driver.sign({\n      name: \"RSA-PSS\",\n      saltLength: 32\n    }, await this.jwkToCryptoKey(jwk), data);\n    return new Uint8Array(signature);\n  }\n\n  async hash(data, algorithm = \"SHA-256\") {\n    let digest = await this.driver.digest(algorithm, data);\n    return new Uint8Array(digest);\n  }\n\n  async verify(publicModulus, data, signature) {\n    const publicKey = {\n      kty: \"RSA\",\n      e: \"AQAB\",\n      n: publicModulus\n    };\n    const key = await this.jwkToPublicCryptoKey(publicKey);\n    const verifyWith32 = this.driver.verify({\n      name: \"RSA-PSS\",\n      saltLength: 32\n    }, key, signature, data);\n    const verifyWith0 = this.driver.verify({\n      name: \"RSA-PSS\",\n      saltLength: 0\n    }, key, signature, data);\n    return verifyWith32 || verifyWith0;\n  }\n\n  async jwkToCryptoKey(jwk) {\n    return this.driver.importKey(\"jwk\", jwk, {\n      name: \"RSA-PSS\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, false, [\"sign\"]);\n  }\n\n  async jwkToPublicCryptoKey(publicJwk) {\n    return this.driver.importKey(\"jwk\", publicJwk, {\n      name: \"RSA-PSS\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, false, [\"verify\"]);\n  }\n\n  detectWebCrypto() {\n    if (typeof crypto === \"undefined\") {\n      return false;\n    }\n\n    const subtle = crypto === null || crypto === void 0 ? void 0 : crypto.subtle;\n\n    if (subtle === undefined) {\n      return false;\n    }\n\n    const names = [\"generateKey\", \"importKey\", \"exportKey\", \"digest\", \"sign\"];\n    return names.every(name => typeof subtle[name] === \"function\");\n  }\n\n  async encrypt(data, key, salt) {\n    const initialKey = await this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n      name: \"PBKDF2\",\n      length: 32\n    }, false, [\"deriveKey\"]); // const salt = ArweaveUtils.stringToBuffer(\"salt\");\n    // create a random string for deriving the key\n    // const salt = this.driver.randomBytes(16).toString('hex');\n\n    const derivedkey = await this.driver.deriveKey({\n      name: \"PBKDF2\",\n      salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer(\"salt\"),\n      iterations: 100000,\n      hash: \"SHA-256\"\n    }, initialKey, {\n      name: \"AES-CBC\",\n      length: 256\n    }, false, [\"encrypt\", \"decrypt\"]);\n    const iv = new Uint8Array(16);\n    crypto.getRandomValues(iv);\n    const encryptedData = await this.driver.encrypt({\n      name: \"AES-CBC\",\n      iv: iv\n    }, derivedkey, data);\n    return ArweaveUtils.concatBuffers([iv, encryptedData]);\n  }\n\n  async decrypt(encrypted, key, salt) {\n    const initialKey = await this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n      name: \"PBKDF2\",\n      length: 32\n    }, false, [\"deriveKey\"]); // const salt = ArweaveUtils.stringToBuffer(\"pepper\");\n\n    const derivedkey = await this.driver.deriveKey({\n      name: \"PBKDF2\",\n      salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer(\"salt\"),\n      iterations: 100000,\n      hash: \"SHA-256\"\n    }, initialKey, {\n      name: \"AES-CBC\",\n      length: 256\n    }, false, [\"encrypt\", \"decrypt\"]);\n    const iv = encrypted.slice(0, 16);\n    const data = await this.driver.decrypt({\n      name: \"AES-CBC\",\n      iv: iv\n    }, derivedkey, encrypted.slice(16)); // We're just using concat to convert from an array buffer to uint8array\n\n    return ArweaveUtils.concatBuffers([data]);\n  }\n\n}\n\nexports.default = WebCryptoDriver;","map":{"version":3,"sources":["../../../../../src/common/lib/crypto/webcrypto-driver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArweaveUtils = require(\"../utils\");\nclass WebCryptoDriver {\n    constructor() {\n        this.keyLength = 4096;\n        this.publicExponent = 0x10001;\n        this.hashAlgorithm = \"sha256\";\n        if (!this.detectWebCrypto()) {\n            throw new Error(\"SubtleCrypto not available!\");\n        }\n        this.driver = crypto.subtle;\n    }\n    async generateJWK() {\n        let cryptoKey = await this.driver.generateKey({\n            name: \"RSA-PSS\",\n            modulusLength: 4096,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n            hash: {\n                name: \"SHA-256\",\n            },\n        }, true, [\"sign\"]);\n        let jwk = await this.driver.exportKey(\"jwk\", cryptoKey.privateKey);\n        return {\n            kty: jwk.kty,\n            e: jwk.e,\n            n: jwk.n,\n            d: jwk.d,\n            p: jwk.p,\n            q: jwk.q,\n            dp: jwk.dp,\n            dq: jwk.dq,\n            qi: jwk.qi,\n        };\n    }\n    async sign(jwk, data, { saltLength } = {}) {\n        let signature = await this.driver.sign({\n            name: \"RSA-PSS\",\n            saltLength: 32,\n        }, await this.jwkToCryptoKey(jwk), data);\n        return new Uint8Array(signature);\n    }\n    async hash(data, algorithm = \"SHA-256\") {\n        let digest = await this.driver.digest(algorithm, data);\n        return new Uint8Array(digest);\n    }\n    async verify(publicModulus, data, signature) {\n        const publicKey = {\n            kty: \"RSA\",\n            e: \"AQAB\",\n            n: publicModulus,\n        };\n        const key = await this.jwkToPublicCryptoKey(publicKey);\n        const verifyWith32 = this.driver.verify({\n            name: \"RSA-PSS\",\n            saltLength: 32,\n        }, key, signature, data);\n        const verifyWith0 = this.driver.verify({\n            name: \"RSA-PSS\",\n            saltLength: 0,\n        }, key, signature, data);\n        return verifyWith32 || verifyWith0;\n    }\n    async jwkToCryptoKey(jwk) {\n        return this.driver.importKey(\"jwk\", jwk, {\n            name: \"RSA-PSS\",\n            hash: {\n                name: \"SHA-256\",\n            },\n        }, false, [\"sign\"]);\n    }\n    async jwkToPublicCryptoKey(publicJwk) {\n        return this.driver.importKey(\"jwk\", publicJwk, {\n            name: \"RSA-PSS\",\n            hash: {\n                name: \"SHA-256\",\n            },\n        }, false, [\"verify\"]);\n    }\n    detectWebCrypto() {\n        if (typeof crypto === \"undefined\") {\n            return false;\n        }\n        const subtle = crypto === null || crypto === void 0 ? void 0 : crypto.subtle;\n        if (subtle === undefined) {\n            return false;\n        }\n        const names = [\n            \"generateKey\",\n            \"importKey\",\n            \"exportKey\",\n            \"digest\",\n            \"sign\",\n        ];\n        return names.every((name) => typeof subtle[name] === \"function\");\n    }\n    async encrypt(data, key, salt) {\n        const initialKey = await this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n            name: \"PBKDF2\",\n            length: 32,\n        }, false, [\"deriveKey\"]);\n        // const salt = ArweaveUtils.stringToBuffer(\"salt\");\n        // create a random string for deriving the key\n        // const salt = this.driver.randomBytes(16).toString('hex');\n        const derivedkey = await this.driver.deriveKey({\n            name: \"PBKDF2\",\n            salt: salt\n                ? ArweaveUtils.stringToBuffer(salt)\n                : ArweaveUtils.stringToBuffer(\"salt\"),\n            iterations: 100000,\n            hash: \"SHA-256\",\n        }, initialKey, {\n            name: \"AES-CBC\",\n            length: 256,\n        }, false, [\"encrypt\", \"decrypt\"]);\n        const iv = new Uint8Array(16);\n        crypto.getRandomValues(iv);\n        const encryptedData = await this.driver.encrypt({\n            name: \"AES-CBC\",\n            iv: iv,\n        }, derivedkey, data);\n        return ArweaveUtils.concatBuffers([iv, encryptedData]);\n    }\n    async decrypt(encrypted, key, salt) {\n        const initialKey = await this.driver.importKey(\"raw\", typeof key == \"string\" ? ArweaveUtils.stringToBuffer(key) : key, {\n            name: \"PBKDF2\",\n            length: 32,\n        }, false, [\"deriveKey\"]);\n        // const salt = ArweaveUtils.stringToBuffer(\"pepper\");\n        const derivedkey = await this.driver.deriveKey({\n            name: \"PBKDF2\",\n            salt: salt\n                ? ArweaveUtils.stringToBuffer(salt)\n                : ArweaveUtils.stringToBuffer(\"salt\"),\n            iterations: 100000,\n            hash: \"SHA-256\",\n        }, initialKey, {\n            name: \"AES-CBC\",\n            length: 256,\n        }, false, [\"encrypt\", \"decrypt\"]);\n        const iv = encrypted.slice(0, 16);\n        const data = await this.driver.decrypt({\n            name: \"AES-CBC\",\n            iv: iv,\n        }, derivedkey, encrypted.slice(16));\n        // We're just using concat to convert from an array buffer to uint8array\n        return ArweaveUtils.concatBuffers([data]);\n    }\n}\nexports.default = WebCryptoDriver;\n//# sourceMappingURL=webcrypto-driver.js.map"]},"metadata":{},"sourceType":"script"}