{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionUploader = void 0;\n\nconst transaction_1 = require(\"./transaction\");\n\nconst ArweaveUtils = require(\"./utils\");\n\nconst error_1 = require(\"./error\");\n\nconst merkle_1 = require(\"./merkle\"); // Maximum amount of chunks we will upload in the body.\n\n\nconst MAX_CHUNKS_IN_BODY = 1; // We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\n\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\"invalid_json\", \"chunk_too_big\", \"data_path_too_big\", \"offset_too_big\", \"data_size_too_big\", \"chunk_proof_ratio_not_attractive\", \"invalid_proof\"]; // Amount we will delay on receiving an error response but do want to continue.\n\nconst ERROR_DELAY = 1000 * 40;\n\nclass TransactionUploader {\n  constructor(api, transaction) {\n    this.api = api;\n    this.chunkIndex = 0;\n    this.txPosted = false;\n    this.lastRequestTimeEnd = 0;\n    this.totalErrors = 0; // Not serialized.\n\n    this.lastResponseStatus = 0;\n    this.lastResponseError = \"\";\n\n    if (!transaction.id) {\n      throw new Error(`Transaction is not signed`);\n    }\n\n    if (!transaction.chunks) {\n      throw new Error(`Transaction chunks not prepared`);\n    } // Make a copy of transaction, zeroing the data so we can serialize.\n\n\n    this.data = transaction.data;\n    this.transaction = new transaction_1.default(Object.assign({}, transaction, {\n      data: new Uint8Array(0)\n    }));\n  }\n\n  get isComplete() {\n    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;\n  }\n\n  get totalChunks() {\n    return this.transaction.chunks.chunks.length;\n  }\n\n  get uploadedChunks() {\n    return this.chunkIndex;\n  }\n\n  get pctComplete() {\n    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);\n  }\n  /**\n   * Uploads the next part of the transaction.\n   * On the first call this posts the transaction\n   * itself and on any subsequent calls uploads the\n   * next chunk until it completes.\n   */\n\n\n  async uploadChunk() {\n    if (this.isComplete) {\n      throw new Error(`Upload is already complete`);\n    }\n\n    if (this.lastResponseError !== \"\") {\n      this.totalErrors++;\n    } else {\n      this.totalErrors = 0;\n    } // We have been trying for about an hour receiving an\n    // error every time, so eventually bail.\n\n\n    if (this.totalErrors === 100) {\n      throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n    }\n\n    let delay = this.lastResponseError === \"\" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n\n    if (delay > 0) {\n      // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n      delay = delay - delay * Math.random() * 0.3;\n      await new Promise(res => setTimeout(res, delay));\n    }\n\n    this.lastResponseError = \"\";\n\n    if (!this.txPosted) {\n      await this.postTransaction();\n      return;\n    }\n\n    const chunk = this.transaction.getChunk(this.chunkIndex, this.data);\n    const chunkOk = await merkle_1.validatePath(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n\n    if (!chunkOk) {\n      throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n    } // Catch network errors and turn them into objects with status -1 and an error message.\n\n\n    const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch(e => {\n      console.error(e.message);\n      return {\n        status: -1,\n        data: {\n          error: e.message\n        }\n      };\n    });\n    this.lastRequestTimeEnd = Date.now();\n    this.lastResponseStatus = resp.status;\n\n    if (this.lastResponseStatus == 200) {\n      this.chunkIndex++;\n    } else {\n      this.lastResponseError = error_1.getError(resp);\n\n      if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n      }\n    }\n  }\n  /**\n   * Reconstructs an upload from its serialized state and data.\n   * Checks if data matches the expected data_root.\n   *\n   * @param serialized\n   * @param data\n   */\n\n\n  static async fromSerialized(api, serialized, data) {\n    if (!serialized || typeof serialized.chunkIndex !== \"number\" || typeof serialized.transaction !== \"object\") {\n      throw new Error(`Serialized object does not match expected format.`);\n    } // Everything looks ok, reconstruct the TransactionUpload,\n    // prepare the chunks again and verify the data_root matches\n\n\n    const upload = new TransactionUploader(api, new transaction_1.default(serialized.transaction)); // Copy the serialized upload information, and data passed in.\n\n    upload.chunkIndex = serialized.chunkIndex;\n    upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n    upload.lastResponseError = serialized.lastResponseError;\n    upload.lastResponseStatus = serialized.lastResponseStatus;\n    upload.txPosted = serialized.txPosted;\n    upload.data = data;\n    await upload.transaction.prepareChunks(data);\n\n    if (upload.transaction.data_root !== serialized.transaction.data_root) {\n      throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n    }\n\n    return upload;\n  }\n  /**\n   * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n   *\n   * @param api\n   * @param id\n   * @param data\n   */\n\n\n  static async fromTransactionId(api, id) {\n    const resp = await api.get(`tx/${id}`);\n\n    if (resp.status !== 200) {\n      throw new Error(`Tx ${id} not found: ${resp.status}`);\n    }\n\n    const transaction = resp.data;\n    transaction.data = new Uint8Array(0);\n    const serialized = {\n      txPosted: true,\n      chunkIndex: 0,\n      lastResponseError: \"\",\n      lastRequestTimeEnd: 0,\n      lastResponseStatus: 0,\n      transaction\n    };\n    return serialized;\n  }\n\n  toJSON() {\n    return {\n      chunkIndex: this.chunkIndex,\n      transaction: this.transaction,\n      lastRequestTimeEnd: this.lastRequestTimeEnd,\n      lastResponseStatus: this.lastResponseStatus,\n      lastResponseError: this.lastResponseError,\n      txPosted: this.txPosted\n    };\n  } // POST to /tx\n\n\n  async postTransaction() {\n    const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n\n    if (uploadInBody) {\n      // Post the transaction with data.\n      this.transaction.data = this.data;\n      const resp = await this.api.post(`tx`, this.transaction).catch(e => {\n        console.error(e);\n        return {\n          status: -1,\n          data: {\n            error: e.message\n          }\n        };\n      });\n      this.lastRequestTimeEnd = Date.now();\n      this.lastResponseStatus = resp.status;\n      this.transaction.data = new Uint8Array(0);\n\n      if (resp.status >= 200 && resp.status < 300) {\n        // We are complete.\n        this.txPosted = true;\n        this.chunkIndex = MAX_CHUNKS_IN_BODY;\n        return;\n      }\n\n      this.lastResponseError = error_1.getError(resp);\n      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n    } // Post the transaction with no data.\n\n\n    const resp = await this.api.post(`tx`, this.transaction);\n    this.lastRequestTimeEnd = Date.now();\n    this.lastResponseStatus = resp.status;\n\n    if (!(resp.status >= 200 && resp.status < 300)) {\n      this.lastResponseError = error_1.getError(resp);\n      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n    }\n\n    this.txPosted = true;\n  }\n\n}\n\nexports.TransactionUploader = TransactionUploader;","map":{"version":3,"sources":["../../../../src/common/lib/transaction-uploader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionUploader = void 0;\nconst transaction_1 = require(\"./transaction\");\nconst ArweaveUtils = require(\"./utils\");\nconst error_1 = require(\"./error\");\nconst merkle_1 = require(\"./merkle\");\n// Maximum amount of chunks we will upload in the body.\nconst MAX_CHUNKS_IN_BODY = 1;\n// We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\n    \"invalid_json\",\n    \"chunk_too_big\",\n    \"data_path_too_big\",\n    \"offset_too_big\",\n    \"data_size_too_big\",\n    \"chunk_proof_ratio_not_attractive\",\n    \"invalid_proof\",\n];\n// Amount we will delay on receiving an error response but do want to continue.\nconst ERROR_DELAY = 1000 * 40;\nclass TransactionUploader {\n    constructor(api, transaction) {\n        this.api = api;\n        this.chunkIndex = 0;\n        this.txPosted = false;\n        this.lastRequestTimeEnd = 0;\n        this.totalErrors = 0; // Not serialized.\n        this.lastResponseStatus = 0;\n        this.lastResponseError = \"\";\n        if (!transaction.id) {\n            throw new Error(`Transaction is not signed`);\n        }\n        if (!transaction.chunks) {\n            throw new Error(`Transaction chunks not prepared`);\n        }\n        // Make a copy of transaction, zeroing the data so we can serialize.\n        this.data = transaction.data;\n        this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));\n    }\n    get isComplete() {\n        return (this.txPosted &&\n            this.chunkIndex === this.transaction.chunks.chunks.length);\n    }\n    get totalChunks() {\n        return this.transaction.chunks.chunks.length;\n    }\n    get uploadedChunks() {\n        return this.chunkIndex;\n    }\n    get pctComplete() {\n        return Math.trunc((this.uploadedChunks / this.totalChunks) * 100);\n    }\n    /**\n     * Uploads the next part of the transaction.\n     * On the first call this posts the transaction\n     * itself and on any subsequent calls uploads the\n     * next chunk until it completes.\n     */\n    async uploadChunk() {\n        if (this.isComplete) {\n            throw new Error(`Upload is already complete`);\n        }\n        if (this.lastResponseError !== \"\") {\n            this.totalErrors++;\n        }\n        else {\n            this.totalErrors = 0;\n        }\n        // We have been trying for about an hour receiving an\n        // error every time, so eventually bail.\n        if (this.totalErrors === 100) {\n            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n        }\n        let delay = this.lastResponseError === \"\"\n            ? 0\n            : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n        if (delay > 0) {\n            // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n            delay = delay - delay * Math.random() * 0.3;\n            await new Promise((res) => setTimeout(res, delay));\n        }\n        this.lastResponseError = \"\";\n        if (!this.txPosted) {\n            await this.postTransaction();\n            return;\n        }\n        const chunk = this.transaction.getChunk(this.chunkIndex, this.data);\n        const chunkOk = await merkle_1.validatePath(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n        if (!chunkOk) {\n            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n        }\n        // Catch network errors and turn them into objects with status -1 and an error message.\n        const resp = await this.api\n            .post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data))\n            .catch((e) => {\n            console.error(e.message);\n            return { status: -1, data: { error: e.message } };\n        });\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (this.lastResponseStatus == 200) {\n            this.chunkIndex++;\n        }\n        else {\n            this.lastResponseError = error_1.getError(resp);\n            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n                throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n            }\n        }\n    }\n    /**\n     * Reconstructs an upload from its serialized state and data.\n     * Checks if data matches the expected data_root.\n     *\n     * @param serialized\n     * @param data\n     */\n    static async fromSerialized(api, serialized, data) {\n        if (!serialized ||\n            typeof serialized.chunkIndex !== \"number\" ||\n            typeof serialized.transaction !== \"object\") {\n            throw new Error(`Serialized object does not match expected format.`);\n        }\n        // Everything looks ok, reconstruct the TransactionUpload,\n        // prepare the chunks again and verify the data_root matches\n        const upload = new TransactionUploader(api, new transaction_1.default(serialized.transaction));\n        // Copy the serialized upload information, and data passed in.\n        upload.chunkIndex = serialized.chunkIndex;\n        upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n        upload.lastResponseError = serialized.lastResponseError;\n        upload.lastResponseStatus = serialized.lastResponseStatus;\n        upload.txPosted = serialized.txPosted;\n        upload.data = data;\n        await upload.transaction.prepareChunks(data);\n        if (upload.transaction.data_root !== serialized.transaction.data_root) {\n            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n        }\n        return upload;\n    }\n    /**\n     * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n     *\n     * @param api\n     * @param id\n     * @param data\n     */\n    static async fromTransactionId(api, id) {\n        const resp = await api.get(`tx/${id}`);\n        if (resp.status !== 200) {\n            throw new Error(`Tx ${id} not found: ${resp.status}`);\n        }\n        const transaction = resp.data;\n        transaction.data = new Uint8Array(0);\n        const serialized = {\n            txPosted: true,\n            chunkIndex: 0,\n            lastResponseError: \"\",\n            lastRequestTimeEnd: 0,\n            lastResponseStatus: 0,\n            transaction,\n        };\n        return serialized;\n    }\n    toJSON() {\n        return {\n            chunkIndex: this.chunkIndex,\n            transaction: this.transaction,\n            lastRequestTimeEnd: this.lastRequestTimeEnd,\n            lastResponseStatus: this.lastResponseStatus,\n            lastResponseError: this.lastResponseError,\n            txPosted: this.txPosted,\n        };\n    }\n    // POST to /tx\n    async postTransaction() {\n        const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n        if (uploadInBody) {\n            // Post the transaction with data.\n            this.transaction.data = this.data;\n            const resp = await this.api.post(`tx`, this.transaction).catch((e) => {\n                console.error(e);\n                return { status: -1, data: { error: e.message } };\n            });\n            this.lastRequestTimeEnd = Date.now();\n            this.lastResponseStatus = resp.status;\n            this.transaction.data = new Uint8Array(0);\n            if (resp.status >= 200 && resp.status < 300) {\n                // We are complete.\n                this.txPosted = true;\n                this.chunkIndex = MAX_CHUNKS_IN_BODY;\n                return;\n            }\n            this.lastResponseError = error_1.getError(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        // Post the transaction with no data.\n        const resp = await this.api.post(`tx`, this.transaction);\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (!(resp.status >= 200 && resp.status < 300)) {\n            this.lastResponseError = error_1.getError(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        this.txPosted = true;\n    }\n}\nexports.TransactionUploader = TransactionUploader;\n//# sourceMappingURL=transaction-uploader.js.map"]},"metadata":{},"sourceType":"script"}