{"ast":null,"code":"import _toConsumableArray from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { UnsupportedAlgorithmError } from './errors';\n\nvar getEcFieldSize = function getEcFieldSize(namedCurve) {\n  return (// Get the the curve's field size in bytes by extracting the number of bits from it and converting it to bytes\n    // Note that the number of bits may not be multiples of 8\n    Math.floor((Number(namedCurve.match(/\\d+/)[0]) + 7) / 8)\n  );\n};\n\nexport var decodeEcPoint = function decodeEcPoint(namedCurve, publicKey) {\n  var fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (publicKey[0] !== 4) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported');\n  }\n\n  if (publicKey.length !== fieldSizeBytes * 2 + 1) {\n    throw new UnsupportedAlgorithmError(\"Expecting EC public key to have length \".concat(fieldSizeBytes * 2 - 1));\n  }\n\n  return {\n    x: publicKey.slice(1, fieldSizeBytes + 1),\n    y: publicKey.slice(fieldSizeBytes + 1)\n  };\n};\nexport var encodeEcPoint = function encodeEcPoint(namedCurve, x, y) {\n  var fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!y) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported (y must be specified)');\n  }\n\n  if (!x || x.length !== fieldSizeBytes || !y || y.length !== fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(\"Expecting x & y points to have length \".concat(fieldSizeBytes, \" bytes\"));\n  }\n\n  return new Uint8Array([4].concat(_toConsumableArray(x), _toConsumableArray(y)));\n};\nexport var validateEcD = function validateEcD(namedCurve, d) {\n  var fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!d || d.length < fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(\"Expecting d length to be >= \".concat(fieldSizeBytes, \" bytes\"));\n  }\n\n  return d;\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/util/ec.js"],"names":["UnsupportedAlgorithmError","getEcFieldSize","namedCurve","Math","floor","Number","match","decodeEcPoint","publicKey","fieldSizeBytes","length","x","slice","y","encodeEcPoint","Uint8Array","validateEcD","d"],"mappings":";AAAA,SAASA,yBAAT,QAA0C,UAA1C;;AAEA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAAAC,UAAU;AAAA,SAAI;AACrC;AACAC,IAAAA,IAAI,CAACC,KAAL,CAAW,CAACC,MAAM,CAACH,UAAU,CAACI,KAAX,CAAiB,KAAjB,EAAwB,CAAxB,CAAD,CAAN,GAAqC,CAAtC,IAA2C,CAAtD;AAFiC;AAAA,CAAjC;;AAIA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACL,UAAD,EAAaM,SAAb,EAA2B;AACtD,MAAMC,cAAc,GAAGR,cAAc,CAACC,UAAD,CAArC;;AAEA,MAAIM,SAAS,CAAC,CAAD,CAAT,KAAiB,CAArB,EAAwB;AACtB,UAAM,IAAIR,yBAAJ,CAA8B,2CAA9B,CAAN;AACD;;AAED,MAAIQ,SAAS,CAACE,MAAV,KAAqBD,cAAc,GAAG,CAAjB,GAAqB,CAA9C,EAAiD;AAC/C,UAAM,IAAIT,yBAAJ,kDAAwES,cAAc,GAAG,CAAjB,GAAqB,CAA7F,EAAN;AACD;;AAED,SAAO;AACLE,IAAAA,CAAC,EAAEH,SAAS,CAACI,KAAV,CAAgB,CAAhB,EAAmBH,cAAc,GAAG,CAApC,CADE;AAELI,IAAAA,CAAC,EAAEL,SAAS,CAACI,KAAV,CAAgBH,cAAc,GAAG,CAAjC;AAFE,GAAP;AAID,CAfM;AAgBP,OAAO,IAAMK,aAAa,GAAG,SAAhBA,aAAgB,CAACZ,UAAD,EAAaS,CAAb,EAAgBE,CAAhB,EAAsB;AACjD,MAAMJ,cAAc,GAAGR,cAAc,CAACC,UAAD,CAArC;;AAEA,MAAI,CAACW,CAAL,EAAQ;AACN,UAAM,IAAIb,yBAAJ,CAA8B,iEAA9B,CAAN;AACD;;AAED,MAAI,CAACW,CAAD,IAAMA,CAAC,CAACD,MAAF,KAAaD,cAAnB,IAAqC,CAACI,CAAtC,IAA2CA,CAAC,CAACH,MAAF,KAAaD,cAA5D,EAA4E;AAC1E,UAAM,IAAIT,yBAAJ,iDAAuES,cAAvE,YAAN;AACD;;AAED,SAAO,IAAIM,UAAJ,EAAgB,CAAhB,4BAAsBJ,CAAtB,sBAA4BE,CAA5B,GAAP;AACD,CAZM;AAaP,OAAO,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACd,UAAD,EAAae,CAAb,EAAmB;AAC5C,MAAMR,cAAc,GAAGR,cAAc,CAACC,UAAD,CAArC;;AAEA,MAAI,CAACe,CAAD,IAAMA,CAAC,CAACP,MAAF,GAAWD,cAArB,EAAqC;AACnC,UAAM,IAAIT,yBAAJ,uCAA6DS,cAA7D,YAAN;AACD;;AAED,SAAOQ,CAAP;AACD,CARM","sourcesContent":["import { UnsupportedAlgorithmError } from './errors';\n\nconst getEcFieldSize = namedCurve => // Get the the curve's field size in bytes by extracting the number of bits from it and converting it to bytes\n// Note that the number of bits may not be multiples of 8\nMath.floor((Number(namedCurve.match(/\\d+/)[0]) + 7) / 8);\n\nexport const decodeEcPoint = (namedCurve, publicKey) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (publicKey[0] !== 4) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported');\n  }\n\n  if (publicKey.length !== fieldSizeBytes * 2 + 1) {\n    throw new UnsupportedAlgorithmError(`Expecting EC public key to have length ${fieldSizeBytes * 2 - 1}`);\n  }\n\n  return {\n    x: publicKey.slice(1, fieldSizeBytes + 1),\n    y: publicKey.slice(fieldSizeBytes + 1)\n  };\n};\nexport const encodeEcPoint = (namedCurve, x, y) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!y) {\n    throw new UnsupportedAlgorithmError('Only uncompressed EC points are supported (y must be specified)');\n  }\n\n  if (!x || x.length !== fieldSizeBytes || !y || y.length !== fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(`Expecting x & y points to have length ${fieldSizeBytes} bytes`);\n  }\n\n  return new Uint8Array([4, ...x, ...y]);\n};\nexport const validateEcD = (namedCurve, d) => {\n  const fieldSizeBytes = getEcFieldSize(namedCurve);\n\n  if (!d || d.length < fieldSizeBytes) {\n    throw new UnsupportedAlgorithmError(`Expecting d length to be >= ${fieldSizeBytes} bytes`);\n  }\n\n  return d;\n};"]},"metadata":{},"sourceType":"module"}