{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport { binaryStringToUint8Array, typedArrayToUint8Array } from './binary';\nimport { KEY_ALIASES } from './key-types';\nimport { UnexpectedTypeError, UnsupportedFormatError } from './errors';\nexport const validateInputKey = input => {\n  // Support strings\n  if (typeof input === 'string') {\n    return binaryStringToUint8Array(input);\n  } // Support array buffer or typed arrays\n\n\n  if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  }\n\n  if (ArrayBuffer.isView(input)) {\n    return typedArrayToUint8Array(input);\n  }\n\n  throw new UnexpectedTypeError('Expecting input key to be one of: Uint8Array, ArrayBuffer, string');\n};\nexport const validateFormat = (format, supportedFormats) => {\n  if (typeof format !== 'string') {\n    throw new UnexpectedTypeError('Expecting format to be a string');\n  }\n\n  if (!supportedFormats[format]) {\n    throw new UnsupportedFormatError(format);\n  }\n\n  return format;\n};\n\nconst validateAlgorithmIdentifier = (algorithmIdentifier, errorContext) => {\n  if (typeof algorithmIdentifier === 'string') {\n    algorithmIdentifier = {\n      id: algorithmIdentifier\n    };\n  }\n\n  if (!_isPlainObject(algorithmIdentifier)) {\n    throw new UnexpectedTypeError(`Expecting ${errorContext} to be an object`);\n  }\n\n  if (typeof algorithmIdentifier.id !== 'string') {\n    throw new UnexpectedTypeError(`Expecting ${errorContext} id to be a string`);\n  }\n\n  return algorithmIdentifier;\n};\n\nexport const validateDecomposedKey = (decomposedKey, supportedFormats) => {\n  if (!decomposedKey || !_isPlainObject(decomposedKey)) {\n    throw new UnexpectedTypeError('Expecting decomposed key to be an object');\n  }\n\n  decomposedKey = { ...decomposedKey\n  };\n  decomposedKey.format = validateFormat(decomposedKey.format, supportedFormats);\n  decomposedKey.keyAlgorithm = validateAlgorithmIdentifier(decomposedKey.keyAlgorithm, 'key algorithm'); // Allow key algorithm to be an alias\n\n  const aliasedKeyAlgorithm = KEY_ALIASES[decomposedKey.keyAlgorithm.id];\n\n  if (aliasedKeyAlgorithm) {\n    decomposedKey.keyAlgorithm = { ...aliasedKeyAlgorithm,\n      ...decomposedKey.keyAlgorithm,\n      id: aliasedKeyAlgorithm.id\n    };\n  }\n\n  if (!_isPlainObject(decomposedKey.keyData)) {\n    throw new UnexpectedTypeError('Expecting key data to be an object');\n  }\n\n  if (decomposedKey.encryptionAlgorithm && !_isPlainObject(decomposedKey.encryptionAlgorithm)) {\n    throw new UnexpectedTypeError('Expecting encryption algorithm to be an object');\n  }\n\n  return decomposedKey;\n};\nexport const validateEncryptionAlgorithm = (encryptionAlgorithm, defaultKeyDerivationFunc, defaultEncryptionScheme) => {\n  encryptionAlgorithm = encryptionAlgorithm || {};\n  return {\n    keyDerivationFunc: validateAlgorithmIdentifier(encryptionAlgorithm.keyDerivationFunc || defaultKeyDerivationFunc, 'key derivation func'),\n    encryptionScheme: validateAlgorithmIdentifier(encryptionAlgorithm.encryptionScheme || defaultEncryptionScheme, 'encryption scheme')\n  };\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/util/validator.js"],"names":["_isPlainObject","binaryStringToUint8Array","typedArrayToUint8Array","KEY_ALIASES","UnexpectedTypeError","UnsupportedFormatError","validateInputKey","input","ArrayBuffer","Uint8Array","isView","validateFormat","format","supportedFormats","validateAlgorithmIdentifier","algorithmIdentifier","errorContext","id","validateDecomposedKey","decomposedKey","keyAlgorithm","aliasedKeyAlgorithm","keyData","encryptionAlgorithm","validateEncryptionAlgorithm","defaultKeyDerivationFunc","defaultEncryptionScheme","keyDerivationFunc","encryptionScheme"],"mappings":"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","sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport { binaryStringToUint8Array, typedArrayToUint8Array } from './binary';\nimport { KEY_ALIASES } from './key-types';\nimport { UnexpectedTypeError, UnsupportedFormatError } from './errors';\nexport const validateInputKey = input => {\n  // Support strings\n  if (typeof input === 'string') {\n    return binaryStringToUint8Array(input);\n  } // Support array buffer or typed arrays\n\n\n  if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  }\n\n  if (ArrayBuffer.isView(input)) {\n    return typedArrayToUint8Array(input);\n  }\n\n  throw new UnexpectedTypeError('Expecting input key to be one of: Uint8Array, ArrayBuffer, string');\n};\nexport const validateFormat = (format, supportedFormats) => {\n  if (typeof format !== 'string') {\n    throw new UnexpectedTypeError('Expecting format to be a string');\n  }\n\n  if (!supportedFormats[format]) {\n    throw new UnsupportedFormatError(format);\n  }\n\n  return format;\n};\n\nconst validateAlgorithmIdentifier = (algorithmIdentifier, errorContext) => {\n  if (typeof algorithmIdentifier === 'string') {\n    algorithmIdentifier = {\n      id: algorithmIdentifier\n    };\n  }\n\n  if (!_isPlainObject(algorithmIdentifier)) {\n    throw new UnexpectedTypeError(`Expecting ${errorContext} to be an object`);\n  }\n\n  if (typeof algorithmIdentifier.id !== 'string') {\n    throw new UnexpectedTypeError(`Expecting ${errorContext} id to be a string`);\n  }\n\n  return algorithmIdentifier;\n};\n\nexport const validateDecomposedKey = (decomposedKey, supportedFormats) => {\n  if (!decomposedKey || !_isPlainObject(decomposedKey)) {\n    throw new UnexpectedTypeError('Expecting decomposed key to be an object');\n  }\n\n  decomposedKey = { ...decomposedKey\n  };\n  decomposedKey.format = validateFormat(decomposedKey.format, supportedFormats);\n  decomposedKey.keyAlgorithm = validateAlgorithmIdentifier(decomposedKey.keyAlgorithm, 'key algorithm'); // Allow key algorithm to be an alias\n\n  const aliasedKeyAlgorithm = KEY_ALIASES[decomposedKey.keyAlgorithm.id];\n\n  if (aliasedKeyAlgorithm) {\n    decomposedKey.keyAlgorithm = { ...aliasedKeyAlgorithm,\n      ...decomposedKey.keyAlgorithm,\n      id: aliasedKeyAlgorithm.id\n    };\n  }\n\n  if (!_isPlainObject(decomposedKey.keyData)) {\n    throw new UnexpectedTypeError('Expecting key data to be an object');\n  }\n\n  if (decomposedKey.encryptionAlgorithm && !_isPlainObject(decomposedKey.encryptionAlgorithm)) {\n    throw new UnexpectedTypeError('Expecting encryption algorithm to be an object');\n  }\n\n  return decomposedKey;\n};\nexport const validateEncryptionAlgorithm = (encryptionAlgorithm, defaultKeyDerivationFunc, defaultEncryptionScheme) => {\n  encryptionAlgorithm = encryptionAlgorithm || {};\n  return {\n    keyDerivationFunc: validateAlgorithmIdentifier(encryptionAlgorithm.keyDerivationFunc || defaultKeyDerivationFunc, 'key derivation func'),\n    encryptionScheme: validateAlgorithmIdentifier(encryptionAlgorithm.encryptionScheme || defaultEncryptionScheme, 'encryption scheme')\n  };\n};"]},"metadata":{},"sourceType":"module"}