{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readContract = void 0;\n\nconst contract_load_1 = require(\"./contract-load\");\n\nconst utils_1 = require(\"./utils\");\n\nconst contract_step_1 = require(\"./contract-step\");\n\nconst errors_1 = __importDefault(require(\"./errors\"));\n\nconst cache = {};\n/**\n * Queries all interaction transactions and replays a contract to its latest state.\n *\n * If height is provided, will replay only to that block height.\n *\n * @param arweave         an Arweave client instance\n * @param contractId      the Transaction Id of the contract\n * @param height          if specified the contract will be replayed only to this block height\n * @param returnValidity  if true, the function will return valid and invalid transaction IDs along with the state\n */\n\nfunction readContract(arweave, contractId, height, returnValidity) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!height) {\n      const networkInfo = yield arweave.network.getInfo();\n      height = networkInfo.height;\n    }\n\n    if (contractId in cache) {\n      if (height in cache[contractId]) {\n        const res = JSON.parse(cache[contractId][height]);\n        return returnValidity ? {\n          state: res.state,\n          validity: res.validity\n        } : res.state;\n      }\n    }\n\n    const loadPromise = contract_load_1.loadContract(arweave, contractId).catch(err => {\n      const error = new errors_1.default(\"CONTRACT_NOT_FOUND\"\n      /* CONTRACT_NOT_FOUND */\n      , {\n        message: `Contract having txId: ${contractId} not found`,\n        requestedTxId: contractId\n      });\n      throw error;\n    });\n    const fetchTxPromise = fetchTransactions(arweave, contractId, height).catch(err => err); // tslint:disable-next-line: prefer-const\n\n    let [contractInfo, txInfos] = yield Promise.all([loadPromise, fetchTxPromise]);\n    if (contractInfo instanceof Error) throw contractInfo;\n    if (txInfos instanceof Error) throw txInfos;\n    let state;\n    const contractSrc = contractInfo.contractSrc;\n\n    try {\n      state = JSON.parse(contractInfo.initState);\n    } catch (e) {\n      throw new Error(`Unable to parse initial state for contract: ${contractId}`);\n    }\n\n    utils_1.log(arweave, `Replaying ${txInfos.length} confirmed interactions`);\n    yield sortTransactions(arweave, txInfos); // tslint:disable-next-line: prefer-const\n\n    let {\n      handler,\n      swGlobal\n    } = contractInfo;\n    let validity = {};\n\n    if (contractId in cache) {\n      const heights = Object.keys(cache[contractId]).filter(item => +item < height).map(item => +item);\n\n      if (heights.length) {\n        const max = Math.max(...heights);\n        txInfos = txInfos.filter(item => item.node.block.height > max);\n        const res = JSON.parse(cache[contractId][max]);\n        state = res.state;\n        validity = res.validity;\n      }\n    }\n\n    for (const txInfo of txInfos) {\n      const currentTx = txInfo.node;\n      const contractIndex = txInfo.node.tags.findIndex(tag => tag.name === 'Contract' && tag.value === contractId);\n      const inputTag = txInfo.node.tags[contractIndex + 1];\n\n      if (!inputTag || inputTag.name !== 'Input') {\n        utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n        continue;\n      }\n\n      let input = inputTag.value;\n\n      try {\n        input = JSON.parse(input);\n      } catch (e) {\n        utils_1.log(arweave, e);\n        continue;\n      }\n\n      if (!input) {\n        utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n        continue;\n      }\n\n      const interaction = {\n        input,\n        caller: currentTx.owner.address\n      };\n      swGlobal._activeTx = currentTx;\n      const result = yield contract_step_1.execute(handler, interaction, state);\n\n      if (result.type === 'exception') {\n        utils_1.log(arweave, `${result.result}`);\n        utils_1.log(arweave, `Executing of interaction: ${currentTx.id} threw exception.`);\n      }\n\n      if (result.type === 'error') {\n        utils_1.log(arweave, `${result.result}`);\n        utils_1.log(arweave, `Executing of interaction: ${currentTx.id} returned error.`);\n      }\n\n      validity[currentTx.id] = result.type === 'ok';\n      state = result.state;\n      let settings = new Map();\n\n      try {\n        if (state.settings) settings = new Map(state.settings);\n      } catch (_a) {}\n\n      const evolve = state.evolve || settings.get('evolve');\n      let canEvolve = state.canEvolve || settings.get('canEvolve'); // By default, contracts can evolve if there's not an explicit `false`.\n\n      if (canEvolve === undefined || canEvolve === null) {\n        canEvolve = true;\n      }\n\n      if (evolve && /[a-z0-9_-]{43}/i.test(evolve) && canEvolve) {\n        if (contractSrc !== state.evolve) {\n          try {\n            contractInfo = yield contract_load_1.loadContract(arweave, contractId, evolve);\n            handler = contractInfo.handler;\n          } catch (e) {\n            const error = new errors_1.default(\"CONTRACT_NOT_FOUND\"\n            /* CONTRACT_NOT_FOUND */\n            , {\n              message: `Contract having txId: ${contractId} not found`,\n              requestedTxId: contractId\n            });\n            throw error;\n          }\n        }\n      }\n    }\n\n    cache[contractId] = Object.assign(Object.assign({}, cache[contractId] || {}), {\n      [height]: JSON.stringify({\n        state,\n        validity\n      })\n    });\n    return returnValidity ? {\n      state,\n      validity\n    } : state;\n  });\n}\n\nexports.readContract = readContract; // Sort the transactions based on the sort key generated in addSortKey()\n\nfunction sortTransactions(arweave, txInfos) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const addKeysFuncs = txInfos.map(tx => addSortKey(arweave, tx));\n    yield Promise.all(addKeysFuncs);\n    txInfos.sort((a, b) => a.sortKey.localeCompare(b.sortKey));\n  });\n} // Construct a string that will lexographically sort.\n// { block_height, sha256(block_indep_hash + txid) }\n// pad block height to 12 digits and convert hash value\n// to a hex string.\n\n\nfunction addSortKey(arweave, txInfo) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      node\n    } = txInfo;\n    const blockHashBytes = arweave.utils.b64UrlToBuffer(node.block.id);\n    const txIdBytes = arweave.utils.b64UrlToBuffer(node.id);\n    const concatted = arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);\n    const hashed = utils_1.arrayToHex(yield arweave.crypto.hash(concatted));\n    const blockHeight = `000000${node.block.height}`.slice(-12);\n    txInfo.sortKey = `${blockHeight},${hashed}`;\n  });\n} // the maximum number of transactions we can get from graphql at once\n\n\nconst MAX_REQUEST = 100; // fetch all contract interactions up to the specified block height\n\nfunction fetchTransactions(arweave, contractId, height) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let variables = {\n      tags: [{\n        name: 'App-Name',\n        values: ['SmartWeaveAction']\n      }, {\n        name: 'Contract',\n        values: [contractId]\n      }],\n      blockFilter: {\n        max: height\n      },\n      first: MAX_REQUEST\n    };\n    let transactions = yield getNextPage(arweave, variables);\n    const txInfos = transactions.edges.filter(tx => !tx.node.parent || !tx.node.parent.id);\n\n    while (transactions.pageInfo.hasNextPage) {\n      const cursor = transactions.edges[MAX_REQUEST - 1].cursor;\n      variables = Object.assign(Object.assign({}, variables), {\n        after: cursor\n      });\n      transactions = yield getNextPage(arweave, variables);\n      txInfos.push(...transactions.edges.filter(tx => !tx.node.parent || !tx.node.parent.id));\n    }\n\n    return txInfos;\n  });\n}\n\nfunction getNextPage(arweave, variables) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {\n    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {\n      pageInfo {\n        hasNextPage\n      }\n      edges {\n        node {\n          id\n          owner { address }\n          recipient\n          tags {\n            name\n            value\n          }\n          block {\n            height\n            id\n            timestamp\n          }\n          fee { winston }\n          quantity { winston }\n          parent { id }\n        }\n        cursor\n      }\n    }\n  }`;\n    const response = yield arweave.api.post('graphql', {\n      query,\n      variables\n    });\n\n    if (response.status !== 200) {\n      throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response.status}.`);\n    }\n\n    const data = response.data;\n    const txs = data.data.transactions;\n    return txs;\n  });\n}","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/@kyve/contract-lib/node_modules/smartweave/lib/contract-read.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","readContract","contract_load_1","require","utils_1","contract_step_1","errors_1","cache","arweave","contractId","height","returnValidity","networkInfo","network","getInfo","res","JSON","parse","state","validity","loadPromise","loadContract","catch","err","error","default","message","requestedTxId","fetchTxPromise","fetchTransactions","contractInfo","txInfos","all","Error","contractSrc","initState","log","length","sortTransactions","handler","swGlobal","heights","keys","filter","item","map","max","Math","node","block","txInfo","currentTx","contractIndex","tags","findIndex","tag","name","inputTag","id","input","interaction","caller","owner","address","_activeTx","execute","type","settings","Map","_a","evolve","get","canEvolve","undefined","test","assign","stringify","addKeysFuncs","tx","addSortKey","sort","a","b","sortKey","localeCompare","blockHashBytes","utils","b64UrlToBuffer","txIdBytes","concatted","concatBuffers","hashed","arrayToHex","crypto","hash","blockHeight","slice","MAX_REQUEST","variables","values","blockFilter","first","transactions","getNextPage","edges","parent","pageInfo","hasNextPage","cursor","after","push","query","response","api","post","status","data","txs"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readContract = void 0;\nconst contract_load_1 = require(\"./contract-load\");\nconst utils_1 = require(\"./utils\");\nconst contract_step_1 = require(\"./contract-step\");\nconst errors_1 = __importDefault(require(\"./errors\"));\nconst cache = {};\n/**\n * Queries all interaction transactions and replays a contract to its latest state.\n *\n * If height is provided, will replay only to that block height.\n *\n * @param arweave         an Arweave client instance\n * @param contractId      the Transaction Id of the contract\n * @param height          if specified the contract will be replayed only to this block height\n * @param returnValidity  if true, the function will return valid and invalid transaction IDs along with the state\n */\nfunction readContract(arweave, contractId, height, returnValidity) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!height) {\n            const networkInfo = yield arweave.network.getInfo();\n            height = networkInfo.height;\n        }\n        if (contractId in cache) {\n            if (height in cache[contractId]) {\n                const res = JSON.parse(cache[contractId][height]);\n                return returnValidity ? { state: res.state, validity: res.validity } : res.state;\n            }\n        }\n        const loadPromise = contract_load_1.loadContract(arweave, contractId).catch((err) => {\n            const error = new errors_1.default(\"CONTRACT_NOT_FOUND\" /* CONTRACT_NOT_FOUND */, {\n                message: `Contract having txId: ${contractId} not found`,\n                requestedTxId: contractId,\n            });\n            throw error;\n        });\n        const fetchTxPromise = fetchTransactions(arweave, contractId, height).catch((err) => err);\n        // tslint:disable-next-line: prefer-const\n        let [contractInfo, txInfos] = yield Promise.all([loadPromise, fetchTxPromise]);\n        if (contractInfo instanceof Error)\n            throw contractInfo;\n        if (txInfos instanceof Error)\n            throw txInfos;\n        let state;\n        const contractSrc = contractInfo.contractSrc;\n        try {\n            state = JSON.parse(contractInfo.initState);\n        }\n        catch (e) {\n            throw new Error(`Unable to parse initial state for contract: ${contractId}`);\n        }\n        utils_1.log(arweave, `Replaying ${txInfos.length} confirmed interactions`);\n        yield sortTransactions(arweave, txInfos);\n        // tslint:disable-next-line: prefer-const\n        let { handler, swGlobal } = contractInfo;\n        let validity = {};\n        if (contractId in cache) {\n            const heights = Object.keys(cache[contractId])\n                .filter((item) => +item < height)\n                .map((item) => +item);\n            if (heights.length) {\n                const max = Math.max(...heights);\n                txInfos = txInfos.filter((item) => item.node.block.height > max);\n                const res = JSON.parse(cache[contractId][max]);\n                state = res.state;\n                validity = res.validity;\n            }\n        }\n        for (const txInfo of txInfos) {\n            const currentTx = txInfo.node;\n            const contractIndex = txInfo.node.tags.findIndex((tag) => tag.name === 'Contract' && tag.value === contractId);\n            const inputTag = txInfo.node.tags[contractIndex + 1];\n            if (!inputTag || inputTag.name !== 'Input') {\n                utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n                continue;\n            }\n            let input = inputTag.value;\n            try {\n                input = JSON.parse(input);\n            }\n            catch (e) {\n                utils_1.log(arweave, e);\n                continue;\n            }\n            if (!input) {\n                utils_1.log(arweave, `Skipping tx with missing or invalid Input tag - ${currentTx.id}`);\n                continue;\n            }\n            const interaction = {\n                input,\n                caller: currentTx.owner.address,\n            };\n            swGlobal._activeTx = currentTx;\n            const result = yield contract_step_1.execute(handler, interaction, state);\n            if (result.type === 'exception') {\n                utils_1.log(arweave, `${result.result}`);\n                utils_1.log(arweave, `Executing of interaction: ${currentTx.id} threw exception.`);\n            }\n            if (result.type === 'error') {\n                utils_1.log(arweave, `${result.result}`);\n                utils_1.log(arweave, `Executing of interaction: ${currentTx.id} returned error.`);\n            }\n            validity[currentTx.id] = result.type === 'ok';\n            state = result.state;\n            let settings = new Map();\n            try {\n                if (state.settings)\n                    settings = new Map(state.settings);\n            }\n            catch (_a) { }\n            const evolve = state.evolve || settings.get('evolve');\n            let canEvolve = state.canEvolve || settings.get('canEvolve');\n            // By default, contracts can evolve if there's not an explicit `false`.\n            if (canEvolve === undefined || canEvolve === null) {\n                canEvolve = true;\n            }\n            if (evolve && /[a-z0-9_-]{43}/i.test(evolve) && canEvolve) {\n                if (contractSrc !== state.evolve) {\n                    try {\n                        contractInfo = yield contract_load_1.loadContract(arweave, contractId, evolve);\n                        handler = contractInfo.handler;\n                    }\n                    catch (e) {\n                        const error = new errors_1.default(\"CONTRACT_NOT_FOUND\" /* CONTRACT_NOT_FOUND */, {\n                            message: `Contract having txId: ${contractId} not found`,\n                            requestedTxId: contractId,\n                        });\n                        throw error;\n                    }\n                }\n            }\n        }\n        cache[contractId] = Object.assign(Object.assign({}, (cache[contractId] || {})), { [height]: JSON.stringify({ state, validity }) });\n        return returnValidity ? { state, validity } : state;\n    });\n}\nexports.readContract = readContract;\n// Sort the transactions based on the sort key generated in addSortKey()\nfunction sortTransactions(arweave, txInfos) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const addKeysFuncs = txInfos.map((tx) => addSortKey(arweave, tx));\n        yield Promise.all(addKeysFuncs);\n        txInfos.sort((a, b) => a.sortKey.localeCompare(b.sortKey));\n    });\n}\n// Construct a string that will lexographically sort.\n// { block_height, sha256(block_indep_hash + txid) }\n// pad block height to 12 digits and convert hash value\n// to a hex string.\nfunction addSortKey(arweave, txInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { node } = txInfo;\n        const blockHashBytes = arweave.utils.b64UrlToBuffer(node.block.id);\n        const txIdBytes = arweave.utils.b64UrlToBuffer(node.id);\n        const concatted = arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);\n        const hashed = utils_1.arrayToHex(yield arweave.crypto.hash(concatted));\n        const blockHeight = `000000${node.block.height}`.slice(-12);\n        txInfo.sortKey = `${blockHeight},${hashed}`;\n    });\n}\n// the maximum number of transactions we can get from graphql at once\nconst MAX_REQUEST = 100;\n// fetch all contract interactions up to the specified block height\nfunction fetchTransactions(arweave, contractId, height) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let variables = {\n            tags: [\n                {\n                    name: 'App-Name',\n                    values: ['SmartWeaveAction'],\n                },\n                {\n                    name: 'Contract',\n                    values: [contractId],\n                },\n            ],\n            blockFilter: {\n                max: height,\n            },\n            first: MAX_REQUEST,\n        };\n        let transactions = yield getNextPage(arweave, variables);\n        const txInfos = transactions.edges.filter((tx) => !tx.node.parent || !tx.node.parent.id);\n        while (transactions.pageInfo.hasNextPage) {\n            const cursor = transactions.edges[MAX_REQUEST - 1].cursor;\n            variables = Object.assign(Object.assign({}, variables), { after: cursor });\n            transactions = yield getNextPage(arweave, variables);\n            txInfos.push(...transactions.edges.filter((tx) => !tx.node.parent || !tx.node.parent.id));\n        }\n        return txInfos;\n    });\n}\nfunction getNextPage(arweave, variables) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {\n    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {\n      pageInfo {\n        hasNextPage\n      }\n      edges {\n        node {\n          id\n          owner { address }\n          recipient\n          tags {\n            name\n            value\n          }\n          block {\n            height\n            id\n            timestamp\n          }\n          fee { winston }\n          quantity { winston }\n          parent { id }\n        }\n        cursor\n      }\n    }\n  }`;\n        const response = yield arweave.api.post('graphql', {\n            query,\n            variables,\n        });\n        if (response.status !== 200) {\n            throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${response.status}.`);\n        }\n        const data = response.data;\n        const txs = data.data.transactions;\n        return txs;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}