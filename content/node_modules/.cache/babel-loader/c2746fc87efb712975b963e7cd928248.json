{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\n\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst error_1 = __importStar(require(\"./lib/error\"));\n\nconst transaction_1 = __importDefault(require(\"./lib/transaction\"));\n\nconst ArweaveUtils = __importStar(require(\"./lib/utils\"));\n\nconst transaction_uploader_1 = require(\"./lib/transaction-uploader\");\n\nrequire(\"arconnect\");\n\nclass Transactions {\n  constructor(api, crypto, chunks) {\n    this.api = api;\n    this.crypto = crypto;\n    this.chunks = chunks;\n  }\n\n  getTransactionAnchor() {\n    return this.api.get(`tx_anchor`).then(response => {\n      return response.data;\n    });\n  }\n\n  getPrice(byteSize, targetAddress) {\n    let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;\n    return this.api.get(endpoint, {\n      transformResponse: [\n      /**\n       * We need to specify a response transformer to override\n       * the default JSON.parse behaviour, as this causes\n       * winston to be converted to a number and we want to\n       * return it as a winston string.\n       * @param data\n       */\n      function (data) {\n        return data;\n      }]\n    }).then(response => {\n      return response.data;\n    });\n  }\n\n  async get(id) {\n    const response = await this.api.get(`tx/${id}`);\n\n    if (response.status == 200) {\n      const data_size = parseInt(response.data.data_size);\n\n      if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {\n        const data = await this.getData(id);\n        return new transaction_1.default(Object.assign(Object.assign({}, response.data), {\n          data\n        }));\n      }\n\n      return new transaction_1.default(Object.assign(Object.assign({}, response.data), {\n        format: response.data.format || 1\n      }));\n    }\n\n    if (response.status == 202) {\n      throw new error_1.default(\"TX_PENDING\"\n      /* TX_PENDING */\n      );\n    }\n\n    if (response.status == 404) {\n      throw new error_1.default(\"TX_NOT_FOUND\"\n      /* TX_NOT_FOUND */\n      );\n    }\n\n    if (response.status == 410) {\n      throw new error_1.default(\"TX_FAILED\"\n      /* TX_FAILED */\n      );\n    }\n\n    throw new error_1.default(\"TX_INVALID\"\n    /* TX_INVALID */\n    );\n  }\n\n  fromRaw(attributes) {\n    return new transaction_1.default(attributes);\n  }\n\n  async search(tagName, tagValue) {\n    return this.api.post(`arql`, {\n      op: \"equals\",\n      expr1: tagName,\n      expr2: tagValue\n    }).then(response => {\n      if (!response.data) {\n        return [];\n      }\n\n      return response.data;\n    });\n  }\n\n  getStatus(id) {\n    return this.api.get(`tx/${id}/status`).then(response => {\n      if (response.status == 200) {\n        return {\n          status: 200,\n          confirmed: response.data\n        };\n      }\n\n      return {\n        status: response.status,\n        confirmed: null\n      };\n    });\n  }\n\n  async getData(id, options) {\n    // Attempt to download from /txid, fall back to downloading chunks.\n    const resp = await this.api.get(`${id}`, {\n      responseType: \"arraybuffer\"\n    });\n    let data = undefined;\n\n    if (resp.status === 200) {\n      data = new Uint8Array(resp.data);\n    }\n\n    if (resp.status === 400 && error_1.getError(resp) === \"tx_data_too_big\") {\n      data = await this.chunks.downloadChunkedData(id);\n    } // If we don't have data, throw an exception. Previously we\n    // just returned an empty data object.\n\n\n    if (!data) {\n      if (resp.status == 202) {\n        throw new error_1.default(\"TX_PENDING\"\n        /* TX_PENDING */\n        );\n      }\n\n      if (resp.status == 404) {\n        throw new error_1.default(\"TX_NOT_FOUND\"\n        /* TX_NOT_FOUND */\n        );\n      }\n\n      if (resp.status == 410) {\n        throw new error_1.default(\"TX_FAILED\"\n        /* TX_FAILED */\n        );\n      }\n\n      throw new Error(`Unable to get data: ${resp.status} - ${error_1.getError(resp)}`);\n    }\n\n    if (options && options.decode && !options.string) {\n      return data;\n    }\n\n    if (options && options.decode && options.string) {\n      return ArweaveUtils.bufferToString(data);\n    } // Since decode wasn't requested, caller expects b64url encoded data.\n\n\n    return ArweaveUtils.bufferTob64Url(data);\n  }\n\n  async sign(transaction, jwk, options) {\n    // @ts-ignore\n    if (!jwk && (!window || !window.arweaveWallet)) {\n      throw new Error(`A new Arweave transaction must provide the jwk parameter.`);\n    } else if (!jwk || jwk === \"use_wallet\") {\n      try {\n        const existingPermissions = await window.arweaveWallet.getPermissions();\n        if (!existingPermissions.includes(\"SIGN_TRANSACTION\")) await window.arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n      } catch (_a) {// Permission is already granted\n      }\n\n      const signedTransaction = await window.arweaveWallet.sign(transaction, options);\n      transaction.setSignature({\n        id: signedTransaction.id,\n        owner: signedTransaction.owner,\n        tags: signedTransaction.tags,\n        signature: signedTransaction.signature\n      });\n    } else {\n      transaction.setOwner(jwk.n);\n      let dataToSign = await transaction.getSignatureData();\n      let rawSignature = await this.crypto.sign(jwk, dataToSign, options);\n      let id = await this.crypto.hash(rawSignature);\n      transaction.setSignature({\n        id: ArweaveUtils.bufferTob64Url(id),\n        owner: jwk.n,\n        signature: ArweaveUtils.bufferTob64Url(rawSignature)\n      });\n    }\n  }\n\n  async verify(transaction) {\n    const signaturePayload = await transaction.getSignatureData();\n    /**\n     * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n     * to be recalculated from the signature and checked against the transaction ID.\n     */\n\n    const rawSignature = transaction.get(\"signature\", {\n      decode: true,\n      string: false\n    });\n    const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));\n\n    if (transaction.id !== expectedId) {\n      throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);\n    }\n    /**\n     * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).\n     */\n\n\n    return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);\n  }\n\n  async post(transaction) {\n    if (typeof transaction === \"string\") {\n      transaction = new transaction_1.default(JSON.parse(transaction));\n    } else if (typeof transaction.readInt32BE === \"function\") {\n      transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n    } else if (typeof transaction === \"object\" && !(transaction instanceof transaction_1.default)) {\n      transaction = new transaction_1.default(transaction);\n    }\n\n    if (!(transaction instanceof transaction_1.default)) {\n      throw new Error(`Must be Transaction object`);\n    }\n\n    if (!transaction.chunks) {\n      await transaction.prepareChunks(transaction.data);\n    }\n\n    const uploader = await this.getUploader(transaction); // Emulate existing error & return value behaviour.\n\n    try {\n      while (!uploader.isComplete) {\n        await uploader.uploadChunk();\n      }\n    } catch (e) {\n      if (uploader.lastResponseStatus > 0) {\n        return {\n          status: uploader.lastResponseStatus,\n          statusText: uploader.lastResponseError,\n          data: {\n            error: uploader.lastResponseError\n          }\n        };\n      }\n\n      throw e;\n    }\n\n    return {\n      status: 200,\n      statusText: \"OK\",\n      data: {}\n    };\n  }\n  /**\n   * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n   * and the ability to resume.\n   *\n   * Usage example:\n   *\n   * ```\n   * const uploader = arweave.transactions.getUploader(transaction);\n   * while (!uploader.isComplete) {\n   *   await uploader.uploadChunk();\n   *   console.log(`${uploader.pctComplete}%`);\n   * }\n   * ```\n   *\n   * @param upload a Transaction object, a previously save progress object, or a transaction id.\n   * @param data the data of the transaction. Required when resuming an upload.\n   */\n\n\n  async getUploader(upload, data) {\n    let uploader;\n\n    if (upload instanceof transaction_1.default) {\n      uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n    } else {\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      }\n\n      if (!data || !(data instanceof Uint8Array)) {\n        throw new Error(`Must provide data when resuming upload`);\n      }\n\n      if (typeof upload === \"string\") {\n        upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n      } // upload should be a serialized upload.\n\n\n      uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n    }\n\n    return uploader;\n  }\n  /**\n   * Async generator version of uploader\n   *\n   * Usage example:\n   *\n   * ```\n   * for await (const uploader of arweave.transactions.upload(tx)) {\n   *  console.log(`${uploader.pctComplete}%`);\n   * }\n   * ```\n   *\n   * @param upload a Transaction object, a previously save uploader, or a transaction id.\n   * @param data the data of the transaction. Required when resuming an upload.\n   */\n\n\n  upload(upload, data) {\n    return __asyncGenerator(this, arguments, function* upload_1() {\n      const uploader = yield __await(this.getUploader(upload, data));\n\n      while (!uploader.isComplete) {\n        yield __await(uploader.uploadChunk());\n        yield yield __await(uploader);\n      }\n\n      return yield __await(uploader);\n    });\n  }\n\n}\n\nexports.default = Transactions;","map":{"version":3,"sources":["../../../src/common/transactions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = __importStar(require(\"./lib/error\"));\nconst transaction_1 = __importDefault(require(\"./lib/transaction\"));\nconst ArweaveUtils = __importStar(require(\"./lib/utils\"));\nconst transaction_uploader_1 = require(\"./lib/transaction-uploader\");\nrequire(\"arconnect\");\nclass Transactions {\n    constructor(api, crypto, chunks) {\n        this.api = api;\n        this.crypto = crypto;\n        this.chunks = chunks;\n    }\n    getTransactionAnchor() {\n        return this.api.get(`tx_anchor`).then((response) => {\n            return response.data;\n        });\n    }\n    getPrice(byteSize, targetAddress) {\n        let endpoint = targetAddress\n            ? `price/${byteSize}/${targetAddress}`\n            : `price/${byteSize}`;\n        return this.api\n            .get(endpoint, {\n            transformResponse: [\n                /**\n                 * We need to specify a response transformer to override\n                 * the default JSON.parse behaviour, as this causes\n                 * winston to be converted to a number and we want to\n                 * return it as a winston string.\n                 * @param data\n                 */\n                function (data) {\n                    return data;\n                },\n            ],\n        })\n            .then((response) => {\n            return response.data;\n        });\n    }\n    async get(id) {\n        const response = await this.api.get(`tx/${id}`);\n        if (response.status == 200) {\n            const data_size = parseInt(response.data.data_size);\n            if (response.data.format >= 2 &&\n                data_size > 0 &&\n                data_size <= 1024 * 1024 * 12) {\n                const data = await this.getData(id);\n                return new transaction_1.default(Object.assign(Object.assign({}, response.data), { data }));\n            }\n            return new transaction_1.default(Object.assign(Object.assign({}, response.data), { format: response.data.format || 1 }));\n        }\n        if (response.status == 202) {\n            throw new error_1.default(\"TX_PENDING\" /* TX_PENDING */);\n        }\n        if (response.status == 404) {\n            throw new error_1.default(\"TX_NOT_FOUND\" /* TX_NOT_FOUND */);\n        }\n        if (response.status == 410) {\n            throw new error_1.default(\"TX_FAILED\" /* TX_FAILED */);\n        }\n        throw new error_1.default(\"TX_INVALID\" /* TX_INVALID */);\n    }\n    fromRaw(attributes) {\n        return new transaction_1.default(attributes);\n    }\n    async search(tagName, tagValue) {\n        return this.api\n            .post(`arql`, {\n            op: \"equals\",\n            expr1: tagName,\n            expr2: tagValue,\n        })\n            .then((response) => {\n            if (!response.data) {\n                return [];\n            }\n            return response.data;\n        });\n    }\n    getStatus(id) {\n        return this.api.get(`tx/${id}/status`).then((response) => {\n            if (response.status == 200) {\n                return {\n                    status: 200,\n                    confirmed: response.data,\n                };\n            }\n            return {\n                status: response.status,\n                confirmed: null,\n            };\n        });\n    }\n    async getData(id, options) {\n        // Attempt to download from /txid, fall back to downloading chunks.\n        const resp = await this.api.get(`${id}`, { responseType: \"arraybuffer\" });\n        let data = undefined;\n        if (resp.status === 200) {\n            data = new Uint8Array(resp.data);\n        }\n        if (resp.status === 400 && error_1.getError(resp) === \"tx_data_too_big\") {\n            data = await this.chunks.downloadChunkedData(id);\n        }\n        // If we don't have data, throw an exception. Previously we\n        // just returned an empty data object.\n        if (!data) {\n            if (resp.status == 202) {\n                throw new error_1.default(\"TX_PENDING\" /* TX_PENDING */);\n            }\n            if (resp.status == 404) {\n                throw new error_1.default(\"TX_NOT_FOUND\" /* TX_NOT_FOUND */);\n            }\n            if (resp.status == 410) {\n                throw new error_1.default(\"TX_FAILED\" /* TX_FAILED */);\n            }\n            throw new Error(`Unable to get data: ${resp.status} - ${error_1.getError(resp)}`);\n        }\n        if (options && options.decode && !options.string) {\n            return data;\n        }\n        if (options && options.decode && options.string) {\n            return ArweaveUtils.bufferToString(data);\n        }\n        // Since decode wasn't requested, caller expects b64url encoded data.\n        return ArweaveUtils.bufferTob64Url(data);\n    }\n    async sign(transaction, jwk, options) {\n        // @ts-ignore\n        if (!jwk && (!window || !window.arweaveWallet)) {\n            throw new Error(`A new Arweave transaction must provide the jwk parameter.`);\n        }\n        else if (!jwk || jwk === \"use_wallet\") {\n            try {\n                const existingPermissions = await window.arweaveWallet.getPermissions();\n                if (!existingPermissions.includes(\"SIGN_TRANSACTION\"))\n                    await window.arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n            }\n            catch (_a) {\n                // Permission is already granted\n            }\n            const signedTransaction = await window.arweaveWallet.sign(transaction, options);\n            transaction.setSignature({\n                id: signedTransaction.id,\n                owner: signedTransaction.owner,\n                tags: signedTransaction.tags,\n                signature: signedTransaction.signature,\n            });\n        }\n        else {\n            transaction.setOwner(jwk.n);\n            let dataToSign = await transaction.getSignatureData();\n            let rawSignature = await this.crypto.sign(jwk, dataToSign, options);\n            let id = await this.crypto.hash(rawSignature);\n            transaction.setSignature({\n                id: ArweaveUtils.bufferTob64Url(id),\n                owner: jwk.n,\n                signature: ArweaveUtils.bufferTob64Url(rawSignature),\n            });\n        }\n    }\n    async verify(transaction) {\n        const signaturePayload = await transaction.getSignatureData();\n        /**\n         * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n         * to be recalculated from the signature and checked against the transaction ID.\n         */\n        const rawSignature = transaction.get(\"signature\", {\n            decode: true,\n            string: false,\n        });\n        const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));\n        if (transaction.id !== expectedId) {\n            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);\n        }\n        /**\n         * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).\n         */\n        return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);\n    }\n    async post(transaction) {\n        if (typeof transaction === \"string\") {\n            transaction = new transaction_1.default(JSON.parse(transaction));\n        }\n        else if (typeof transaction.readInt32BE === \"function\") {\n            transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n        }\n        else if (typeof transaction === \"object\" &&\n            !(transaction instanceof transaction_1.default)) {\n            transaction = new transaction_1.default(transaction);\n        }\n        if (!(transaction instanceof transaction_1.default)) {\n            throw new Error(`Must be Transaction object`);\n        }\n        if (!transaction.chunks) {\n            await transaction.prepareChunks(transaction.data);\n        }\n        const uploader = await this.getUploader(transaction);\n        // Emulate existing error & return value behaviour.\n        try {\n            while (!uploader.isComplete) {\n                await uploader.uploadChunk();\n            }\n        }\n        catch (e) {\n            if (uploader.lastResponseStatus > 0) {\n                return {\n                    status: uploader.lastResponseStatus,\n                    statusText: uploader.lastResponseError,\n                    data: {\n                        error: uploader.lastResponseError,\n                    },\n                };\n            }\n            throw e;\n        }\n        return {\n            status: 200,\n            statusText: \"OK\",\n            data: {},\n        };\n    }\n    /**\n     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n     * and the ability to resume.\n     *\n     * Usage example:\n     *\n     * ```\n     * const uploader = arweave.transactions.getUploader(transaction);\n     * while (!uploader.isComplete) {\n     *   await uploader.uploadChunk();\n     *   console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save progress object, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async getUploader(upload, data) {\n        let uploader;\n        if (upload instanceof transaction_1.default) {\n            uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n        }\n        else {\n            if (data instanceof ArrayBuffer) {\n                data = new Uint8Array(data);\n            }\n            if (!data || !(data instanceof Uint8Array)) {\n                throw new Error(`Must provide data when resuming upload`);\n            }\n            if (typeof upload === \"string\") {\n                upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n            }\n            // upload should be a serialized upload.\n            uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n        }\n        return uploader;\n    }\n    /**\n     * Async generator version of uploader\n     *\n     * Usage example:\n     *\n     * ```\n     * for await (const uploader of arweave.transactions.upload(tx)) {\n     *  console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save uploader, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    upload(upload, data) {\n        return __asyncGenerator(this, arguments, function* upload_1() {\n            const uploader = yield __await(this.getUploader(upload, data));\n            while (!uploader.isComplete) {\n                yield __await(uploader.uploadChunk());\n                yield yield __await(uploader);\n            }\n            return yield __await(uploader);\n        });\n    }\n}\nexports.default = Transactions;\n//# sourceMappingURL=transactions.js.map"]},"metadata":{},"sourceType":"script"}