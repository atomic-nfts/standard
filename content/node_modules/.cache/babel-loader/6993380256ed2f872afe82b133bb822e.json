{"ast":null,"code":"/* eslint-disable no-bitwise */\nexport const binaryStringToUint8Array = str => {\n  const len = str.length;\n  const uint8Array = new Uint8Array(len);\n\n  for (let i = 0; i < len; i += 1) {\n    uint8Array[i] = str.charCodeAt(i);\n  }\n\n  return uint8Array;\n};\nexport const uint8ArrayToBinaryString = uint8Array => String.fromCharCode.apply(null, uint8Array);\nexport const hexStringToUint8Array = str => new Uint8Array(str.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\nexport const uint8ArrayToHexString = uint8Array => Array.prototype.map.call(uint8Array, x => `00${x.toString(16)}`.slice(-2)).join('');\nexport const typedArrayToUint8Array = typedArray => new Uint8Array(typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength));\nexport const bnToUint8Array = bn => {\n  const numArray = bn.toArray(); // Remove useless sign\n\n  if (!bn.negative && numArray[0] & 0x80) {\n    numArray.unshift(0);\n  }\n\n  return Uint8Array.from(numArray);\n};\nexport const uint8ArrayToInteger = uint8Array => {\n  if (uint8Array.byteLength > 32) {\n    throw new Error('Only 32 byte integers is supported');\n  }\n\n  let integer = 0;\n  let byteCount = 0;\n\n  do {\n    integer = (integer << 8) + uint8Array[byteCount];\n    byteCount += 1;\n  } while (uint8Array.byteLength > byteCount);\n\n  return integer;\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/util/binary.js"],"names":["binaryStringToUint8Array","str","len","length","uint8Array","Uint8Array","i","charCodeAt","uint8ArrayToBinaryString","String","fromCharCode","apply","hexStringToUint8Array","match","map","byte","parseInt","uint8ArrayToHexString","Array","prototype","call","x","toString","slice","join","typedArrayToUint8Array","typedArray","buffer","byteOffset","byteLength","bnToUint8Array","bn","numArray","toArray","negative","unshift","from","uint8ArrayToInteger","Error","integer","byteCount"],"mappings":"AAAA;AACA,OAAO,MAAMA,wBAAwB,GAAGC,GAAG,IAAI;AAC7C,QAAMC,GAAG,GAAGD,GAAG,CAACE,MAAhB;AACA,QAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAeH,GAAf,CAAnB;;AAEA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,GAApB,EAAyBI,CAAC,IAAI,CAA9B,EAAiC;AAC/BF,IAAAA,UAAU,CAACE,CAAD,CAAV,GAAgBL,GAAG,CAACM,UAAJ,CAAeD,CAAf,CAAhB;AACD;;AAED,SAAOF,UAAP;AACD,CATM;AAUP,OAAO,MAAMI,wBAAwB,GAAGJ,UAAU,IAAIK,MAAM,CAACC,YAAP,CAAoBC,KAApB,CAA0B,IAA1B,EAAgCP,UAAhC,CAA/C;AACP,OAAO,MAAMQ,qBAAqB,GAAGX,GAAG,IAAI,IAAII,UAAJ,CAAeJ,GAAG,CAACY,KAAJ,CAAU,SAAV,EAAqBC,GAArB,CAAyBC,IAAI,IAAIC,QAAQ,CAACD,IAAD,EAAO,EAAP,CAAzC,CAAf,CAArC;AACP,OAAO,MAAME,qBAAqB,GAAGb,UAAU,IAAIc,KAAK,CAACC,SAAN,CAAgBL,GAAhB,CAAoBM,IAApB,CAAyBhB,UAAzB,EAAqCiB,CAAC,IAAK,KAAIA,CAAC,CAACC,QAAF,CAAW,EAAX,CAAe,EAApB,CAAsBC,KAAtB,CAA4B,CAAC,CAA7B,CAA1C,EAA2EC,IAA3E,CAAgF,EAAhF,CAA5C;AACP,OAAO,MAAMC,sBAAsB,GAAGC,UAAU,IAAI,IAAIrB,UAAJ,CAAeqB,UAAU,CAACC,MAAX,CAAkBJ,KAAlB,CAAwBG,UAAU,CAACE,UAAnC,EAA+CF,UAAU,CAACE,UAAX,GAAwBF,UAAU,CAACG,UAAlF,CAAf,CAA7C;AACP,OAAO,MAAMC,cAAc,GAAGC,EAAE,IAAI;AAClC,QAAMC,QAAQ,GAAGD,EAAE,CAACE,OAAH,EAAjB,CADkC,CACH;;AAE/B,MAAI,CAACF,EAAE,CAACG,QAAJ,IAAgBF,QAAQ,CAAC,CAAD,CAAR,GAAc,IAAlC,EAAwC;AACtCA,IAAAA,QAAQ,CAACG,OAAT,CAAiB,CAAjB;AACD;;AAED,SAAO9B,UAAU,CAAC+B,IAAX,CAAgBJ,QAAhB,CAAP;AACD,CARM;AASP,OAAO,MAAMK,mBAAmB,GAAGjC,UAAU,IAAI;AAC/C,MAAIA,UAAU,CAACyB,UAAX,GAAwB,EAA5B,EAAgC;AAC9B,UAAM,IAAIS,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,SAAS,GAAG,CAAhB;;AAEA,KAAG;AACDD,IAAAA,OAAO,GAAG,CAACA,OAAO,IAAI,CAAZ,IAAiBnC,UAAU,CAACoC,SAAD,CAArC;AACAA,IAAAA,SAAS,IAAI,CAAb;AACD,GAHD,QAGSpC,UAAU,CAACyB,UAAX,GAAwBW,SAHjC;;AAKA,SAAOD,OAAP;AACD,CAdM","sourcesContent":["/* eslint-disable no-bitwise */\nexport const binaryStringToUint8Array = str => {\n  const len = str.length;\n  const uint8Array = new Uint8Array(len);\n\n  for (let i = 0; i < len; i += 1) {\n    uint8Array[i] = str.charCodeAt(i);\n  }\n\n  return uint8Array;\n};\nexport const uint8ArrayToBinaryString = uint8Array => String.fromCharCode.apply(null, uint8Array);\nexport const hexStringToUint8Array = str => new Uint8Array(str.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\nexport const uint8ArrayToHexString = uint8Array => Array.prototype.map.call(uint8Array, x => `00${x.toString(16)}`.slice(-2)).join('');\nexport const typedArrayToUint8Array = typedArray => new Uint8Array(typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength));\nexport const bnToUint8Array = bn => {\n  const numArray = bn.toArray(); // Remove useless sign\n\n  if (!bn.negative && numArray[0] & 0x80) {\n    numArray.unshift(0);\n  }\n\n  return Uint8Array.from(numArray);\n};\nexport const uint8ArrayToInteger = uint8Array => {\n  if (uint8Array.byteLength > 32) {\n    throw new Error('Only 32 byte integers is supported');\n  }\n\n  let integer = 0;\n  let byteCount = 0;\n\n  do {\n    integer = (integer << 8) + uint8Array[byteCount];\n    byteCount += 1;\n  } while (uint8Array.byteLength > byteCount);\n\n  return integer;\n};"]},"metadata":{},"sourceType":"module"}