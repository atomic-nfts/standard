{"ast":null,"code":"var MultiRange = require('multi-integer-range').MultiRange;\n\nvar getPixels = require('get-pixels-frame-info-update');\n\nvar savePixels = require('save-pixels-jpeg-js-upgrade');\n\nfunction nopromises() {\n  throw new Error('Promises not supported in your environment. ' + 'Use the callback argument or a Promise polyfill.');\n}\n\nvar brokenPromise = {\n  then: nopromises,\n  catch: nopromises\n};\n\nfunction gifFrames(options, callback) {\n  options = options || {};\n\n  callback = callback || function () {};\n\n  var promise;\n  var resolve;\n  var reject;\n\n  if (typeof Promise === 'function') {\n    promise = new Promise(function (_resolve, _reject) {\n      resolve = function (res) {\n        callback(null, res);\n\n        _resolve(res);\n      };\n\n      reject = function (err) {\n        callback(err);\n\n        _reject(err);\n      };\n    });\n  } else {\n    promise = brokenPromise;\n\n    resolve = function (res) {\n      callback(null, res);\n    };\n\n    reject = callback;\n  }\n\n  var url = options.url;\n\n  if (!url) {\n    reject(new Error('\"url\" option is required.'));\n    return promise;\n  }\n\n  var frames = options.frames;\n\n  if (!frames && frames !== 0) {\n    reject(new Error('\"frames\" option is required.'));\n    return promise;\n  }\n\n  var outputType = options.outputType || 'jpg';\n  var quality = options.quality;\n  var cumulative = options.cumulative;\n  var acceptedFrames = frames === 'all' ? 'all' : new MultiRange(frames); // Necessary to check if we're in Node or the browser until this is fixed:\n  // https://github.com/scijs/get-pixels/issues/33\n\n  var inputType = typeof window === 'undefined' ? 'image/gif' : '.GIF';\n  getPixels(url, inputType, function (err, pixels, framesInfo) {\n    if (err) {\n      reject(err);\n      return;\n    }\n\n    if (pixels.shape.length < 4) {\n      reject(new Error('\"url\" input should be multi-frame GIF.'));\n      return;\n    }\n\n    var frameData = [];\n    var maxAccumulatedFrame = 0;\n\n    for (var i = 0; i < pixels.shape[0]; i++) {\n      if (acceptedFrames !== 'all' && !acceptedFrames.has(i)) {\n        continue;\n      }\n\n      (function (frameIndex) {\n        frameData.push({\n          getImage: function () {\n            if (cumulative && frameIndex > maxAccumulatedFrame) {\n              // for each frame, replace any invisible pixel with\n              // the corresponding pixel from the previous frame (beginning\n              // with the second frame).\n              // to avoid doing too much work at once we only compute the\n              // frames up to and including the requested frame.\n              var lastFrame = pixels.pick(maxAccumulatedFrame);\n\n              for (var f = maxAccumulatedFrame + 1; f <= frameIndex; f++) {\n                var frame = pixels.pick(f);\n\n                for (var x = 0; x < frame.shape[0]; x++) {\n                  for (var y = 0; y < frame.shape[1]; y++) {\n                    if (frame.get(x, y, 3) === 0) {\n                      // if alpha is fully transparent, use the pixel\n                      // from the last frame\n                      frame.set(x, y, 0, lastFrame.get(x, y, 0));\n                      frame.set(x, y, 1, lastFrame.get(x, y, 1));\n                      frame.set(x, y, 2, lastFrame.get(x, y, 2));\n                      frame.set(x, y, 3, lastFrame.get(x, y, 3));\n                    }\n                  }\n                }\n\n                lastFrame = frame;\n              }\n\n              maxAccumulatedFrame = frameIndex;\n            }\n\n            return savePixels(pixels.pick(frameIndex), outputType, {\n              quality: quality\n            });\n          },\n          frameIndex: frameIndex,\n          frameInfo: framesInfo && framesInfo[frameIndex]\n        });\n      })(i);\n    }\n\n    resolve(frameData);\n  });\n  return promise;\n}\n\nmodule.exports = gifFrames;","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/gif-frames/gif-frames.js"],"names":["MultiRange","require","getPixels","savePixels","nopromises","Error","brokenPromise","then","catch","gifFrames","options","callback","promise","resolve","reject","Promise","_resolve","_reject","res","err","url","frames","outputType","quality","cumulative","acceptedFrames","inputType","window","pixels","framesInfo","shape","length","frameData","maxAccumulatedFrame","i","has","frameIndex","push","getImage","lastFrame","pick","f","frame","x","y","get","set","frameInfo","module","exports"],"mappings":"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","sourcesContent":["var MultiRange = require('multi-integer-range').MultiRange;\nvar getPixels = require('get-pixels-frame-info-update');\nvar savePixels = require('save-pixels-jpeg-js-upgrade');\n\nfunction nopromises () {\n  throw new Error(\n    'Promises not supported in your environment. ' +\n    'Use the callback argument or a Promise polyfill.'\n  );\n}\n\nvar brokenPromise = {\n  then: nopromises,\n  catch: nopromises\n};\n\nfunction gifFrames (options, callback) {\n  options = options || {};\n  callback = callback || function () {};\n\n  var promise;\n  var resolve;\n  var reject;\n  if (typeof Promise === 'function') {\n    promise = new Promise(function (_resolve, _reject) {\n      resolve = function (res) {\n        callback(null, res);\n        _resolve(res);\n      };\n      reject = function (err) {\n        callback(err);\n        _reject(err);\n      };\n    });\n  } else {\n    promise = brokenPromise;\n    resolve = function (res) {\n      callback(null, res);\n    };\n    reject = callback;\n  }\n\n  var url = options.url;\n  if (!url) {\n    reject(new Error('\"url\" option is required.'));\n    return promise;\n  }\n  var frames = options.frames;\n  if (!frames && frames !== 0) {\n    reject(new Error('\"frames\" option is required.'));\n    return promise;\n  }\n  var outputType = options.outputType || 'jpg';\n  var quality = options.quality;\n  var cumulative = options.cumulative;\n\n  var acceptedFrames = frames === 'all' ? 'all' : new MultiRange(frames);\n\n  // Necessary to check if we're in Node or the browser until this is fixed:\n  // https://github.com/scijs/get-pixels/issues/33\n  var inputType = typeof window === 'undefined' ? 'image/gif' : '.GIF';\n  getPixels(url, inputType, function (err, pixels, framesInfo) {\n    if (err) {\n      reject(err);\n      return;\n    }\n    if (pixels.shape.length < 4) {\n      reject(new Error('\"url\" input should be multi-frame GIF.'));\n      return;\n    }\n    var frameData = [];\n    var maxAccumulatedFrame = 0;\n    for (var i = 0; i < pixels.shape[0]; i++) {\n      if (acceptedFrames !== 'all' && !acceptedFrames.has(i)) {\n        continue;\n      }\n      (function (frameIndex) {\n        frameData.push({\n          getImage: function () {\n            if (cumulative && frameIndex > maxAccumulatedFrame) {\n              // for each frame, replace any invisible pixel with\n              // the corresponding pixel from the previous frame (beginning\n              // with the second frame).\n              // to avoid doing too much work at once we only compute the\n              // frames up to and including the requested frame.\n              var lastFrame = pixels.pick(maxAccumulatedFrame);\n              for (var f = maxAccumulatedFrame + 1; f <= frameIndex; f++) {\n                var frame = pixels.pick(f);\n                for (var x = 0; x < frame.shape[0]; x++) {\n                  for (var y = 0; y < frame.shape[1]; y++) {\n                    if (frame.get(x, y, 3) === 0) {\n                      // if alpha is fully transparent, use the pixel\n                      // from the last frame\n                      frame.set(x, y, 0, lastFrame.get(x, y, 0));\n                      frame.set(x, y, 1, lastFrame.get(x, y, 1));\n                      frame.set(x, y, 2, lastFrame.get(x, y, 2));\n                      frame.set(x, y, 3, lastFrame.get(x, y, 3));\n                    }\n                  }\n                }\n                lastFrame = frame;\n              }\n              maxAccumulatedFrame = frameIndex;\n            }\n            return savePixels(pixels.pick(frameIndex), outputType, {\n              quality: quality\n            });\n          },\n          frameIndex: frameIndex,\n          frameInfo: framesInfo && framesInfo[frameIndex]\n        });\n      })(i);\n    }\n    resolve(frameData);\n  });\n\n  return promise;\n}\n\nmodule.exports = gifFrames;\n"]},"metadata":{},"sourceType":"script"}