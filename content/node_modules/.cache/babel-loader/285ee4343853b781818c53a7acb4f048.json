{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;\n/**\n * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}\n */\n\nvar common_1 = require(\"../common\");\n\nvar utils_1 = require(\"./utils\");\n\nvar util_1 = require(\"util\");\n\nexports.MAX_CHUNK_SIZE = 256 * 1024;\nexports.MIN_CHUNK_SIZE = 32 * 1024;\nvar NOTE_SIZE = 32;\nvar HASH_SIZE = 32;\n/**\n * Takes the input data and chunks it into (mostly) equal sized chunks.\n * The last chunk will be a bit smaller as it contains the remainder\n * from the chunking process.\n */\n\nfunction chunkData(_x) {\n  return _chunkData.apply(this, arguments);\n}\n\nfunction _chunkData() {\n  _chunkData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n    var chunks, rest, cursor, chunkSize, nextChunkSize, chunk, dataHash;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            chunks = [];\n            rest = data;\n            cursor = 0;\n\n          case 3:\n            if (!(rest.byteLength >= exports.MAX_CHUNK_SIZE)) {\n              _context.next = 16;\n              break;\n            }\n\n            chunkSize = exports.MAX_CHUNK_SIZE; // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,\n            // then adjust the amount we put in this 2nd last chunk.\n\n            nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;\n\n            if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {\n              chunkSize = Math.ceil(rest.byteLength / 2); // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)\n            }\n\n            chunk = rest.slice(0, chunkSize);\n            _context.next = 10;\n            return common_1.default.crypto.hash(chunk);\n\n          case 10:\n            dataHash = _context.sent;\n            cursor += chunk.byteLength;\n            chunks.push({\n              dataHash: dataHash,\n              minByteRange: cursor - chunk.byteLength,\n              maxByteRange: cursor\n            });\n            rest = rest.slice(chunkSize);\n            _context.next = 3;\n            break;\n\n          case 16:\n            _context.t0 = chunks;\n            _context.next = 19;\n            return common_1.default.crypto.hash(rest);\n\n          case 19:\n            _context.t1 = _context.sent;\n            _context.t2 = cursor;\n            _context.t3 = cursor + rest.byteLength;\n            _context.t4 = {\n              dataHash: _context.t1,\n              minByteRange: _context.t2,\n              maxByteRange: _context.t3\n            };\n\n            _context.t0.push.call(_context.t0, _context.t4);\n\n            return _context.abrupt(\"return\", chunks);\n\n          case 25:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _chunkData.apply(this, arguments);\n}\n\nexports.chunkData = chunkData;\n\nfunction generateLeaves(_x2) {\n  return _generateLeaves.apply(this, arguments);\n}\n\nfunction _generateLeaves() {\n  _generateLeaves = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(chunks) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", Promise.all(chunks.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n                var dataHash, minByteRange, maxByteRange;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        dataHash = _ref.dataHash, minByteRange = _ref.minByteRange, maxByteRange = _ref.maxByteRange;\n                        _context2.t0 = hash;\n                        _context2.next = 4;\n                        return Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))]);\n\n                      case 4:\n                        _context2.t1 = _context2.sent;\n                        _context2.next = 7;\n                        return (0, _context2.t0)(_context2.t1);\n\n                      case 7:\n                        _context2.t2 = _context2.sent;\n                        _context2.t3 = dataHash;\n                        _context2.t4 = minByteRange;\n                        _context2.t5 = maxByteRange;\n                        return _context2.abrupt(\"return\", {\n                          type: \"leaf\",\n                          id: _context2.t2,\n                          dataHash: _context2.t3,\n                          minByteRange: _context2.t4,\n                          maxByteRange: _context2.t5\n                        });\n\n                      case 12:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x16) {\n                return _ref2.apply(this, arguments);\n              };\n            }())));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _generateLeaves.apply(this, arguments);\n}\n\nexports.generateLeaves = generateLeaves;\n/**\n * Builds an arweave merkle tree and gets the root hash for the given input.\n */\n\nfunction computeRootHash(_x3) {\n  return _computeRootHash.apply(this, arguments);\n}\n\nfunction _computeRootHash() {\n  _computeRootHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n    var rootNode;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return generateTree(data);\n\n          case 2:\n            rootNode = _context4.sent;\n            return _context4.abrupt(\"return\", rootNode.id);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _computeRootHash.apply(this, arguments);\n}\n\nexports.computeRootHash = computeRootHash;\n\nfunction generateTree(_x4) {\n  return _generateTree.apply(this, arguments);\n}\n\nfunction _generateTree() {\n  _generateTree = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(data) {\n    var rootNode;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.t0 = buildLayers;\n            _context5.t1 = generateLeaves;\n            _context5.next = 4;\n            return chunkData(data);\n\n          case 4:\n            _context5.t2 = _context5.sent;\n            _context5.next = 7;\n            return (0, _context5.t1)(_context5.t2);\n\n          case 7:\n            _context5.t3 = _context5.sent;\n            _context5.next = 10;\n            return (0, _context5.t0)(_context5.t3);\n\n          case 10:\n            rootNode = _context5.sent;\n            return _context5.abrupt(\"return\", rootNode);\n\n          case 12:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _generateTree.apply(this, arguments);\n}\n\nexports.generateTree = generateTree;\n/**\n * Generates the data_root, chunks & proofs\n * needed for a transaction.\n *\n * This also checks if the last chunk is a zero-length\n * chunk and discards that chunk and proof if so.\n * (we do not need to upload this zero length chunk)\n *\n * @param data\n */\n\nfunction generateTransactionChunks(_x5) {\n  return _generateTransactionChunks.apply(this, arguments);\n}\n\nfunction _generateTransactionChunks() {\n  _generateTransactionChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(data) {\n    var chunks, leaves, root, proofs, lastChunk;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return chunkData(data);\n\n          case 2:\n            chunks = _context6.sent;\n            _context6.next = 5;\n            return generateLeaves(chunks);\n\n          case 5:\n            leaves = _context6.sent;\n            _context6.next = 8;\n            return buildLayers(leaves);\n\n          case 8:\n            root = _context6.sent;\n            _context6.next = 11;\n            return generateProofs(root);\n\n          case 11:\n            proofs = _context6.sent;\n            // Discard the last chunk & proof if it's zero length.\n            lastChunk = chunks.slice(-1)[0];\n\n            if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {\n              chunks.splice(chunks.length - 1, 1);\n              proofs.splice(proofs.length - 1, 1);\n            }\n\n            return _context6.abrupt(\"return\", {\n              data_root: root.id,\n              chunks: chunks,\n              proofs: proofs\n            });\n\n          case 15:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _generateTransactionChunks.apply(this, arguments);\n}\n\nexports.generateTransactionChunks = generateTransactionChunks;\n/**\n * Starting with the bottom layer of leaf nodes, hash every second pair\n * into a new branch node, push those branch nodes onto a new layer,\n * and then recurse, building up the tree to it's root, where the\n * layer only consists of two items.\n */\n\nfunction buildLayers(_x6) {\n  return _buildLayers.apply(this, arguments);\n}\n\nfunction _buildLayers() {\n  _buildLayers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(nodes) {\n    var level,\n        root,\n        nextLayer,\n        i,\n        _args7 = arguments;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            level = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : 0;\n\n            if (!(nodes.length < 2)) {\n              _context7.next = 6;\n              break;\n            }\n\n            _context7.next = 4;\n            return hashBranch(nodes[0], nodes[1]);\n\n          case 4:\n            root = _context7.sent;\n            return _context7.abrupt(\"return\", root);\n\n          case 6:\n            nextLayer = [];\n            i = 0;\n\n          case 8:\n            if (!(i < nodes.length)) {\n              _context7.next = 17;\n              break;\n            }\n\n            _context7.t0 = nextLayer;\n            _context7.next = 12;\n            return hashBranch(nodes[i], nodes[i + 1]);\n\n          case 12:\n            _context7.t1 = _context7.sent;\n\n            _context7.t0.push.call(_context7.t0, _context7.t1);\n\n          case 14:\n            i += 2;\n            _context7.next = 8;\n            break;\n\n          case 17:\n            return _context7.abrupt(\"return\", buildLayers(nextLayer, level + 1));\n\n          case 18:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _buildLayers.apply(this, arguments);\n}\n\nexports.buildLayers = buildLayers;\n/**\n * Recursively search through all branches of the tree,\n * and generate a proof for each leaf node.\n */\n\nfunction generateProofs(root) {\n  var proofs = resolveBranchProofs(root);\n\n  if (!Array.isArray(proofs)) {\n    return [proofs];\n  }\n\n  return arrayFlatten(proofs);\n}\n\nexports.generateProofs = generateProofs;\n\nfunction resolveBranchProofs(node) {\n  var proof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (node.type == \"leaf\") {\n    return {\n      offset: node.maxByteRange - 1,\n      proof: utils_1.concatBuffers([proof, node.dataHash, intToBuffer(node.maxByteRange)])\n    };\n  }\n\n  if (node.type == \"branch\") {\n    var partialProof = utils_1.concatBuffers([proof, node.leftChild.id, node.rightChild.id, intToBuffer(node.byteRange)]);\n    return [resolveBranchProofs(node.leftChild, partialProof, depth + 1), resolveBranchProofs(node.rightChild, partialProof, depth + 1)];\n  }\n\n  throw new Error(\"Unexpected node type\");\n}\n\nfunction arrayFlatten(input) {\n  var flat = [];\n  input.forEach(function (item) {\n    if (Array.isArray(item)) {\n      flat.push.apply(flat, _toConsumableArray(arrayFlatten(item)));\n    } else {\n      flat.push(item);\n    }\n  });\n  return flat;\n}\n\nexports.arrayFlatten = arrayFlatten;\n\nfunction hashBranch(_x7, _x8) {\n  return _hashBranch.apply(this, arguments);\n}\n\nfunction _hashBranch() {\n  _hashBranch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(left, right) {\n    var branch;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (right) {\n              _context8.next = 2;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", left);\n\n          case 2:\n            _context8.t0 = hash;\n            _context8.next = 5;\n            return hash(left.id);\n\n          case 5:\n            _context8.t1 = _context8.sent;\n            _context8.next = 8;\n            return hash(right.id);\n\n          case 8:\n            _context8.t2 = _context8.sent;\n            _context8.next = 11;\n            return hash(intToBuffer(left.maxByteRange));\n\n          case 11:\n            _context8.t3 = _context8.sent;\n            _context8.t4 = [_context8.t1, _context8.t2, _context8.t3];\n            _context8.next = 15;\n            return (0, _context8.t0)(_context8.t4);\n\n          case 15:\n            _context8.t5 = _context8.sent;\n            _context8.t6 = left.maxByteRange;\n            _context8.t7 = right.maxByteRange;\n            _context8.t8 = left;\n            _context8.t9 = right;\n            branch = {\n              type: \"branch\",\n              id: _context8.t5,\n              byteRange: _context8.t6,\n              maxByteRange: _context8.t7,\n              leftChild: _context8.t8,\n              rightChild: _context8.t9\n            };\n            return _context8.abrupt(\"return\", branch);\n\n          case 22:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _hashBranch.apply(this, arguments);\n}\n\nfunction hash(_x9) {\n  return _hash.apply(this, arguments);\n}\n\nfunction _hash() {\n  _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(data) {\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            if (Array.isArray(data)) {\n              data = common_1.default.utils.concatBuffers(data);\n            }\n\n            _context9.t0 = Uint8Array;\n            _context9.next = 4;\n            return common_1.default.crypto.hash(data);\n\n          case 4:\n            _context9.t1 = _context9.sent;\n            return _context9.abrupt(\"return\", new _context9.t0(_context9.t1));\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _hash.apply(this, arguments);\n}\n\nfunction intToBuffer(note) {\n  var buffer = new Uint8Array(NOTE_SIZE);\n\n  for (var i = buffer.length - 1; i >= 0; i--) {\n    var byte = note % 256;\n    buffer[i] = byte;\n    note = (note - byte) / 256;\n  }\n\n  return buffer;\n}\n\nexports.intToBuffer = intToBuffer;\n\nfunction bufferToInt(buffer) {\n  var value = 0;\n\n  for (var i = 0; i < buffer.length; i++) {\n    value *= 256;\n    value += buffer[i];\n  }\n\n  return value;\n}\n\nexports.bufferToInt = bufferToInt;\n\nvar arrayCompare = function arrayCompare(a, b) {\n  return a.every(function (value, index) {\n    return b[index] === value;\n  });\n};\n\nexports.arrayCompare = arrayCompare;\n\nfunction validatePath(_x10, _x11, _x12, _x13, _x14) {\n  return _validatePath.apply(this, arguments);\n}\n\nfunction _validatePath() {\n  _validatePath = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(id, dest, leftBound, rightBound, path) {\n    var pathData, endOffsetBuffer, pathDataHash, result, left, right, offsetBuffer, offset, remainder, pathHash;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(rightBound <= 0)) {\n              _context10.next = 2;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", false);\n\n          case 2:\n            if (!(dest >= rightBound)) {\n              _context10.next = 4;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", validatePath(id, 0, rightBound - 1, rightBound, path));\n\n          case 4:\n            if (!(dest < 0)) {\n              _context10.next = 6;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", validatePath(id, 0, 0, rightBound, path));\n\n          case 6:\n            if (!(path.length == HASH_SIZE + NOTE_SIZE)) {\n              _context10.next = 24;\n              break;\n            }\n\n            pathData = path.slice(0, HASH_SIZE);\n            endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);\n            _context10.t0 = hash;\n            _context10.next = 12;\n            return hash(pathData);\n\n          case 12:\n            _context10.t1 = _context10.sent;\n            _context10.next = 15;\n            return hash(endOffsetBuffer);\n\n          case 15:\n            _context10.t2 = _context10.sent;\n            _context10.t3 = [_context10.t1, _context10.t2];\n            _context10.next = 19;\n            return (0, _context10.t0)(_context10.t3);\n\n          case 19:\n            pathDataHash = _context10.sent;\n            result = exports.arrayCompare(id, pathDataHash);\n\n            if (!result) {\n              _context10.next = 23;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", {\n              offset: rightBound - 1,\n              leftBound: leftBound,\n              rightBound: rightBound,\n              chunkSize: rightBound - leftBound\n            });\n\n          case 23:\n            return _context10.abrupt(\"return\", false);\n\n          case 24:\n            left = path.slice(0, HASH_SIZE);\n            right = path.slice(left.length, left.length + HASH_SIZE);\n            offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n            offset = bufferToInt(offsetBuffer);\n            remainder = path.slice(left.length + right.length + offsetBuffer.length);\n            _context10.t4 = hash;\n            _context10.next = 32;\n            return hash(left);\n\n          case 32:\n            _context10.t5 = _context10.sent;\n            _context10.next = 35;\n            return hash(right);\n\n          case 35:\n            _context10.t6 = _context10.sent;\n            _context10.next = 38;\n            return hash(offsetBuffer);\n\n          case 38:\n            _context10.t7 = _context10.sent;\n            _context10.t8 = [_context10.t5, _context10.t6, _context10.t7];\n            _context10.next = 42;\n            return (0, _context10.t4)(_context10.t8);\n\n          case 42:\n            pathHash = _context10.sent;\n\n            if (!exports.arrayCompare(id, pathHash)) {\n              _context10.next = 51;\n              break;\n            }\n\n            if (!(dest < offset)) {\n              _context10.next = 48;\n              break;\n            }\n\n            _context10.next = 47;\n            return validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);\n\n          case 47:\n            return _context10.abrupt(\"return\", _context10.sent);\n\n          case 48:\n            _context10.next = 50;\n            return validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);\n\n          case 50:\n            return _context10.abrupt(\"return\", _context10.sent);\n\n          case 51:\n            return _context10.abrupt(\"return\", false);\n\n          case 52:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  return _validatePath.apply(this, arguments);\n}\n\nexports.validatePath = validatePath;\n/**\n * Inspect an arweave chunk proof.\n * Takes proof, parses, reads and displays the values for console logging.\n * One proof section per line\n * Format: left,right,offset => hash\n */\n\nfunction debug(_x15) {\n  return _debug.apply(this, arguments);\n}\n\nfunction _debug() {\n  _debug = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(proof) {\n    var output,\n        left,\n        right,\n        offsetBuffer,\n        offset,\n        remainder,\n        pathHash,\n        updatedOutput,\n        _args11 = arguments;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            output = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : \"\";\n\n            if (!(proof.byteLength < 1)) {\n              _context11.next = 3;\n              break;\n            }\n\n            return _context11.abrupt(\"return\", output);\n\n          case 3:\n            left = proof.slice(0, HASH_SIZE);\n            right = proof.slice(left.length, left.length + HASH_SIZE);\n            offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n            offset = bufferToInt(offsetBuffer);\n            remainder = proof.slice(left.length + right.length + offsetBuffer.length);\n            _context11.t0 = hash;\n            _context11.next = 11;\n            return hash(left);\n\n          case 11:\n            _context11.t1 = _context11.sent;\n            _context11.next = 14;\n            return hash(right);\n\n          case 14:\n            _context11.t2 = _context11.sent;\n            _context11.next = 17;\n            return hash(offsetBuffer);\n\n          case 17:\n            _context11.t3 = _context11.sent;\n            _context11.t4 = [_context11.t1, _context11.t2, _context11.t3];\n            _context11.next = 21;\n            return (0, _context11.t0)(_context11.t4);\n\n          case 21:\n            pathHash = _context11.sent;\n            updatedOutput = \"\".concat(output, \"\\n\").concat(util_1.inspect(Buffer.from(left)), \",\").concat(util_1.inspect(Buffer.from(right)), \",\").concat(offset, \" => \").concat(util_1.inspect(pathHash));\n            return _context11.abrupt(\"return\", debug(remainder, updatedOutput));\n\n          case 24:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _debug.apply(this, arguments);\n}\n\nexports.debug = debug;","map":{"version":3,"sources":["../../../../src/common/lib/merkle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;\n/**\n * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}\n */\nconst common_1 = require(\"../common\");\nconst utils_1 = require(\"./utils\");\nconst util_1 = require(\"util\");\nexports.MAX_CHUNK_SIZE = 256 * 1024;\nexports.MIN_CHUNK_SIZE = 32 * 1024;\nconst NOTE_SIZE = 32;\nconst HASH_SIZE = 32;\n/**\n * Takes the input data and chunks it into (mostly) equal sized chunks.\n * The last chunk will be a bit smaller as it contains the remainder\n * from the chunking process.\n */\nasync function chunkData(data) {\n    let chunks = [];\n    let rest = data;\n    let cursor = 0;\n    while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {\n        let chunkSize = exports.MAX_CHUNK_SIZE;\n        // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,\n        // then adjust the amount we put in this 2nd last chunk.\n        let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;\n        if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {\n            chunkSize = Math.ceil(rest.byteLength / 2);\n            // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)\n        }\n        const chunk = rest.slice(0, chunkSize);\n        const dataHash = await common_1.default.crypto.hash(chunk);\n        cursor += chunk.byteLength;\n        chunks.push({\n            dataHash,\n            minByteRange: cursor - chunk.byteLength,\n            maxByteRange: cursor,\n        });\n        rest = rest.slice(chunkSize);\n    }\n    chunks.push({\n        dataHash: await common_1.default.crypto.hash(rest),\n        minByteRange: cursor,\n        maxByteRange: cursor + rest.byteLength,\n    });\n    return chunks;\n}\nexports.chunkData = chunkData;\nasync function generateLeaves(chunks) {\n    return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange }) => {\n        return {\n            type: \"leaf\",\n            id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),\n            dataHash: dataHash,\n            minByteRange,\n            maxByteRange,\n        };\n    }));\n}\nexports.generateLeaves = generateLeaves;\n/**\n * Builds an arweave merkle tree and gets the root hash for the given input.\n */\nasync function computeRootHash(data) {\n    const rootNode = await generateTree(data);\n    return rootNode.id;\n}\nexports.computeRootHash = computeRootHash;\nasync function generateTree(data) {\n    const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));\n    return rootNode;\n}\nexports.generateTree = generateTree;\n/**\n * Generates the data_root, chunks & proofs\n * needed for a transaction.\n *\n * This also checks if the last chunk is a zero-length\n * chunk and discards that chunk and proof if so.\n * (we do not need to upload this zero length chunk)\n *\n * @param data\n */\nasync function generateTransactionChunks(data) {\n    const chunks = await chunkData(data);\n    const leaves = await generateLeaves(chunks);\n    const root = await buildLayers(leaves);\n    const proofs = await generateProofs(root);\n    // Discard the last chunk & proof if it's zero length.\n    const lastChunk = chunks.slice(-1)[0];\n    if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {\n        chunks.splice(chunks.length - 1, 1);\n        proofs.splice(proofs.length - 1, 1);\n    }\n    return {\n        data_root: root.id,\n        chunks,\n        proofs,\n    };\n}\nexports.generateTransactionChunks = generateTransactionChunks;\n/**\n * Starting with the bottom layer of leaf nodes, hash every second pair\n * into a new branch node, push those branch nodes onto a new layer,\n * and then recurse, building up the tree to it's root, where the\n * layer only consists of two items.\n */\nasync function buildLayers(nodes, level = 0) {\n    // If there are only 2 nodes left, this is going to be the root node\n    if (nodes.length < 2) {\n        const root = await hashBranch(nodes[0], nodes[1]);\n        // console.log(\"Root layer\", root);\n        return root;\n    }\n    const nextLayer = [];\n    for (let i = 0; i < nodes.length; i += 2) {\n        nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));\n    }\n    // console.log(\"Layer\", nextLayer);\n    return buildLayers(nextLayer, level + 1);\n}\nexports.buildLayers = buildLayers;\n/**\n * Recursively search through all branches of the tree,\n * and generate a proof for each leaf node.\n */\nfunction generateProofs(root) {\n    const proofs = resolveBranchProofs(root);\n    if (!Array.isArray(proofs)) {\n        return [proofs];\n    }\n    return arrayFlatten(proofs);\n}\nexports.generateProofs = generateProofs;\nfunction resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {\n    if (node.type == \"leaf\") {\n        return {\n            offset: node.maxByteRange - 1,\n            proof: utils_1.concatBuffers([\n                proof,\n                node.dataHash,\n                intToBuffer(node.maxByteRange),\n            ]),\n        };\n    }\n    if (node.type == \"branch\") {\n        const partialProof = utils_1.concatBuffers([\n            proof,\n            node.leftChild.id,\n            node.rightChild.id,\n            intToBuffer(node.byteRange),\n        ]);\n        return [\n            resolveBranchProofs(node.leftChild, partialProof, depth + 1),\n            resolveBranchProofs(node.rightChild, partialProof, depth + 1),\n        ];\n    }\n    throw new Error(`Unexpected node type`);\n}\nfunction arrayFlatten(input) {\n    const flat = [];\n    input.forEach((item) => {\n        if (Array.isArray(item)) {\n            flat.push(...arrayFlatten(item));\n        }\n        else {\n            flat.push(item);\n        }\n    });\n    return flat;\n}\nexports.arrayFlatten = arrayFlatten;\nasync function hashBranch(left, right) {\n    if (!right) {\n        return left;\n    }\n    let branch = {\n        type: \"branch\",\n        id: await hash([\n            await hash(left.id),\n            await hash(right.id),\n            await hash(intToBuffer(left.maxByteRange)),\n        ]),\n        byteRange: left.maxByteRange,\n        maxByteRange: right.maxByteRange,\n        leftChild: left,\n        rightChild: right,\n    };\n    return branch;\n}\nasync function hash(data) {\n    if (Array.isArray(data)) {\n        data = common_1.default.utils.concatBuffers(data);\n    }\n    return new Uint8Array(await common_1.default.crypto.hash(data));\n}\nfunction intToBuffer(note) {\n    const buffer = new Uint8Array(NOTE_SIZE);\n    for (var i = buffer.length - 1; i >= 0; i--) {\n        var byte = note % 256;\n        buffer[i] = byte;\n        note = (note - byte) / 256;\n    }\n    return buffer;\n}\nexports.intToBuffer = intToBuffer;\nfunction bufferToInt(buffer) {\n    let value = 0;\n    for (var i = 0; i < buffer.length; i++) {\n        value *= 256;\n        value += buffer[i];\n    }\n    return value;\n}\nexports.bufferToInt = bufferToInt;\nconst arrayCompare = (a, b) => a.every((value, index) => b[index] === value);\nexports.arrayCompare = arrayCompare;\nasync function validatePath(id, dest, leftBound, rightBound, path) {\n    if (rightBound <= 0) {\n        return false;\n    }\n    if (dest >= rightBound) {\n        return validatePath(id, 0, rightBound - 1, rightBound, path);\n    }\n    if (dest < 0) {\n        return validatePath(id, 0, 0, rightBound, path);\n    }\n    if (path.length == HASH_SIZE + NOTE_SIZE) {\n        const pathData = path.slice(0, HASH_SIZE);\n        const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);\n        const pathDataHash = await hash([\n            await hash(pathData),\n            await hash(endOffsetBuffer),\n        ]);\n        let result = exports.arrayCompare(id, pathDataHash);\n        if (result) {\n            return {\n                offset: rightBound - 1,\n                leftBound: leftBound,\n                rightBound: rightBound,\n                chunkSize: rightBound - leftBound,\n            };\n        }\n        return false;\n    }\n    const left = path.slice(0, HASH_SIZE);\n    const right = path.slice(left.length, left.length + HASH_SIZE);\n    const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n    const offset = bufferToInt(offsetBuffer);\n    const remainder = path.slice(left.length + right.length + offsetBuffer.length);\n    const pathHash = await hash([\n        await hash(left),\n        await hash(right),\n        await hash(offsetBuffer),\n    ]);\n    if (exports.arrayCompare(id, pathHash)) {\n        if (dest < offset) {\n            return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);\n        }\n        return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);\n    }\n    return false;\n}\nexports.validatePath = validatePath;\n/**\n * Inspect an arweave chunk proof.\n * Takes proof, parses, reads and displays the values for console logging.\n * One proof section per line\n * Format: left,right,offset => hash\n */\nasync function debug(proof, output = \"\") {\n    if (proof.byteLength < 1) {\n        return output;\n    }\n    const left = proof.slice(0, HASH_SIZE);\n    const right = proof.slice(left.length, left.length + HASH_SIZE);\n    const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n    const offset = bufferToInt(offsetBuffer);\n    const remainder = proof.slice(left.length + right.length + offsetBuffer.length);\n    const pathHash = await hash([\n        await hash(left),\n        await hash(right),\n        await hash(offsetBuffer),\n    ]);\n    const updatedOutput = `${output}\\n${util_1.inspect(Buffer.from(left))},${util_1.inspect(Buffer.from(right))},${offset} => ${util_1.inspect(pathHash)}`;\n    return debug(remainder, updatedOutput);\n}\nexports.debug = debug;\n//# sourceMappingURL=merkle.js.map"]},"metadata":{},"sourceType":"script"}