{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar error_1 = require(\"./lib/error\");\n\nvar ArweaveUtils = require(\"./lib/utils\");\n\nvar Chunks = /*#__PURE__*/function () {\n  function Chunks(api) {\n    _classCallCheck(this, Chunks);\n\n    this.api = api;\n  }\n\n  _createClass(Chunks, [{\n    key: \"getTransactionOffset\",\n    value: function () {\n      var _getTransactionOffset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id) {\n        var resp;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.api.get(\"tx/\".concat(id, \"/offset\"));\n\n              case 2:\n                resp = _context.sent;\n\n                if (!(resp.status === 200)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", resp.data);\n\n              case 5:\n                throw new Error(\"Unable to get transaction offset: \".concat(error_1.getError(resp)));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getTransactionOffset(_x) {\n        return _getTransactionOffset.apply(this, arguments);\n      }\n\n      return getTransactionOffset;\n    }()\n  }, {\n    key: \"getChunk\",\n    value: function () {\n      var _getChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(offset) {\n        var resp;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.api.get(\"chunk/\".concat(offset));\n\n              case 2:\n                resp = _context2.sent;\n\n                if (!(resp.status === 200)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", resp.data);\n\n              case 5:\n                throw new Error(\"Unable to get chunk: \".concat(error_1.getError(resp)));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getChunk(_x2) {\n        return _getChunk.apply(this, arguments);\n      }\n\n      return getChunk;\n    }()\n  }, {\n    key: \"getChunkData\",\n    value: function () {\n      var _getChunkData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(offset) {\n        var chunk, buf;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.getChunk(offset);\n\n              case 2:\n                chunk = _context3.sent;\n                buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n                return _context3.abrupt(\"return\", buf);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getChunkData(_x3) {\n        return _getChunkData.apply(this, arguments);\n      }\n\n      return getChunkData;\n    }()\n  }, {\n    key: \"firstChunkOffset\",\n    value: function firstChunkOffset(offsetResponse) {\n      return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n    }\n  }, {\n    key: \"downloadChunkedData\",\n    value: function () {\n      var _downloadChunkedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id) {\n        var offsetResponse, size, endOffset, startOffset, data, byte, chunkData;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getTransactionOffset(id);\n\n              case 2:\n                offsetResponse = _context4.sent;\n                size = parseInt(offsetResponse.size);\n                endOffset = parseInt(offsetResponse.offset);\n                startOffset = endOffset - size + 1;\n                data = new Uint8Array(size);\n                byte = 0;\n\n              case 8:\n                if (!(startOffset + byte < endOffset)) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                _context4.next = 11;\n                return this.getChunkData(startOffset + byte);\n\n              case 11:\n                chunkData = _context4.sent;\n                data.set(chunkData, byte);\n                byte += chunkData.length;\n                _context4.next = 8;\n                break;\n\n              case 16:\n                return _context4.abrupt(\"return\", data);\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function downloadChunkedData(_x4) {\n        return _downloadChunkedData.apply(this, arguments);\n      }\n\n      return downloadChunkedData;\n    }()\n  }]);\n\n  return Chunks;\n}();\n\nexports.default = Chunks;","map":{"version":3,"sources":["../../../src/common/chunks.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;IAaqB,M;AACnB,kBAAoB,GAApB,EAA4B;AAAA;;AAAR,SAAA,GAAA,GAAA,GAAA;AAAY;;;;;2FAEhC,iBAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACqB,KAAK,GAAL,CAAS,GAAT,cAAmB,EAAnB,aADrB;;AAAA;AACQ,gBAAA,IADR;;AAAA,sBAEM,IAAI,CAAC,MAAL,KAAgB,GAFtB;AAAA;AAAA;AAAA;;AAAA,iDAGW,IAAI,CAAC,IAHhB;;AAAA;AAAA,sBAKQ,IAAI,KAAJ,6CAA+C,OAAA,CAAA,QAAA,CAAS,IAAT,CAA/C,EALR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+EAQA,kBACE,MADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAGqB,KAAK,GAAL,CAAS,GAAT,iBAAsB,MAAtB,EAHrB;;AAAA;AAGQ,gBAAA,IAHR;;AAAA,sBAIM,IAAI,CAAC,MAAL,KAAgB,GAJtB;AAAA;AAAA;AAAA;;AAAA,kDAKW,IAAI,CAAC,IALhB;;AAAA;AAAA,sBAOQ,IAAI,KAAJ,gCAAkC,OAAA,CAAA,QAAA,CAAS,IAAT,CAAlC,EAPR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;mFAUA,kBAAmB,MAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACsB,KAAK,QAAL,CAAc,MAAd,CADtB;;AAAA;AACQ,gBAAA,KADR;AAEQ,gBAAA,GAFR,GAEc,YAAY,CAAC,cAAb,CAA4B,KAAK,CAAC,KAAlC,CAFd;AAAA,kDAGS,GAHT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAMA,0BAAiB,cAAjB,EAA0D;AACxD,aAAO,QAAQ,CAAC,cAAc,CAAC,MAAhB,CAAR,GAAkC,QAAQ,CAAC,cAAc,CAAC,IAAhB,CAA1C,GAAkE,CAAzE;AACD;;;;0FAED,kBAA0B,EAA1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC+B,KAAK,oBAAL,CAA0B,EAA1B,CAD/B;;AAAA;AACQ,gBAAA,cADR;AAGQ,gBAAA,IAHR,GAGe,QAAQ,CAAC,cAAc,CAAC,IAAhB,CAHvB;AAIQ,gBAAA,SAJR,GAIoB,QAAQ,CAAC,cAAc,CAAC,MAAhB,CAJ5B;AAKQ,gBAAA,WALR,GAKsB,SAAS,GAAG,IAAZ,GAAmB,CALzC;AAOQ,gBAAA,IAPR,GAOe,IAAI,UAAJ,CAAe,IAAf,CAPf;AAQM,gBAAA,IARN,GAQa,CARb;;AAAA;AAAA,sBAUS,WAAW,GAAG,IAAd,GAAqB,SAV9B;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAW4B,KAAK,YAAL,CAAkB,WAAW,GAAG,IAAhC,CAX5B;;AAAA;AAWU,gBAAA,SAXV;AAYI,gBAAA,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,IAApB;AACA,gBAAA,IAAI,IAAI,SAAS,CAAC,MAAlB;AAbJ;AAAA;;AAAA;AAAA,kDAgBS,IAhBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;AA/BF,OAAA,CAAA,OAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = require(\"./lib/error\");\nconst ArweaveUtils = require(\"./lib/utils\");\nclass Chunks {\n    constructor(api) {\n        this.api = api;\n    }\n    async getTransactionOffset(id) {\n        const resp = await this.api.get(`tx/${id}/offset`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get transaction offset: ${error_1.getError(resp)}`);\n    }\n    async getChunk(offset) {\n        const resp = await this.api.get(`chunk/${offset}`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get chunk: ${error_1.getError(resp)}`);\n    }\n    async getChunkData(offset) {\n        const chunk = await this.getChunk(offset);\n        const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n        return buf;\n    }\n    firstChunkOffset(offsetResponse) {\n        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n    }\n    async downloadChunkedData(id) {\n        const offsetResponse = await this.getTransactionOffset(id);\n        const size = parseInt(offsetResponse.size);\n        const endOffset = parseInt(offsetResponse.offset);\n        const startOffset = endOffset - size + 1;\n        const data = new Uint8Array(size);\n        let byte = 0;\n        while (startOffset + byte < endOffset) {\n            const chunkData = await this.getChunkData(startOffset + byte);\n            data.set(chunkData, byte);\n            byte += chunkData.length;\n        }\n        return data;\n    }\n}\nexports.default = Chunks;\n//# sourceMappingURL=chunks.js.map"]},"metadata":{},"sourceType":"script"}