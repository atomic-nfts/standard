{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\n\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar error_1 = require(\"./lib/error\");\n\nvar transaction_1 = require(\"./lib/transaction\");\n\nvar ArweaveUtils = require(\"./lib/utils\");\n\nvar transaction_uploader_1 = require(\"./lib/transaction-uploader\");\n\nrequire(\"arconnect\");\n\nvar Transactions = /*#__PURE__*/function () {\n  function Transactions(api, crypto, chunks) {\n    _classCallCheck(this, Transactions);\n\n    this.api = api;\n    this.crypto = crypto;\n    this.chunks = chunks;\n  }\n\n  _createClass(Transactions, [{\n    key: \"getTransactionAnchor\",\n    value: function getTransactionAnchor() {\n      return this.api.get(\"tx_anchor\").then(function (response) {\n        return response.data;\n      });\n    }\n  }, {\n    key: \"getPrice\",\n    value: function getPrice(byteSize, targetAddress) {\n      var endpoint = targetAddress ? \"price/\".concat(byteSize, \"/\").concat(targetAddress) : \"price/\".concat(byteSize);\n      return this.api.get(endpoint, {\n        transformResponse: [\n        /**\n         * We need to specify a response transformer to override\n         * the default JSON.parse behaviour, as this causes\n         * winston to be converted to a number and we want to\n         * return it as a winston string.\n         * @param data\n         */\n        function (data) {\n          return data;\n        }]\n      }).then(function (response) {\n        return response.data;\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id) {\n        var response, data_size, data;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.api.get(\"tx/\".concat(id));\n\n              case 2:\n                response = _context.sent;\n\n                if (!(response.status == 200)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                data_size = parseInt(response.data.data_size);\n\n                if (!(response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 8;\n                return this.getData(id);\n\n              case 8:\n                data = _context.sent;\n                return _context.abrupt(\"return\", new transaction_1.default(Object.assign(Object.assign({}, response.data), {\n                  data: data\n                })));\n\n              case 10:\n                return _context.abrupt(\"return\", new transaction_1.default(Object.assign(Object.assign({}, response.data), {\n                  format: response.data.format || 1\n                })));\n\n              case 11:\n                if (!(response.status == 202)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new error_1.default(\"TX_PENDING\"\n                /* TX_PENDING */\n                );\n\n              case 13:\n                if (!(response.status == 404)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                throw new error_1.default(\"TX_NOT_FOUND\"\n                /* TX_NOT_FOUND */\n                );\n\n              case 15:\n                if (!(response.status == 410)) {\n                  _context.next = 17;\n                  break;\n                }\n\n                throw new error_1.default(\"TX_FAILED\"\n                /* TX_FAILED */\n                );\n\n              case 17:\n                throw new error_1.default(\"TX_INVALID\"\n                /* TX_INVALID */\n                );\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"fromRaw\",\n    value: function fromRaw(attributes) {\n      return new transaction_1.default(attributes);\n    }\n  }, {\n    key: \"search\",\n    value: function () {\n      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tagName, tagValue) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.api.post(\"arql\", {\n                  op: \"equals\",\n                  expr1: tagName,\n                  expr2: tagValue\n                }).then(function (response) {\n                  if (!response.data) {\n                    return [];\n                  }\n\n                  return response.data;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function search(_x2, _x3) {\n        return _search.apply(this, arguments);\n      }\n\n      return search;\n    }()\n  }, {\n    key: \"getStatus\",\n    value: function getStatus(id) {\n      return this.api.get(\"tx/\".concat(id, \"/status\")).then(function (response) {\n        if (response.status == 200) {\n          return {\n            status: 200,\n            confirmed: response.data\n          };\n        }\n\n        return {\n          status: response.status,\n          confirmed: null\n        };\n      });\n    }\n  }, {\n    key: \"getData\",\n    value: function () {\n      var _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id, options) {\n        var resp, data;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.api.get(\"\".concat(id), {\n                  responseType: \"arraybuffer\"\n                });\n\n              case 2:\n                resp = _context3.sent;\n                data = undefined;\n\n                if (resp.status === 200) {\n                  data = new Uint8Array(resp.data);\n                }\n\n                if (!(resp.status === 400 && error_1.getError(resp) === \"tx_data_too_big\")) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.next = 8;\n                return this.chunks.downloadChunkedData(id);\n\n              case 8:\n                data = _context3.sent;\n\n              case 9:\n                if (data) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                if (!(resp.status == 202)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                throw new error_1.default(\"TX_PENDING\"\n                /* TX_PENDING */\n                );\n\n              case 12:\n                if (!(resp.status == 404)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                throw new error_1.default(\"TX_NOT_FOUND\"\n                /* TX_NOT_FOUND */\n                );\n\n              case 14:\n                if (!(resp.status == 410)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                throw new error_1.default(\"TX_FAILED\"\n                /* TX_FAILED */\n                );\n\n              case 16:\n                throw new Error(\"Unable to get data: \".concat(resp.status, \" - \").concat(error_1.getError(resp)));\n\n              case 17:\n                if (!(options && options.decode && !options.string)) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", data);\n\n              case 19:\n                if (!(options && options.decode && options.string)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", ArweaveUtils.bufferToString(data));\n\n              case 21:\n                return _context3.abrupt(\"return\", ArweaveUtils.bufferTob64Url(data));\n\n              case 22:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getData(_x4, _x5) {\n        return _getData.apply(this, arguments);\n      }\n\n      return getData;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(transaction, jwk, options) {\n        var existingPermissions, signedTransaction, dataToSign, rawSignature, id;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!jwk && (!window || !window.arweaveWallet))) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new Error(\"A new Arweave transaction must provide the jwk parameter.\");\n\n              case 4:\n                if (!(!jwk || jwk === \"use_wallet\")) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                _context4.prev = 5;\n                _context4.next = 8;\n                return window.arweaveWallet.getPermissions();\n\n              case 8:\n                existingPermissions = _context4.sent;\n\n                if (existingPermissions.includes(\"SIGN_TRANSACTION\")) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                _context4.next = 12;\n                return window.arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n\n              case 12:\n                _context4.next = 16;\n                break;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](5);\n\n              case 16:\n                _context4.next = 18;\n                return window.arweaveWallet.sign(transaction, options);\n\n              case 18:\n                signedTransaction = _context4.sent;\n                transaction.setSignature({\n                  id: signedTransaction.id,\n                  owner: signedTransaction.owner,\n                  tags: signedTransaction.tags,\n                  signature: signedTransaction.signature\n                });\n                _context4.next = 33;\n                break;\n\n              case 22:\n                transaction.setOwner(jwk.n);\n                _context4.next = 25;\n                return transaction.getSignatureData();\n\n              case 25:\n                dataToSign = _context4.sent;\n                _context4.next = 28;\n                return this.crypto.sign(jwk, dataToSign, options);\n\n              case 28:\n                rawSignature = _context4.sent;\n                _context4.next = 31;\n                return this.crypto.hash(rawSignature);\n\n              case 31:\n                id = _context4.sent;\n                transaction.setSignature({\n                  id: ArweaveUtils.bufferTob64Url(id),\n                  owner: jwk.n,\n                  signature: ArweaveUtils.bufferTob64Url(rawSignature)\n                });\n\n              case 33:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[5, 14]]);\n      }));\n\n      function sign(_x6, _x7, _x8) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(transaction) {\n        var signaturePayload, rawSignature, expectedId;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return transaction.getSignatureData();\n\n              case 2:\n                signaturePayload = _context5.sent;\n\n                /**\n                 * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n                 * to be recalculated from the signature and checked against the transaction ID.\n                 */\n                rawSignature = transaction.get(\"signature\", {\n                  decode: true,\n                  string: false\n                });\n                _context5.t0 = ArweaveUtils;\n                _context5.next = 7;\n                return this.crypto.hash(rawSignature);\n\n              case 7:\n                _context5.t1 = _context5.sent;\n                expectedId = _context5.t0.bufferTob64Url.call(_context5.t0, _context5.t1);\n\n                if (!(transaction.id !== expectedId)) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.\");\n\n              case 11:\n                return _context5.abrupt(\"return\", this.crypto.verify(transaction.owner, signaturePayload, rawSignature));\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function verify(_x9) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(transaction) {\n        var uploader;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (typeof transaction === \"string\") {\n                  transaction = new transaction_1.default(JSON.parse(transaction));\n                } else if (typeof transaction.readInt32BE === \"function\") {\n                  transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n                } else if (typeof transaction === \"object\" && !(transaction instanceof transaction_1.default)) {\n                  transaction = new transaction_1.default(transaction);\n                }\n\n                if (transaction instanceof transaction_1.default) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Must be Transaction object\");\n\n              case 3:\n                if (transaction.chunks) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 6;\n                return transaction.prepareChunks(transaction.data);\n\n              case 6:\n                _context6.next = 8;\n                return this.getUploader(transaction);\n\n              case 8:\n                uploader = _context6.sent;\n                _context6.prev = 9;\n\n              case 10:\n                if (uploader.isComplete) {\n                  _context6.next = 15;\n                  break;\n                }\n\n                _context6.next = 13;\n                return uploader.uploadChunk();\n\n              case 13:\n                _context6.next = 10;\n                break;\n\n              case 15:\n                _context6.next = 22;\n                break;\n\n              case 17:\n                _context6.prev = 17;\n                _context6.t0 = _context6[\"catch\"](9);\n\n                if (!(uploader.lastResponseStatus > 0)) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  status: uploader.lastResponseStatus,\n                  statusText: uploader.lastResponseError,\n                  data: {\n                    error: uploader.lastResponseError\n                  }\n                });\n\n              case 21:\n                throw _context6.t0;\n\n              case 22:\n                return _context6.abrupt(\"return\", {\n                  status: 200,\n                  statusText: \"OK\",\n                  data: {}\n                });\n\n              case 23:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[9, 17]]);\n      }));\n\n      function post(_x10) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n    /**\n     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n     * and the ability to resume.\n     *\n     * Usage example:\n     *\n     * ```\n     * const uploader = arweave.transactions.getUploader(transaction);\n     * while (!uploader.isComplete) {\n     *   await uploader.uploadChunk();\n     *   console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save progress object, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n\n  }, {\n    key: \"getUploader\",\n    value: function () {\n      var _getUploader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(upload, data) {\n        var uploader;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(upload instanceof transaction_1.default)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n                _context7.next = 14;\n                break;\n\n              case 4:\n                if (data instanceof ArrayBuffer) {\n                  data = new Uint8Array(data);\n                }\n\n                if (!(!data || !(data instanceof Uint8Array))) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Must provide data when resuming upload\");\n\n              case 7:\n                if (!(typeof upload === \"string\")) {\n                  _context7.next = 11;\n                  break;\n                }\n\n                _context7.next = 10;\n                return transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n\n              case 10:\n                upload = _context7.sent;\n\n              case 11:\n                _context7.next = 13;\n                return transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n\n              case 13:\n                uploader = _context7.sent;\n\n              case 14:\n                return _context7.abrupt(\"return\", uploader);\n\n              case 15:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getUploader(_x11, _x12) {\n        return _getUploader.apply(this, arguments);\n      }\n\n      return getUploader;\n    }()\n    /**\n     * Async generator version of uploader\n     *\n     * Usage example:\n     *\n     * ```\n     * for await (const uploader of arweave.transactions.upload(tx)) {\n     *  console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save uploader, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n\n  }, {\n    key: \"upload\",\n    value: function upload(_upload, data) {\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime.mark(function upload_1() {\n        var uploader;\n        return _regeneratorRuntime.wrap(function upload_1$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return __await(this.getUploader(_upload, data));\n\n              case 2:\n                uploader = _context8.sent;\n\n              case 3:\n                if (uploader.isComplete) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                _context8.next = 6;\n                return __await(uploader.uploadChunk());\n\n              case 6:\n                _context8.next = 8;\n                return __await(uploader);\n\n              case 8:\n                _context8.next = 10;\n                return _context8.sent;\n\n              case 10:\n                _context8.next = 3;\n                break;\n\n              case 12:\n                _context8.next = 14;\n                return __await(uploader);\n\n              case 14:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 15:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, upload_1, this);\n      }));\n    }\n  }]);\n\n  return Transactions;\n}();\n\nexports.default = Transactions;","map":{"version":3,"sources":["../../../src/common/transactions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = require(\"./lib/error\");\nconst transaction_1 = require(\"./lib/transaction\");\nconst ArweaveUtils = require(\"./lib/utils\");\nconst transaction_uploader_1 = require(\"./lib/transaction-uploader\");\nrequire(\"arconnect\");\nclass Transactions {\n    constructor(api, crypto, chunks) {\n        this.api = api;\n        this.crypto = crypto;\n        this.chunks = chunks;\n    }\n    getTransactionAnchor() {\n        return this.api.get(`tx_anchor`).then((response) => {\n            return response.data;\n        });\n    }\n    getPrice(byteSize, targetAddress) {\n        let endpoint = targetAddress\n            ? `price/${byteSize}/${targetAddress}`\n            : `price/${byteSize}`;\n        return this.api\n            .get(endpoint, {\n            transformResponse: [\n                /**\n                 * We need to specify a response transformer to override\n                 * the default JSON.parse behaviour, as this causes\n                 * winston to be converted to a number and we want to\n                 * return it as a winston string.\n                 * @param data\n                 */\n                function (data) {\n                    return data;\n                },\n            ],\n        })\n            .then((response) => {\n            return response.data;\n        });\n    }\n    async get(id) {\n        const response = await this.api.get(`tx/${id}`);\n        if (response.status == 200) {\n            const data_size = parseInt(response.data.data_size);\n            if (response.data.format >= 2 &&\n                data_size > 0 &&\n                data_size <= 1024 * 1024 * 12) {\n                const data = await this.getData(id);\n                return new transaction_1.default(Object.assign(Object.assign({}, response.data), { data }));\n            }\n            return new transaction_1.default(Object.assign(Object.assign({}, response.data), { format: response.data.format || 1 }));\n        }\n        if (response.status == 202) {\n            throw new error_1.default(\"TX_PENDING\" /* TX_PENDING */);\n        }\n        if (response.status == 404) {\n            throw new error_1.default(\"TX_NOT_FOUND\" /* TX_NOT_FOUND */);\n        }\n        if (response.status == 410) {\n            throw new error_1.default(\"TX_FAILED\" /* TX_FAILED */);\n        }\n        throw new error_1.default(\"TX_INVALID\" /* TX_INVALID */);\n    }\n    fromRaw(attributes) {\n        return new transaction_1.default(attributes);\n    }\n    async search(tagName, tagValue) {\n        return this.api\n            .post(`arql`, {\n            op: \"equals\",\n            expr1: tagName,\n            expr2: tagValue,\n        })\n            .then((response) => {\n            if (!response.data) {\n                return [];\n            }\n            return response.data;\n        });\n    }\n    getStatus(id) {\n        return this.api.get(`tx/${id}/status`).then((response) => {\n            if (response.status == 200) {\n                return {\n                    status: 200,\n                    confirmed: response.data,\n                };\n            }\n            return {\n                status: response.status,\n                confirmed: null,\n            };\n        });\n    }\n    async getData(id, options) {\n        // Attempt to download from /txid, fall back to downloading chunks.\n        const resp = await this.api.get(`${id}`, { responseType: \"arraybuffer\" });\n        let data = undefined;\n        if (resp.status === 200) {\n            data = new Uint8Array(resp.data);\n        }\n        if (resp.status === 400 && error_1.getError(resp) === \"tx_data_too_big\") {\n            data = await this.chunks.downloadChunkedData(id);\n        }\n        // If we don't have data, throw an exception. Previously we\n        // just returned an empty data object.\n        if (!data) {\n            if (resp.status == 202) {\n                throw new error_1.default(\"TX_PENDING\" /* TX_PENDING */);\n            }\n            if (resp.status == 404) {\n                throw new error_1.default(\"TX_NOT_FOUND\" /* TX_NOT_FOUND */);\n            }\n            if (resp.status == 410) {\n                throw new error_1.default(\"TX_FAILED\" /* TX_FAILED */);\n            }\n            throw new Error(`Unable to get data: ${resp.status} - ${error_1.getError(resp)}`);\n        }\n        if (options && options.decode && !options.string) {\n            return data;\n        }\n        if (options && options.decode && options.string) {\n            return ArweaveUtils.bufferToString(data);\n        }\n        // Since decode wasn't requested, caller expects b64url encoded data.\n        return ArweaveUtils.bufferTob64Url(data);\n    }\n    async sign(transaction, jwk, options) {\n        // @ts-ignore\n        if (!jwk && (!window || !window.arweaveWallet)) {\n            throw new Error(`A new Arweave transaction must provide the jwk parameter.`);\n        }\n        else if (!jwk || jwk === \"use_wallet\") {\n            try {\n                const existingPermissions = await window.arweaveWallet.getPermissions();\n                if (!existingPermissions.includes(\"SIGN_TRANSACTION\"))\n                    await window.arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n            }\n            catch (_a) {\n                // Permission is already granted\n            }\n            const signedTransaction = await window.arweaveWallet.sign(transaction, options);\n            transaction.setSignature({\n                id: signedTransaction.id,\n                owner: signedTransaction.owner,\n                tags: signedTransaction.tags,\n                signature: signedTransaction.signature,\n            });\n        }\n        else {\n            transaction.setOwner(jwk.n);\n            let dataToSign = await transaction.getSignatureData();\n            let rawSignature = await this.crypto.sign(jwk, dataToSign, options);\n            let id = await this.crypto.hash(rawSignature);\n            transaction.setSignature({\n                id: ArweaveUtils.bufferTob64Url(id),\n                owner: jwk.n,\n                signature: ArweaveUtils.bufferTob64Url(rawSignature),\n            });\n        }\n    }\n    async verify(transaction) {\n        const signaturePayload = await transaction.getSignatureData();\n        /**\n         * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n         * to be recalculated from the signature and checked against the transaction ID.\n         */\n        const rawSignature = transaction.get(\"signature\", {\n            decode: true,\n            string: false,\n        });\n        const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));\n        if (transaction.id !== expectedId) {\n            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);\n        }\n        /**\n         * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).\n         */\n        return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);\n    }\n    async post(transaction) {\n        if (typeof transaction === \"string\") {\n            transaction = new transaction_1.default(JSON.parse(transaction));\n        }\n        else if (typeof transaction.readInt32BE === \"function\") {\n            transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n        }\n        else if (typeof transaction === \"object\" &&\n            !(transaction instanceof transaction_1.default)) {\n            transaction = new transaction_1.default(transaction);\n        }\n        if (!(transaction instanceof transaction_1.default)) {\n            throw new Error(`Must be Transaction object`);\n        }\n        if (!transaction.chunks) {\n            await transaction.prepareChunks(transaction.data);\n        }\n        const uploader = await this.getUploader(transaction);\n        // Emulate existing error & return value behaviour.\n        try {\n            while (!uploader.isComplete) {\n                await uploader.uploadChunk();\n            }\n        }\n        catch (e) {\n            if (uploader.lastResponseStatus > 0) {\n                return {\n                    status: uploader.lastResponseStatus,\n                    statusText: uploader.lastResponseError,\n                    data: {\n                        error: uploader.lastResponseError,\n                    },\n                };\n            }\n            throw e;\n        }\n        return {\n            status: 200,\n            statusText: \"OK\",\n            data: {},\n        };\n    }\n    /**\n     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n     * and the ability to resume.\n     *\n     * Usage example:\n     *\n     * ```\n     * const uploader = arweave.transactions.getUploader(transaction);\n     * while (!uploader.isComplete) {\n     *   await uploader.uploadChunk();\n     *   console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save progress object, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async getUploader(upload, data) {\n        let uploader;\n        if (upload instanceof transaction_1.default) {\n            uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n        }\n        else {\n            if (data instanceof ArrayBuffer) {\n                data = new Uint8Array(data);\n            }\n            if (!data || !(data instanceof Uint8Array)) {\n                throw new Error(`Must provide data when resuming upload`);\n            }\n            if (typeof upload === \"string\") {\n                upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n            }\n            // upload should be a serialized upload.\n            uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n        }\n        return uploader;\n    }\n    /**\n     * Async generator version of uploader\n     *\n     * Usage example:\n     *\n     * ```\n     * for await (const uploader of arweave.transactions.upload(tx)) {\n     *  console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save uploader, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    upload(upload, data) {\n        return __asyncGenerator(this, arguments, function* upload_1() {\n            const uploader = yield __await(this.getUploader(upload, data));\n            while (!uploader.isComplete) {\n                yield __await(uploader.uploadChunk());\n                yield yield __await(uploader);\n            }\n            return yield __await(uploader);\n        });\n    }\n}\nexports.default = Transactions;\n//# sourceMappingURL=transactions.js.map"]},"metadata":{},"sourceType":"script"}