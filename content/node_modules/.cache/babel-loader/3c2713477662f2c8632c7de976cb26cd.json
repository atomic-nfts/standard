{"ast":null,"code":"import { decomposePrivateKeyInfo, composePrivateKeyInfo } from './keys';\nimport { maybeDecryptPrivateKeyInfo, maybeEncryptPrivateKeyInfo } from './encryption';\nimport { decodeAsn1, encodeAsn1 } from '../../util/asn1-encoder';\nimport { PrivateKeyInfo } from '../../util/asn1-entities';\nimport { DecodeAsn1FailedError } from '../../util/errors';\nexport const decomposePrivateKey = (encryptedPrivateKeyInfoAsn1, options) => {\n  // Attempt to decrypt privateKeyInfoAsn1 as it might actually be a EncryptedPrivateKeyInfo\n  const {\n    privateKeyInfoAsn1,\n    encryptionAlgorithm\n  } = maybeDecryptPrivateKeyInfo(encryptedPrivateKeyInfoAsn1, options.password); // Attempt to decode as PrivateKeyInfo\n\n  let privateKeyInfo;\n\n  try {\n    privateKeyInfo = decodeAsn1(privateKeyInfoAsn1, PrivateKeyInfo);\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodeAsn1FailedError;\n    throw err;\n  } // Decompose the PrivateKeyInfo\n\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposePrivateKeyInfo(privateKeyInfo);\n  return {\n    format: 'pkcs8-der',\n    keyAlgorithm,\n    keyData,\n    encryptionAlgorithm\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}, options) => {\n  // Generate the PrivateKeyInfo based on the key algorithm & key data\n  const privateKeyInfo = composePrivateKeyInfo(keyAlgorithm, keyData); // Encode PrivateKeyInfo into ASN1\n\n  const privateKeyInfoAsn1 = encodeAsn1(privateKeyInfo, PrivateKeyInfo); // Do we need to encrypt as EncryptedPrivateKeyInfo?\n\n  const encryptedPrivateKeyInfoAsn1 = maybeEncryptPrivateKeyInfo(privateKeyInfoAsn1, encryptionAlgorithm, options.password);\n  return encryptedPrivateKeyInfoAsn1;\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/formats/pkcs8/pkcs8-der.js"],"names":["decomposePrivateKeyInfo","composePrivateKeyInfo","maybeDecryptPrivateKeyInfo","maybeEncryptPrivateKeyInfo","decodeAsn1","encodeAsn1","PrivateKeyInfo","DecodeAsn1FailedError","decomposePrivateKey","encryptedPrivateKeyInfoAsn1","options","privateKeyInfoAsn1","encryptionAlgorithm","password","privateKeyInfo","err","invalidInputKey","keyAlgorithm","keyData","format","composePrivateKey"],"mappings":"AAAA,SAASA,uBAAT,EAAkCC,qBAAlC,QAA+D,QAA/D;AACA,SAASC,0BAAT,EAAqCC,0BAArC,QAAuE,cAAvE;AACA,SAASC,UAAT,EAAqBC,UAArB,QAAuC,yBAAvC;AACA,SAASC,cAAT,QAA+B,0BAA/B;AACA,SAASC,qBAAT,QAAsC,mBAAtC;AACA,OAAO,MAAMC,mBAAmB,GAAG,CAACC,2BAAD,EAA8BC,OAA9B,KAA0C;AAC3E;AACA,QAAM;AACJC,IAAAA,kBADI;AAEJC,IAAAA;AAFI,MAGFV,0BAA0B,CAACO,2BAAD,EAA8BC,OAAO,CAACG,QAAtC,CAH9B,CAF2E,CAKI;;AAE/E,MAAIC,cAAJ;;AAEA,MAAI;AACFA,IAAAA,cAAc,GAAGV,UAAU,CAACO,kBAAD,EAAqBL,cAArB,CAA3B;AACD,GAFD,CAEE,OAAOS,GAAP,EAAY;AACZA,IAAAA,GAAG,CAACC,eAAJ,GAAsBD,GAAG,YAAYR,qBAArC;AACA,UAAMQ,GAAN;AACD,GAd0E,CAczE;;;AAGF,QAAM;AACJE,IAAAA,YADI;AAEJC,IAAAA;AAFI,MAGFlB,uBAAuB,CAACc,cAAD,CAH3B;AAIA,SAAO;AACLK,IAAAA,MAAM,EAAE,WADH;AAELF,IAAAA,YAFK;AAGLC,IAAAA,OAHK;AAILN,IAAAA;AAJK,GAAP;AAMD,CA3BM;AA4BP,OAAO,MAAMQ,iBAAiB,GAAG,CAAC;AAChCH,EAAAA,YADgC;AAEhCC,EAAAA,OAFgC;AAGhCN,EAAAA;AAHgC,CAAD,EAI9BF,OAJ8B,KAIlB;AACb;AACA,QAAMI,cAAc,GAAGb,qBAAqB,CAACgB,YAAD,EAAeC,OAAf,CAA5C,CAFa,CAEwD;;AAErE,QAAMP,kBAAkB,GAAGN,UAAU,CAACS,cAAD,EAAiBR,cAAjB,CAArC,CAJa,CAI0D;;AAEvE,QAAMG,2BAA2B,GAAGN,0BAA0B,CAACQ,kBAAD,EAAqBC,mBAArB,EAA0CF,OAAO,CAACG,QAAlD,CAA9D;AACA,SAAOJ,2BAAP;AACD,CAZM","sourcesContent":["import { decomposePrivateKeyInfo, composePrivateKeyInfo } from './keys';\nimport { maybeDecryptPrivateKeyInfo, maybeEncryptPrivateKeyInfo } from './encryption';\nimport { decodeAsn1, encodeAsn1 } from '../../util/asn1-encoder';\nimport { PrivateKeyInfo } from '../../util/asn1-entities';\nimport { DecodeAsn1FailedError } from '../../util/errors';\nexport const decomposePrivateKey = (encryptedPrivateKeyInfoAsn1, options) => {\n  // Attempt to decrypt privateKeyInfoAsn1 as it might actually be a EncryptedPrivateKeyInfo\n  const {\n    privateKeyInfoAsn1,\n    encryptionAlgorithm\n  } = maybeDecryptPrivateKeyInfo(encryptedPrivateKeyInfoAsn1, options.password); // Attempt to decode as PrivateKeyInfo\n\n  let privateKeyInfo;\n\n  try {\n    privateKeyInfo = decodeAsn1(privateKeyInfoAsn1, PrivateKeyInfo);\n  } catch (err) {\n    err.invalidInputKey = err instanceof DecodeAsn1FailedError;\n    throw err;\n  } // Decompose the PrivateKeyInfo\n\n\n  const {\n    keyAlgorithm,\n    keyData\n  } = decomposePrivateKeyInfo(privateKeyInfo);\n  return {\n    format: 'pkcs8-der',\n    keyAlgorithm,\n    keyData,\n    encryptionAlgorithm\n  };\n};\nexport const composePrivateKey = ({\n  keyAlgorithm,\n  keyData,\n  encryptionAlgorithm\n}, options) => {\n  // Generate the PrivateKeyInfo based on the key algorithm & key data\n  const privateKeyInfo = composePrivateKeyInfo(keyAlgorithm, keyData); // Encode PrivateKeyInfo into ASN1\n\n  const privateKeyInfoAsn1 = encodeAsn1(privateKeyInfo, PrivateKeyInfo); // Do we need to encrypt as EncryptedPrivateKeyInfo?\n\n  const encryptedPrivateKeyInfoAsn1 = maybeEncryptPrivateKeyInfo(privateKeyInfoAsn1, encryptionAlgorithm, options.password);\n  return encryptedPrivateKeyInfoAsn1;\n};"]},"metadata":{},"sourceType":"module"}