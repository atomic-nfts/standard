{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeContractSource = exports.log = exports.arrayToHex = exports.formatTags = exports.unpackTags = exports.getTag = void 0;\n\nfunction getTag(tx, name) {\n  var tags = tx.get('tags');\n\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n\n      // decoding tags can throw on invalid utf8 data.\n      try {\n        if (tag.get('name', {\n          decode: true,\n          string: true\n        }) === name) {\n          return tag.get('value', {\n            decode: true,\n            string: true\n          });\n        } // tslint:disable-next-line: no-empty\n\n      } catch (e) {}\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return false;\n}\n\nexports.getTag = getTag;\n/**\n * Unpacks string tags from a Tx and puts in a KV map\n * Tags that appear multiple times will be converted to an\n * array of string values, ordered as they appear in the tx.\n *\n * @param tx\n */\n\nfunction unpackTags(tx) {\n  var tags = tx.get('tags');\n  var result = {};\n\n  var _iterator2 = _createForOfIteratorHelper(tags),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var tag = _step2.value;\n\n      try {\n        var name = tag.get('name', {\n          decode: true,\n          string: true\n        });\n        var value = tag.get('value', {\n          decode: true,\n          string: true\n        });\n\n        if (!result.hasOwnProperty(name)) {\n          result[name] = value;\n          continue;\n        }\n\n        result[name] = [].concat(_toConsumableArray(result[name]), [value]);\n      } catch (e) {// ignore tags with invalid utf-8 strings in key or value.\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return result;\n}\n\nexports.unpackTags = unpackTags;\n\nfunction formatTags(tags) {\n  var result = {};\n\n  var _iterator3 = _createForOfIteratorHelper(tags),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var tag = _step3.value;\n      var name = tag.name,\n          value = tag.value;\n\n      if (!result.hasOwnProperty(name)) {\n        result[name] = value;\n        continue;\n      }\n\n      result[name] = [].concat(_toConsumableArray(result[name]), [value]);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return result;\n}\n\nexports.formatTags = formatTags;\n\nfunction arrayToHex(arr) {\n  var str = '';\n\n  var _iterator4 = _createForOfIteratorHelper(arr),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var a = _step4.value;\n      str += ('0' + a.toString(16)).slice(-2);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return str;\n}\n\nexports.arrayToHex = arrayToHex;\n\nfunction log(arweave) {\n  var _arweave$getConfig$ap, _console;\n\n  if (!arweave || !arweave.getConfig().api.logging) return;\n\n  for (var _len = arguments.length, str = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    str[_key - 1] = arguments[_key];\n  }\n\n  typeof arweave.getConfig().api.logger === 'function' ? (_arweave$getConfig$ap = arweave.getConfig().api).logger.apply(_arweave$getConfig$ap, str) : (_console = console).log.apply(_console, str);\n}\n\nexports.log = log;\n\nfunction normalizeContractSource(contractSrc) {\n  // Convert from ES Module format to something we can run inside a Function.\n  // Removes the `export` keyword and adds ;return handle to the end of the function.\n  // Additionally it removes 'IIFE' declarations\n  // (which may be generated when bundling multiple sources into one output file\n  // - eg. using esbuild's \"IIFE\" bundle format).\n  // We also assign the passed in SmartWeaveGlobal to SmartWeave, and declare\n  // the ContractError exception.\n  // We then use `new Function()` which we can call and get back the returned handle function\n  // which has access to the per-instance globals.\n  contractSrc = contractSrc.replace(/export[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+async[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+function[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+handle/gm, 'async function handle').replace(/export[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+function[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+handle/gm, 'function handle').replace(/\\(\\s*\\(\\)\\s*=>\\s*{/g, '').replace(/\\s*\\(\\s*function\\s*\\(\\)\\s*{/g, '').replace(/}\\s*\\)\\s*\\(\\)\\s*;/g, '');\n  return \"\\n    const [SmartWeave, BigNumber, clarity] = arguments;\\n    clarity.SmartWeave = SmartWeave;\\n    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };\\n    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };\\n    \".concat(contractSrc, \";\\n    return handle;\\n  \");\n}\n\nexports.normalizeContractSource = normalizeContractSource;","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/@kyve/contract-lib/node_modules/smartweave/lib/utils.js"],"names":["Object","defineProperty","exports","value","normalizeContractSource","log","arrayToHex","formatTags","unpackTags","getTag","tx","name","tags","get","tag","decode","string","e","result","hasOwnProperty","arr","str","a","toString","slice","arweave","getConfig","api","logging","logger","console","contractSrc","replace"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeContractSource = exports.log = exports.arrayToHex = exports.formatTags = exports.unpackTags = exports.getTag = void 0;\nfunction getTag(tx, name) {\n    const tags = tx.get('tags');\n    for (const tag of tags) {\n        // decoding tags can throw on invalid utf8 data.\n        try {\n            if (tag.get('name', { decode: true, string: true }) === name) {\n                return tag.get('value', { decode: true, string: true });\n            }\n            // tslint:disable-next-line: no-empty\n        }\n        catch (e) { }\n    }\n    return false;\n}\nexports.getTag = getTag;\n/**\n * Unpacks string tags from a Tx and puts in a KV map\n * Tags that appear multiple times will be converted to an\n * array of string values, ordered as they appear in the tx.\n *\n * @param tx\n */\nfunction unpackTags(tx) {\n    const tags = tx.get('tags');\n    const result = {};\n    for (const tag of tags) {\n        try {\n            const name = tag.get('name', { decode: true, string: true });\n            const value = tag.get('value', { decode: true, string: true });\n            if (!result.hasOwnProperty(name)) {\n                result[name] = value;\n                continue;\n            }\n            result[name] = [...result[name], value];\n        }\n        catch (e) {\n            // ignore tags with invalid utf-8 strings in key or value.\n        }\n    }\n    return result;\n}\nexports.unpackTags = unpackTags;\nfunction formatTags(tags) {\n    const result = {};\n    for (const tag of tags) {\n        const { name, value } = tag;\n        if (!result.hasOwnProperty(name)) {\n            result[name] = value;\n            continue;\n        }\n        result[name] = [...result[name], value];\n    }\n    return result;\n}\nexports.formatTags = formatTags;\nfunction arrayToHex(arr) {\n    let str = '';\n    for (const a of arr) {\n        str += ('0' + a.toString(16)).slice(-2);\n    }\n    return str;\n}\nexports.arrayToHex = arrayToHex;\nfunction log(arweave, ...str) {\n    if (!arweave || !arweave.getConfig().api.logging)\n        return;\n    typeof arweave.getConfig().api.logger === 'function' ? arweave.getConfig().api.logger(...str) : console.log(...str);\n}\nexports.log = log;\nfunction normalizeContractSource(contractSrc) {\n    // Convert from ES Module format to something we can run inside a Function.\n    // Removes the `export` keyword and adds ;return handle to the end of the function.\n    // Additionally it removes 'IIFE' declarations\n    // (which may be generated when bundling multiple sources into one output file\n    // - eg. using esbuild's \"IIFE\" bundle format).\n    // We also assign the passed in SmartWeaveGlobal to SmartWeave, and declare\n    // the ContractError exception.\n    // We then use `new Function()` which we can call and get back the returned handle function\n    // which has access to the per-instance globals.\n    contractSrc = contractSrc\n        .replace(/export\\s+async\\s+function\\s+handle/gmu, 'async function handle')\n        .replace(/export\\s+function\\s+handle/gmu, 'function handle')\n        .replace(/\\(\\s*\\(\\)\\s*=>\\s*{/g, '')\n        .replace(/\\s*\\(\\s*function\\s*\\(\\)\\s*{/g, '')\n        .replace(/}\\s*\\)\\s*\\(\\)\\s*;/g, '');\n    return `\n    const [SmartWeave, BigNumber, clarity] = arguments;\n    clarity.SmartWeave = SmartWeave;\n    class ContractError extends Error { constructor(message) { super(message); this.name = \\'ContractError\\' } };\n    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };\n    ${contractSrc};\n    return handle;\n  `;\n}\nexports.normalizeContractSource = normalizeContractSource;\n"]},"metadata":{},"sourceType":"script"}