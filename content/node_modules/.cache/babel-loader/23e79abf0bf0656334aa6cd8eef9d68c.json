{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;\n/**\n * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}\n */\n\nconst common_1 = require(\"../common\");\n\nconst utils_1 = require(\"./utils\");\n\nconst util_1 = require(\"util\");\n\nexports.MAX_CHUNK_SIZE = 256 * 1024;\nexports.MIN_CHUNK_SIZE = 32 * 1024;\nconst NOTE_SIZE = 32;\nconst HASH_SIZE = 32;\n/**\n * Takes the input data and chunks it into (mostly) equal sized chunks.\n * The last chunk will be a bit smaller as it contains the remainder\n * from the chunking process.\n */\n\nasync function chunkData(data) {\n  let chunks = [];\n  let rest = data;\n  let cursor = 0;\n\n  while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {\n    let chunkSize = exports.MAX_CHUNK_SIZE; // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,\n    // then adjust the amount we put in this 2nd last chunk.\n\n    let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;\n\n    if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {\n      chunkSize = Math.ceil(rest.byteLength / 2); // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)\n    }\n\n    const chunk = rest.slice(0, chunkSize);\n    const dataHash = await common_1.default.crypto.hash(chunk);\n    cursor += chunk.byteLength;\n    chunks.push({\n      dataHash,\n      minByteRange: cursor - chunk.byteLength,\n      maxByteRange: cursor\n    });\n    rest = rest.slice(chunkSize);\n  }\n\n  chunks.push({\n    dataHash: await common_1.default.crypto.hash(rest),\n    minByteRange: cursor,\n    maxByteRange: cursor + rest.byteLength\n  });\n  return chunks;\n}\n\nexports.chunkData = chunkData;\n\nasync function generateLeaves(chunks) {\n  return Promise.all(chunks.map(async ({\n    dataHash,\n    minByteRange,\n    maxByteRange\n  }) => {\n    return {\n      type: \"leaf\",\n      id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),\n      dataHash: dataHash,\n      minByteRange,\n      maxByteRange\n    };\n  }));\n}\n\nexports.generateLeaves = generateLeaves;\n/**\n * Builds an arweave merkle tree and gets the root hash for the given input.\n */\n\nasync function computeRootHash(data) {\n  const rootNode = await generateTree(data);\n  return rootNode.id;\n}\n\nexports.computeRootHash = computeRootHash;\n\nasync function generateTree(data) {\n  const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));\n  return rootNode;\n}\n\nexports.generateTree = generateTree;\n/**\n * Generates the data_root, chunks & proofs\n * needed for a transaction.\n *\n * This also checks if the last chunk is a zero-length\n * chunk and discards that chunk and proof if so.\n * (we do not need to upload this zero length chunk)\n *\n * @param data\n */\n\nasync function generateTransactionChunks(data) {\n  const chunks = await chunkData(data);\n  const leaves = await generateLeaves(chunks);\n  const root = await buildLayers(leaves);\n  const proofs = await generateProofs(root); // Discard the last chunk & proof if it's zero length.\n\n  const lastChunk = chunks.slice(-1)[0];\n\n  if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {\n    chunks.splice(chunks.length - 1, 1);\n    proofs.splice(proofs.length - 1, 1);\n  }\n\n  return {\n    data_root: root.id,\n    chunks,\n    proofs\n  };\n}\n\nexports.generateTransactionChunks = generateTransactionChunks;\n/**\n * Starting with the bottom layer of leaf nodes, hash every second pair\n * into a new branch node, push those branch nodes onto a new layer,\n * and then recurse, building up the tree to it's root, where the\n * layer only consists of two items.\n */\n\nasync function buildLayers(nodes, level = 0) {\n  // If there are only 2 nodes left, this is going to be the root node\n  if (nodes.length < 2) {\n    const root = await hashBranch(nodes[0], nodes[1]); // console.log(\"Root layer\", root);\n\n    return root;\n  }\n\n  const nextLayer = [];\n\n  for (let i = 0; i < nodes.length; i += 2) {\n    nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));\n  } // console.log(\"Layer\", nextLayer);\n\n\n  return buildLayers(nextLayer, level + 1);\n}\n\nexports.buildLayers = buildLayers;\n/**\n * Recursively search through all branches of the tree,\n * and generate a proof for each leaf node.\n */\n\nfunction generateProofs(root) {\n  const proofs = resolveBranchProofs(root);\n\n  if (!Array.isArray(proofs)) {\n    return [proofs];\n  }\n\n  return arrayFlatten(proofs);\n}\n\nexports.generateProofs = generateProofs;\n\nfunction resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {\n  if (node.type == \"leaf\") {\n    return {\n      offset: node.maxByteRange - 1,\n      proof: utils_1.concatBuffers([proof, node.dataHash, intToBuffer(node.maxByteRange)])\n    };\n  }\n\n  if (node.type == \"branch\") {\n    const partialProof = utils_1.concatBuffers([proof, node.leftChild.id, node.rightChild.id, intToBuffer(node.byteRange)]);\n    return [resolveBranchProofs(node.leftChild, partialProof, depth + 1), resolveBranchProofs(node.rightChild, partialProof, depth + 1)];\n  }\n\n  throw new Error(`Unexpected node type`);\n}\n\nfunction arrayFlatten(input) {\n  const flat = [];\n  input.forEach(item => {\n    if (Array.isArray(item)) {\n      flat.push(...arrayFlatten(item));\n    } else {\n      flat.push(item);\n    }\n  });\n  return flat;\n}\n\nexports.arrayFlatten = arrayFlatten;\n\nasync function hashBranch(left, right) {\n  if (!right) {\n    return left;\n  }\n\n  let branch = {\n    type: \"branch\",\n    id: await hash([await hash(left.id), await hash(right.id), await hash(intToBuffer(left.maxByteRange))]),\n    byteRange: left.maxByteRange,\n    maxByteRange: right.maxByteRange,\n    leftChild: left,\n    rightChild: right\n  };\n  return branch;\n}\n\nasync function hash(data) {\n  if (Array.isArray(data)) {\n    data = common_1.default.utils.concatBuffers(data);\n  }\n\n  return new Uint8Array(await common_1.default.crypto.hash(data));\n}\n\nfunction intToBuffer(note) {\n  const buffer = new Uint8Array(NOTE_SIZE);\n\n  for (var i = buffer.length - 1; i >= 0; i--) {\n    var byte = note % 256;\n    buffer[i] = byte;\n    note = (note - byte) / 256;\n  }\n\n  return buffer;\n}\n\nexports.intToBuffer = intToBuffer;\n\nfunction bufferToInt(buffer) {\n  let value = 0;\n\n  for (var i = 0; i < buffer.length; i++) {\n    value *= 256;\n    value += buffer[i];\n  }\n\n  return value;\n}\n\nexports.bufferToInt = bufferToInt;\n\nconst arrayCompare = (a, b) => a.every((value, index) => b[index] === value);\n\nexports.arrayCompare = arrayCompare;\n\nasync function validatePath(id, dest, leftBound, rightBound, path) {\n  if (rightBound <= 0) {\n    return false;\n  }\n\n  if (dest >= rightBound) {\n    return validatePath(id, 0, rightBound - 1, rightBound, path);\n  }\n\n  if (dest < 0) {\n    return validatePath(id, 0, 0, rightBound, path);\n  }\n\n  if (path.length == HASH_SIZE + NOTE_SIZE) {\n    const pathData = path.slice(0, HASH_SIZE);\n    const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);\n    const pathDataHash = await hash([await hash(pathData), await hash(endOffsetBuffer)]);\n    let result = exports.arrayCompare(id, pathDataHash);\n\n    if (result) {\n      return {\n        offset: rightBound - 1,\n        leftBound: leftBound,\n        rightBound: rightBound,\n        chunkSize: rightBound - leftBound\n      };\n    }\n\n    return false;\n  }\n\n  const left = path.slice(0, HASH_SIZE);\n  const right = path.slice(left.length, left.length + HASH_SIZE);\n  const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n  const offset = bufferToInt(offsetBuffer);\n  const remainder = path.slice(left.length + right.length + offsetBuffer.length);\n  const pathHash = await hash([await hash(left), await hash(right), await hash(offsetBuffer)]);\n\n  if (exports.arrayCompare(id, pathHash)) {\n    if (dest < offset) {\n      return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);\n    }\n\n    return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);\n  }\n\n  return false;\n}\n\nexports.validatePath = validatePath;\n/**\n * Inspect an arweave chunk proof.\n * Takes proof, parses, reads and displays the values for console logging.\n * One proof section per line\n * Format: left,right,offset => hash\n */\n\nasync function debug(proof, output = \"\") {\n  if (proof.byteLength < 1) {\n    return output;\n  }\n\n  const left = proof.slice(0, HASH_SIZE);\n  const right = proof.slice(left.length, left.length + HASH_SIZE);\n  const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n  const offset = bufferToInt(offsetBuffer);\n  const remainder = proof.slice(left.length + right.length + offsetBuffer.length);\n  const pathHash = await hash([await hash(left), await hash(right), await hash(offsetBuffer)]);\n  const updatedOutput = `${output}\\n${util_1.inspect(Buffer.from(left))},${util_1.inspect(Buffer.from(right))},${offset} => ${util_1.inspect(pathHash)}`;\n  return debug(remainder, updatedOutput);\n}\n\nexports.debug = debug;","map":{"version":3,"sources":["../../../../src/common/lib/merkle.ts"],"names":[],"mappings":";;;;;;AAAA;;AAEG;;AACH,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AA4Ba,OAAA,CAAA,cAAA,GAAiB,MAAM,IAAvB;AACA,OAAA,CAAA,cAAA,GAAiB,KAAK,IAAtB;AACb,MAAM,SAAS,GAAG,EAAlB;AACA,MAAM,SAAS,GAAG,EAAlB;AAEA;;;;AAIG;;AACI,eAAe,SAAf,CAAyB,IAAzB,EAAyC;AAC9C,MAAI,MAAM,GAAY,EAAtB;AAEA,MAAI,IAAI,GAAG,IAAX;AACA,MAAI,MAAM,GAAG,CAAb;;AAEA,SAAO,IAAI,CAAC,UAAL,IAAmB,OAAA,CAAA,cAA1B,EAA0C;AACxC,QAAI,SAAS,GAAG,OAAA,CAAA,cAAhB,CADwC,CAGxC;AACA;;AAEA,QAAI,aAAa,GAAG,IAAI,CAAC,UAAL,GAAkB,OAAA,CAAA,cAAtC;;AACA,QAAI,aAAa,GAAG,CAAhB,IAAqB,aAAa,GAAG,OAAA,CAAA,cAAzC,EAAyD;AACvD,MAAA,SAAS,GAAG,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,UAAL,GAAkB,CAA5B,CAAZ,CADuD,CAEvD;AACD;;AAED,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,SAAd,CAAd;AACA,UAAM,QAAQ,GAAG,MAAM,QAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,IAAf,CAAoB,KAApB,CAAvB;AACA,IAAA,MAAM,IAAI,KAAK,CAAC,UAAhB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY;AACV,MAAA,QADU;AAEV,MAAA,YAAY,EAAE,MAAM,GAAG,KAAK,CAAC,UAFnB;AAGV,MAAA,YAAY,EAAE;AAHJ,KAAZ;AAKA,IAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,SAAX,CAAP;AACD;;AAED,EAAA,MAAM,CAAC,IAAP,CAAY;AACV,IAAA,QAAQ,EAAE,MAAM,QAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,IAAf,CAAoB,IAApB,CADN;AAEV,IAAA,YAAY,EAAE,MAFJ;AAGV,IAAA,YAAY,EAAE,MAAM,GAAG,IAAI,CAAC;AAHlB,GAAZ;AAMA,SAAO,MAAP;AACD;;AApCD,OAAA,CAAA,SAAA,GAAA,SAAA;;AAsCO,eAAe,cAAf,CAA8B,MAA9B,EAA6C;AAClD,SAAO,OAAO,CAAC,GAAR,CACL,MAAM,CAAC,GAAP,CACE,OAAO;AAAE,IAAA,QAAF;AAAY,IAAA,YAAZ;AAA0B,IAAA;AAA1B,GAAP,KAAsE;AACpE,WAAO;AACL,MAAA,IAAI,EAAE,MADD;AAEL,MAAA,EAAE,EAAE,MAAM,IAAI,CACZ,MAAM,OAAO,CAAC,GAAR,CAAY,CAAC,IAAI,CAAC,QAAD,CAAL,EAAiB,IAAI,CAAC,WAAW,CAAC,YAAD,CAAZ,CAArB,CAAZ,CADM,CAFT;AAKL,MAAA,QAAQ,EAAE,QALL;AAML,MAAA,YANK;AAOL,MAAA;AAPK,KAAP;AASD,GAXH,CADK,CAAP;AAeD;;AAhBD,OAAA,CAAA,cAAA,GAAA,cAAA;AAkBA;;AAEG;;AACI,eAAe,eAAf,CAA+B,IAA/B,EAA+C;AACpD,QAAM,QAAQ,GAAG,MAAM,YAAY,CAAC,IAAD,CAAnC;AAEA,SAAO,QAAQ,CAAC,EAAhB;AACD;;AAJD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAMO,eAAe,YAAf,CAA4B,IAA5B,EAA4C;AACjD,QAAM,QAAQ,GAAG,MAAM,WAAW,CAChC,MAAM,cAAc,CAAC,MAAM,SAAS,CAAC,IAAD,CAAhB,CADY,CAAlC;AAIA,SAAO,QAAP;AACD;;AAND,OAAA,CAAA,YAAA,GAAA,YAAA;AAQA;;;;;;;;;AASG;;AACI,eAAe,yBAAf,CAAyC,IAAzC,EAAyD;AAC9D,QAAM,MAAM,GAAG,MAAM,SAAS,CAAC,IAAD,CAA9B;AACA,QAAM,MAAM,GAAG,MAAM,cAAc,CAAC,MAAD,CAAnC;AACA,QAAM,IAAI,GAAG,MAAM,WAAW,CAAC,MAAD,CAA9B;AACA,QAAM,MAAM,GAAG,MAAM,cAAc,CAAC,IAAD,CAAnC,CAJ8D,CAM9D;;AACA,QAAM,SAAS,GAAG,MAAM,CAAC,KAAP,CAAa,CAAC,CAAd,EAAiB,CAAjB,CAAlB;;AACA,MAAI,SAAS,CAAC,YAAV,GAAyB,SAAS,CAAC,YAAnC,KAAoD,CAAxD,EAA2D;AACzD,IAAA,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,MAAP,GAAgB,CAA9B,EAAiC,CAAjC;AACA,IAAA,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,MAAP,GAAgB,CAA9B,EAAiC,CAAjC;AACD;;AAED,SAAO;AACL,IAAA,SAAS,EAAE,IAAI,CAAC,EADX;AAEL,IAAA,MAFK;AAGL,IAAA;AAHK,GAAP;AAKD;;AAlBD,OAAA,CAAA,yBAAA,GAAA,yBAAA;AAoBA;;;;;AAKG;;AACI,eAAe,WAAf,CACL,KADK,EAEL,KAAK,GAAG,CAFH,EAEI;AAET;AACA,MAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB,UAAM,IAAI,GAAG,MAAM,UAAU,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,KAAK,CAAC,CAAD,CAAhB,CAA7B,CADoB,CAGpB;;AAEA,WAAO,IAAP;AACD;;AAED,QAAM,SAAS,GAAiB,EAAhC;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,IAAI,CAAvC,EAA0C;AACxC,IAAA,SAAS,CAAC,IAAV,CAAe,MAAM,UAAU,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,KAAK,CAAC,CAAC,GAAG,CAAL,CAAhB,CAA/B;AACD,GAfQ,CAiBT;;;AAEA,SAAO,WAAW,CAAC,SAAD,EAAY,KAAK,GAAG,CAApB,CAAlB;AACD;;AAtBD,OAAA,CAAA,WAAA,GAAA,WAAA;AAwBA;;;AAGG;;AACH,SAAgB,cAAhB,CAA+B,IAA/B,EAA+C;AAC7C,QAAM,MAAM,GAAG,mBAAmB,CAAC,IAAD,CAAlC;;AACA,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B;AAC1B,WAAO,CAAC,MAAD,CAAP;AACD;;AACD,SAAO,YAAY,CAAQ,MAAR,CAAnB;AACD;;AAND,OAAA,CAAA,cAAA,GAAA,cAAA;;AAaA,SAAS,mBAAT,CACE,IADF,EAEE,KAAA,GAAoB,IAAI,UAAJ,EAFtB,EAGE,KAAK,GAAG,CAHV,EAGW;AAET,MAAI,IAAI,CAAC,IAAL,IAAa,MAAjB,EAAyB;AACvB,WAAO;AACL,MAAA,MAAM,EAAE,IAAI,CAAC,YAAL,GAAoB,CADvB;AAEL,MAAA,KAAK,EAAE,OAAA,CAAA,aAAA,CAAc,CACnB,KADmB,EAEnB,IAAI,CAAC,QAFc,EAGnB,WAAW,CAAC,IAAI,CAAC,YAAN,CAHQ,CAAd;AAFF,KAAP;AAQD;;AAED,MAAI,IAAI,CAAC,IAAL,IAAa,QAAjB,EAA2B;AACzB,UAAM,YAAY,GAAG,OAAA,CAAA,aAAA,CAAc,CACjC,KADiC,EAEjC,IAAI,CAAC,SAAL,CAAgB,EAFiB,EAGjC,IAAI,CAAC,UAAL,CAAiB,EAHgB,EAIjC,WAAW,CAAC,IAAI,CAAC,SAAN,CAJsB,CAAd,CAArB;AAMA,WAAO,CACL,mBAAmB,CAAC,IAAI,CAAC,SAAN,EAAkB,YAAlB,EAAgC,KAAK,GAAG,CAAxC,CADd,EAEL,mBAAmB,CAAC,IAAI,CAAC,UAAN,EAAmB,YAAnB,EAAiC,KAAK,GAAG,CAAzC,CAFd,CAAP;AAID;;AAED,QAAM,IAAI,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,SAAgB,YAAhB,CAAsC,KAAtC,EAAgD;AAC9C,QAAM,IAAI,GAAU,EAApB;AAEA,EAAA,KAAK,CAAC,OAAN,CAAe,IAAD,IAAS;AACrB,QAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,MAAA,IAAI,CAAC,IAAL,CAAU,GAAG,YAAY,CAAC,IAAD,CAAzB;AACD,KAFD,MAEO;AACL,MAAA,IAAI,CAAC,IAAL,CAAU,IAAV;AACD;AACF,GAND;AAQA,SAAO,IAAP;AACD;;AAZD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAcA,eAAe,UAAf,CACE,IADF,EAEE,KAFF,EAEmB;AAEjB,MAAI,CAAC,KAAL,EAAY;AACV,WAAO,IAAP;AACD;;AACD,MAAI,MAAM,GAAG;AACX,IAAA,IAAI,EAAE,QADK;AAEX,IAAA,EAAE,EAAE,MAAM,IAAI,CAAC,CACb,MAAM,IAAI,CAAC,IAAI,CAAC,EAAN,CADG,EAEb,MAAM,IAAI,CAAC,KAAK,CAAC,EAAP,CAFG,EAGb,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAN,CAAZ,CAHG,CAAD,CAFH;AAOX,IAAA,SAAS,EAAE,IAAI,CAAC,YAPL;AAQX,IAAA,YAAY,EAAE,KAAK,CAAC,YART;AASX,IAAA,SAAS,EAAE,IATA;AAUX,IAAA,UAAU,EAAE;AAVD,GAAb;AAaA,SAAO,MAAP;AACD;;AAED,eAAe,IAAf,CAAoB,IAApB,EAAmD;AACjD,MAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,IAAA,IAAI,GAAG,QAAA,CAAA,OAAA,CAAQ,KAAR,CAAc,aAAd,CAA4B,IAA5B,CAAP;AACD;;AAED,SAAO,IAAI,UAAJ,CAAe,MAAM,QAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,IAAf,CAAoB,IAApB,CAArB,CAAP;AACD;;AAED,SAAgB,WAAhB,CAA4B,IAA5B,EAAwC;AACtC,QAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,SAAf,CAAf;;AAEA,OAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAP,GAAgB,CAA7B,EAAgC,CAAC,IAAI,CAArC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,QAAI,IAAI,GAAG,IAAI,GAAG,GAAlB;AACA,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,IAAZ;AACA,IAAA,IAAI,GAAG,CAAC,IAAI,GAAG,IAAR,IAAgB,GAAvB;AACD;;AAED,SAAO,MAAP;AACD;;AAVD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAYA,SAAgB,WAAhB,CAA4B,MAA5B,EAA8C;AAC5C,MAAI,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,IAAA,KAAK,IAAI,GAAT;AACA,IAAA,KAAK,IAAI,MAAM,CAAC,CAAD,CAAf;AACD;;AACD,SAAO,KAAP;AACD;;AAPD,OAAA,CAAA,WAAA,GAAA,WAAA;;AASO,MAAM,YAAY,GAAG,CAAC,CAAD,EAAwB,CAAxB,KAC1B,CAAC,CAAC,KAAF,CAAQ,CAAC,KAAD,EAAa,KAAb,KAA4B,CAAC,CAAC,KAAD,CAAD,KAAa,KAAjD,CADK;;AAAM,OAAA,CAAA,YAAA,GAAY,YAAZ;;AAGN,eAAe,YAAf,CACL,EADK,EAEL,IAFK,EAGL,SAHK,EAIL,UAJK,EAKL,IALK,EAKW;AAKhB,MAAI,UAAU,IAAI,CAAlB,EAAqB;AACnB,WAAO,KAAP;AACD;;AAED,MAAI,IAAI,IAAI,UAAZ,EAAwB;AACtB,WAAO,YAAY,CAAC,EAAD,EAAK,CAAL,EAAQ,UAAU,GAAG,CAArB,EAAwB,UAAxB,EAAoC,IAApC,CAAnB;AACD;;AAED,MAAI,IAAI,GAAG,CAAX,EAAc;AACZ,WAAO,YAAY,CAAC,EAAD,EAAK,CAAL,EAAQ,CAAR,EAAW,UAAX,EAAuB,IAAvB,CAAnB;AACD;;AAED,MAAI,IAAI,CAAC,MAAL,IAAe,SAAS,GAAG,SAA/B,EAA0C;AACxC,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,SAAd,CAAjB;AACA,UAAM,eAAe,GAAG,IAAI,CAAC,KAAL,CACtB,QAAQ,CAAC,MADa,EAEtB,QAAQ,CAAC,MAAT,GAAkB,SAFI,CAAxB;AAKA,UAAM,YAAY,GAAG,MAAM,IAAI,CAAC,CAC9B,MAAM,IAAI,CAAC,QAAD,CADoB,EAE9B,MAAM,IAAI,CAAC,eAAD,CAFoB,CAAD,CAA/B;AAIA,QAAI,MAAM,GAAG,OAAA,CAAA,YAAA,CAAa,EAAb,EAAiB,YAAjB,CAAb;;AACA,QAAI,MAAJ,EAAY;AACV,aAAO;AACL,QAAA,MAAM,EAAE,UAAU,GAAG,CADhB;AAEL,QAAA,SAAS,EAAE,SAFN;AAGL,QAAA,UAAU,EAAE,UAHP;AAIL,QAAA,SAAS,EAAE,UAAU,GAAG;AAJnB,OAAP;AAMD;;AACD,WAAO,KAAP;AACD;;AAED,QAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,SAAd,CAAb;AACA,QAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAhB,EAAwB,IAAI,CAAC,MAAL,GAAc,SAAtC,CAAd;AACA,QAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CACnB,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,MADD,EAEnB,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,MAApB,GAA6B,SAFV,CAArB;AAIA,QAAM,MAAM,GAAG,WAAW,CAAC,YAAD,CAA1B;AAEA,QAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAChB,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,MAApB,GAA6B,YAAY,CAAC,MAD1B,CAAlB;AAIA,QAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,CAC1B,MAAM,IAAI,CAAC,IAAD,CADgB,EAE1B,MAAM,IAAI,CAAC,KAAD,CAFgB,EAG1B,MAAM,IAAI,CAAC,YAAD,CAHgB,CAAD,CAA3B;;AAMA,MAAI,OAAA,CAAA,YAAA,CAAa,EAAb,EAAiB,QAAjB,CAAJ,EAAgC;AAC9B,QAAI,IAAI,GAAG,MAAX,EAAmB;AACjB,aAAO,MAAM,YAAY,CACvB,IADuB,EAEvB,IAFuB,EAGvB,SAHuB,EAIvB,IAAI,CAAC,GAAL,CAAS,UAAT,EAAqB,MAArB,CAJuB,EAKvB,SALuB,CAAzB;AAOD;;AACD,WAAO,MAAM,YAAY,CACvB,KADuB,EAEvB,IAFuB,EAGvB,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,MAApB,CAHuB,EAIvB,UAJuB,EAKvB,SALuB,CAAzB;AAOD;;AAED,SAAO,KAAP;AACD;;AAnFD,OAAA,CAAA,YAAA,GAAA,YAAA;AAqFA;;;;;AAKG;;AACI,eAAe,KAAf,CAAqB,KAArB,EAAwC,MAAM,GAAG,EAAjD,EAAmD;AACxD,MAAI,KAAK,CAAC,UAAN,GAAmB,CAAvB,EAA0B;AACxB,WAAO,MAAP;AACD;;AAED,QAAM,IAAI,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,SAAf,CAAb;AACA,QAAM,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,IAAI,CAAC,MAAjB,EAAyB,IAAI,CAAC,MAAL,GAAc,SAAvC,CAAd;AACA,QAAM,YAAY,GAAG,KAAK,CAAC,KAAN,CACnB,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,MADD,EAEnB,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,MAApB,GAA6B,SAFV,CAArB;AAIA,QAAM,MAAM,GAAG,WAAW,CAAC,YAAD,CAA1B;AAEA,QAAM,SAAS,GAAG,KAAK,CAAC,KAAN,CAChB,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,MAApB,GAA6B,YAAY,CAAC,MAD1B,CAAlB;AAIA,QAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,CAC1B,MAAM,IAAI,CAAC,IAAD,CADgB,EAE1B,MAAM,IAAI,CAAC,KAAD,CAFgB,EAG1B,MAAM,IAAI,CAAC,YAAD,CAHgB,CAAD,CAA3B;AAMA,QAAM,aAAa,GAAG,GAAG,MAAM,KAAK,MAAA,CAAA,OAAA,CAAQ,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAR,CAA0B,IAAI,MAAA,CAAA,OAAA,CAChE,MAAM,CAAC,IAAP,CAAY,KAAZ,CADgE,CAEjE,IAAI,MAAM,OAAO,MAAA,CAAA,OAAA,CAAQ,QAAR,CAAiB,EAFnC;AAIA,SAAO,KAAK,CAAC,SAAD,EAAY,aAAZ,CAAZ;AACD;;AA5BD,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;\n/**\n * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}\n */\nconst common_1 = require(\"../common\");\nconst utils_1 = require(\"./utils\");\nconst util_1 = require(\"util\");\nexports.MAX_CHUNK_SIZE = 256 * 1024;\nexports.MIN_CHUNK_SIZE = 32 * 1024;\nconst NOTE_SIZE = 32;\nconst HASH_SIZE = 32;\n/**\n * Takes the input data and chunks it into (mostly) equal sized chunks.\n * The last chunk will be a bit smaller as it contains the remainder\n * from the chunking process.\n */\nasync function chunkData(data) {\n    let chunks = [];\n    let rest = data;\n    let cursor = 0;\n    while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {\n        let chunkSize = exports.MAX_CHUNK_SIZE;\n        // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,\n        // then adjust the amount we put in this 2nd last chunk.\n        let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;\n        if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {\n            chunkSize = Math.ceil(rest.byteLength / 2);\n            // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)\n        }\n        const chunk = rest.slice(0, chunkSize);\n        const dataHash = await common_1.default.crypto.hash(chunk);\n        cursor += chunk.byteLength;\n        chunks.push({\n            dataHash,\n            minByteRange: cursor - chunk.byteLength,\n            maxByteRange: cursor,\n        });\n        rest = rest.slice(chunkSize);\n    }\n    chunks.push({\n        dataHash: await common_1.default.crypto.hash(rest),\n        minByteRange: cursor,\n        maxByteRange: cursor + rest.byteLength,\n    });\n    return chunks;\n}\nexports.chunkData = chunkData;\nasync function generateLeaves(chunks) {\n    return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange }) => {\n        return {\n            type: \"leaf\",\n            id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),\n            dataHash: dataHash,\n            minByteRange,\n            maxByteRange,\n        };\n    }));\n}\nexports.generateLeaves = generateLeaves;\n/**\n * Builds an arweave merkle tree and gets the root hash for the given input.\n */\nasync function computeRootHash(data) {\n    const rootNode = await generateTree(data);\n    return rootNode.id;\n}\nexports.computeRootHash = computeRootHash;\nasync function generateTree(data) {\n    const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));\n    return rootNode;\n}\nexports.generateTree = generateTree;\n/**\n * Generates the data_root, chunks & proofs\n * needed for a transaction.\n *\n * This also checks if the last chunk is a zero-length\n * chunk and discards that chunk and proof if so.\n * (we do not need to upload this zero length chunk)\n *\n * @param data\n */\nasync function generateTransactionChunks(data) {\n    const chunks = await chunkData(data);\n    const leaves = await generateLeaves(chunks);\n    const root = await buildLayers(leaves);\n    const proofs = await generateProofs(root);\n    // Discard the last chunk & proof if it's zero length.\n    const lastChunk = chunks.slice(-1)[0];\n    if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {\n        chunks.splice(chunks.length - 1, 1);\n        proofs.splice(proofs.length - 1, 1);\n    }\n    return {\n        data_root: root.id,\n        chunks,\n        proofs,\n    };\n}\nexports.generateTransactionChunks = generateTransactionChunks;\n/**\n * Starting with the bottom layer of leaf nodes, hash every second pair\n * into a new branch node, push those branch nodes onto a new layer,\n * and then recurse, building up the tree to it's root, where the\n * layer only consists of two items.\n */\nasync function buildLayers(nodes, level = 0) {\n    // If there are only 2 nodes left, this is going to be the root node\n    if (nodes.length < 2) {\n        const root = await hashBranch(nodes[0], nodes[1]);\n        // console.log(\"Root layer\", root);\n        return root;\n    }\n    const nextLayer = [];\n    for (let i = 0; i < nodes.length; i += 2) {\n        nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));\n    }\n    // console.log(\"Layer\", nextLayer);\n    return buildLayers(nextLayer, level + 1);\n}\nexports.buildLayers = buildLayers;\n/**\n * Recursively search through all branches of the tree,\n * and generate a proof for each leaf node.\n */\nfunction generateProofs(root) {\n    const proofs = resolveBranchProofs(root);\n    if (!Array.isArray(proofs)) {\n        return [proofs];\n    }\n    return arrayFlatten(proofs);\n}\nexports.generateProofs = generateProofs;\nfunction resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {\n    if (node.type == \"leaf\") {\n        return {\n            offset: node.maxByteRange - 1,\n            proof: utils_1.concatBuffers([\n                proof,\n                node.dataHash,\n                intToBuffer(node.maxByteRange),\n            ]),\n        };\n    }\n    if (node.type == \"branch\") {\n        const partialProof = utils_1.concatBuffers([\n            proof,\n            node.leftChild.id,\n            node.rightChild.id,\n            intToBuffer(node.byteRange),\n        ]);\n        return [\n            resolveBranchProofs(node.leftChild, partialProof, depth + 1),\n            resolveBranchProofs(node.rightChild, partialProof, depth + 1),\n        ];\n    }\n    throw new Error(`Unexpected node type`);\n}\nfunction arrayFlatten(input) {\n    const flat = [];\n    input.forEach((item) => {\n        if (Array.isArray(item)) {\n            flat.push(...arrayFlatten(item));\n        }\n        else {\n            flat.push(item);\n        }\n    });\n    return flat;\n}\nexports.arrayFlatten = arrayFlatten;\nasync function hashBranch(left, right) {\n    if (!right) {\n        return left;\n    }\n    let branch = {\n        type: \"branch\",\n        id: await hash([\n            await hash(left.id),\n            await hash(right.id),\n            await hash(intToBuffer(left.maxByteRange)),\n        ]),\n        byteRange: left.maxByteRange,\n        maxByteRange: right.maxByteRange,\n        leftChild: left,\n        rightChild: right,\n    };\n    return branch;\n}\nasync function hash(data) {\n    if (Array.isArray(data)) {\n        data = common_1.default.utils.concatBuffers(data);\n    }\n    return new Uint8Array(await common_1.default.crypto.hash(data));\n}\nfunction intToBuffer(note) {\n    const buffer = new Uint8Array(NOTE_SIZE);\n    for (var i = buffer.length - 1; i >= 0; i--) {\n        var byte = note % 256;\n        buffer[i] = byte;\n        note = (note - byte) / 256;\n    }\n    return buffer;\n}\nexports.intToBuffer = intToBuffer;\nfunction bufferToInt(buffer) {\n    let value = 0;\n    for (var i = 0; i < buffer.length; i++) {\n        value *= 256;\n        value += buffer[i];\n    }\n    return value;\n}\nexports.bufferToInt = bufferToInt;\nconst arrayCompare = (a, b) => a.every((value, index) => b[index] === value);\nexports.arrayCompare = arrayCompare;\nasync function validatePath(id, dest, leftBound, rightBound, path) {\n    if (rightBound <= 0) {\n        return false;\n    }\n    if (dest >= rightBound) {\n        return validatePath(id, 0, rightBound - 1, rightBound, path);\n    }\n    if (dest < 0) {\n        return validatePath(id, 0, 0, rightBound, path);\n    }\n    if (path.length == HASH_SIZE + NOTE_SIZE) {\n        const pathData = path.slice(0, HASH_SIZE);\n        const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);\n        const pathDataHash = await hash([\n            await hash(pathData),\n            await hash(endOffsetBuffer),\n        ]);\n        let result = exports.arrayCompare(id, pathDataHash);\n        if (result) {\n            return {\n                offset: rightBound - 1,\n                leftBound: leftBound,\n                rightBound: rightBound,\n                chunkSize: rightBound - leftBound,\n            };\n        }\n        return false;\n    }\n    const left = path.slice(0, HASH_SIZE);\n    const right = path.slice(left.length, left.length + HASH_SIZE);\n    const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n    const offset = bufferToInt(offsetBuffer);\n    const remainder = path.slice(left.length + right.length + offsetBuffer.length);\n    const pathHash = await hash([\n        await hash(left),\n        await hash(right),\n        await hash(offsetBuffer),\n    ]);\n    if (exports.arrayCompare(id, pathHash)) {\n        if (dest < offset) {\n            return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);\n        }\n        return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);\n    }\n    return false;\n}\nexports.validatePath = validatePath;\n/**\n * Inspect an arweave chunk proof.\n * Takes proof, parses, reads and displays the values for console logging.\n * One proof section per line\n * Format: left,right,offset => hash\n */\nasync function debug(proof, output = \"\") {\n    if (proof.byteLength < 1) {\n        return output;\n    }\n    const left = proof.slice(0, HASH_SIZE);\n    const right = proof.slice(left.length, left.length + HASH_SIZE);\n    const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n    const offset = bufferToInt(offsetBuffer);\n    const remainder = proof.slice(left.length + right.length + offsetBuffer.length);\n    const pathHash = await hash([\n        await hash(left),\n        await hash(right),\n        await hash(offsetBuffer),\n    ]);\n    const updatedOutput = `${output}\\n${util_1.inspect(Buffer.from(left))},${util_1.inspect(Buffer.from(right))},${offset} => ${util_1.inspect(pathHash)}`;\n    return debug(remainder, updatedOutput);\n}\nexports.debug = debug;\n//# sourceMappingURL=merkle.js.map"]},"metadata":{},"sourceType":"script"}