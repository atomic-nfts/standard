{"ast":null,"code":"import _regeneratorRuntime from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport * as bip39 from 'bip39';\nimport parseAlgorithm from './algorithm';\nimport { composePrivateKey, composePublicKey } from 'crypto-key-composer';\n\nvar composeKeys = function composeKeys(_ref, keyAlgorithm, options) {\n  var privateKey = _ref.privateKey,\n      publicKey = _ref.publicKey;\n  options = _objectSpread({\n    privateKeyFormat: 'pkcs8-pem',\n    publicKeyFormat: 'spki-pem'\n  }, options);\n  var _options = options,\n      privateKeyFormat = _options.privateKeyFormat,\n      publicKeyFormat = _options.publicKeyFormat,\n      encryptionAlgorithm = _options.encryptionAlgorithm,\n      password = _options.password;\n  return {\n    privateKey: composePrivateKey({\n      format: privateKeyFormat,\n      keyAlgorithm: keyAlgorithm,\n      keyData: privateKey,\n      encryptionAlgorithm: encryptionAlgorithm\n    }, {\n      password: password\n    }),\n    publicKey: composePublicKey({\n      format: publicKeyFormat,\n      keyAlgorithm: keyAlgorithm,\n      keyData: publicKey\n    })\n  };\n};\n\nvar generateKeys = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(seed, algorithm, options) {\n    var _parseAlgorithm, id, params, generate, keyPair, keyAlgorithm, composedKeyPair;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _parseAlgorithm = parseAlgorithm(algorithm), id = _parseAlgorithm.id, params = _parseAlgorithm.params, generate = _parseAlgorithm.generate;\n            _context.next = 3;\n            return generate(params, seed);\n\n          case 3:\n            keyPair = _context.sent;\n            keyAlgorithm = _objectSpread({\n              id: id\n            }, params);\n            composedKeyPair = composeKeys(keyPair, keyAlgorithm, options);\n            return _context.abrupt(\"return\", {\n              keyAlgorithm: keyAlgorithm,\n              composedKeyPair: composedKeyPair\n            });\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function generateKeys(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar generateKeyPair = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(algorithm, options) {\n    var mnemonic, seedBuffer, seed, _yield$generateKeys, keyAlgorithm, composedKeyPair;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            mnemonic = bip39.generateMnemonic();\n            _context2.next = 3;\n            return bip39.mnemonicToSeed(mnemonic);\n\n          case 3:\n            seedBuffer = _context2.sent;\n            seed = new Uint8Array(seedBuffer.buffer);\n            _context2.next = 7;\n            return generateKeys(seed, algorithm, options);\n\n          case 7:\n            _yield$generateKeys = _context2.sent;\n            keyAlgorithm = _yield$generateKeys.keyAlgorithm;\n            composedKeyPair = _yield$generateKeys.composedKeyPair;\n            return _context2.abrupt(\"return\", _objectSpread({\n              algorithm: keyAlgorithm,\n              mnemonic: mnemonic,\n              seed: seed\n            }, composedKeyPair));\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function generateKeyPair(_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar getKeyPairFromMnemonic = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(mnemonic, algorithm, options) {\n    var seedBuffer, seed;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return bip39.mnemonicToSeed(mnemonic);\n\n          case 2:\n            seedBuffer = _context3.sent;\n            seed = new Uint8Array(seedBuffer.buffer);\n            return _context3.abrupt(\"return\", getKeyPairFromSeed(seed, algorithm, options));\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function getKeyPairFromMnemonic(_x6, _x7, _x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar getKeyPairFromSeed = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(seed, algorithm, options) {\n    var _yield$generateKeys2, composedKeyPair;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return generateKeys(seed, algorithm, options);\n\n          case 2:\n            _yield$generateKeys2 = _context4.sent;\n            composedKeyPair = _yield$generateKeys2.composedKeyPair;\n            return _context4.abrupt(\"return\", composedKeyPair);\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function getKeyPairFromSeed(_x9, _x10, _x11) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexport { generateKeyPair, getKeyPairFromMnemonic, getKeyPairFromSeed };","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/human-crypto-keys/es/index.js"],"names":["bip39","parseAlgorithm","composePrivateKey","composePublicKey","composeKeys","keyAlgorithm","options","privateKey","publicKey","privateKeyFormat","publicKeyFormat","encryptionAlgorithm","password","format","keyData","generateKeys","seed","algorithm","id","params","generate","keyPair","composedKeyPair","generateKeyPair","mnemonic","generateMnemonic","mnemonicToSeed","seedBuffer","Uint8Array","buffer","getKeyPairFromMnemonic","getKeyPairFromSeed"],"mappings":"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","sourcesContent":["import * as bip39 from 'bip39';\nimport parseAlgorithm from './algorithm';\nimport { composePrivateKey, composePublicKey } from 'crypto-key-composer';\n\nconst composeKeys = ({\n  privateKey,\n  publicKey\n}, keyAlgorithm, options) => {\n  options = {\n    privateKeyFormat: 'pkcs8-pem',\n    publicKeyFormat: 'spki-pem',\n    ...options\n  };\n  const {\n    privateKeyFormat,\n    publicKeyFormat,\n    encryptionAlgorithm,\n    password\n  } = options;\n  return {\n    privateKey: composePrivateKey({\n      format: privateKeyFormat,\n      keyAlgorithm,\n      keyData: privateKey,\n      encryptionAlgorithm\n    }, {\n      password\n    }),\n    publicKey: composePublicKey({\n      format: publicKeyFormat,\n      keyAlgorithm,\n      keyData: publicKey\n    })\n  };\n};\n\nconst generateKeys = async (seed, algorithm, options) => {\n  const {\n    id,\n    params,\n    generate\n  } = parseAlgorithm(algorithm);\n  const keyPair = await generate(params, seed);\n  const keyAlgorithm = {\n    id,\n    ...params\n  };\n  const composedKeyPair = composeKeys(keyPair, keyAlgorithm, options);\n  return {\n    keyAlgorithm,\n    composedKeyPair\n  };\n};\n\nconst generateKeyPair = async (algorithm, options) => {\n  const mnemonic = bip39.generateMnemonic();\n  const seedBuffer = await bip39.mnemonicToSeed(mnemonic);\n  const seed = new Uint8Array(seedBuffer.buffer);\n  const {\n    keyAlgorithm,\n    composedKeyPair\n  } = await generateKeys(seed, algorithm, options);\n  return {\n    algorithm: keyAlgorithm,\n    mnemonic,\n    seed,\n    ...composedKeyPair\n  };\n};\n\nconst getKeyPairFromMnemonic = async (mnemonic, algorithm, options) => {\n  const seedBuffer = await bip39.mnemonicToSeed(mnemonic);\n  const seed = new Uint8Array(seedBuffer.buffer);\n  return getKeyPairFromSeed(seed, algorithm, options);\n};\n\nconst getKeyPairFromSeed = async (seed, algorithm, options) => {\n  const {\n    composedKeyPair\n  } = await generateKeys(seed, algorithm, options);\n  return composedKeyPair;\n};\n\nexport { generateKeyPair, getKeyPairFromMnemonic, getKeyPairFromSeed };"]},"metadata":{},"sourceType":"module"}