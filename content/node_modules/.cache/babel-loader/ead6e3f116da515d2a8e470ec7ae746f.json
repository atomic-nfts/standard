{"ast":null,"code":"import _objectSpread from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"/home/al/Desktop/koi/narcissus/content/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { PRIVATE_FORMATS, PUBLIC_FORMATS, DEFAULT_PRIVATE_FORMATS, DEFAULT_PUBLIC_FORMATS } from './formats';\nimport { validateInputKey, validateFormat, validateDecomposedKey } from './util/validator';\nimport { AggregatedError } from './util/errors';\nimport { KEY_TYPES } from './util/key-types';\n\nvar decomposeKey = function decomposeKey(supportedFormats, inputKey, options) {\n  inputKey = validateInputKey(inputKey);\n\n  if (!Array.isArray(options.format)) {\n    var format = validateFormat(options.format, supportedFormats);\n    return supportedFormats[format].decomposeKey(inputKey, options);\n  }\n\n  var formats = options.format.map(function (format) {\n    return validateFormat(format, supportedFormats);\n  }); // Attempt to decompose the keys, until one succeeds\n  // Along the way, we collect the errors for each format\n\n  var errors = {};\n  var decomposeKey;\n\n  var _iterator = _createForOfIteratorHelper(formats),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _format = _step.value;\n\n      try {\n        decomposeKey = supportedFormats[_format].decomposeKey(inputKey, options);\n        break;\n      } catch (err) {\n        // Skip if the error is marked as `invalidInputKey`\n        if (err.invalidInputKey) {\n          errors[_format] = err;\n          continue;\n        }\n\n        err.format = _format;\n        throw err;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!decomposeKey) {\n    throw new AggregatedError('No format was able to recognize the input key', errors);\n  }\n\n  return decomposeKey;\n};\n\nvar composeKey = function composeKey(supportedFormats, decomposedKey, options) {\n  decomposedKey = validateDecomposedKey(decomposedKey, supportedFormats);\n  return supportedFormats[decomposedKey.format].composeKey(decomposedKey, options);\n};\n\nexport var decomposePrivateKey = function decomposePrivateKey(inputKey, options) {\n  return decomposeKey(PRIVATE_FORMATS, inputKey, _objectSpread({\n    password: null,\n    format: DEFAULT_PRIVATE_FORMATS\n  }, options));\n};\nexport var decomposePublicKey = function decomposePublicKey(inputKey, options) {\n  return decomposeKey(PUBLIC_FORMATS, inputKey, _objectSpread({\n    password: null,\n    format: DEFAULT_PUBLIC_FORMATS\n  }, options));\n};\nexport var composePrivateKey = function composePrivateKey(decomposedKey, options) {\n  return composeKey(PRIVATE_FORMATS, decomposedKey, _objectSpread({\n    password: null\n  }, options));\n};\nexport var composePublicKey = function composePublicKey(decomposedKey) {\n  return composeKey(PUBLIC_FORMATS, decomposedKey, {});\n};\nexport var getKeyTypeFromAlgorithm = function getKeyTypeFromAlgorithm(keyAlgorithm) {\n  var keyAlgorithmId = typeof keyAlgorithm === 'string' ? keyAlgorithm : keyAlgorithm && keyAlgorithm.id;\n  return KEY_TYPES[keyAlgorithmId];\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/index.js"],"names":["PRIVATE_FORMATS","PUBLIC_FORMATS","DEFAULT_PRIVATE_FORMATS","DEFAULT_PUBLIC_FORMATS","validateInputKey","validateFormat","validateDecomposedKey","AggregatedError","KEY_TYPES","decomposeKey","supportedFormats","inputKey","options","Array","isArray","format","formats","map","errors","err","invalidInputKey","composeKey","decomposedKey","decomposePrivateKey","password","decomposePublicKey","composePrivateKey","composePublicKey","getKeyTypeFromAlgorithm","keyAlgorithm","keyAlgorithmId","id"],"mappings":"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","sourcesContent":["import { PRIVATE_FORMATS, PUBLIC_FORMATS, DEFAULT_PRIVATE_FORMATS, DEFAULT_PUBLIC_FORMATS } from './formats';\nimport { validateInputKey, validateFormat, validateDecomposedKey } from './util/validator';\nimport { AggregatedError } from './util/errors';\nimport { KEY_TYPES } from './util/key-types';\n\nconst decomposeKey = (supportedFormats, inputKey, options) => {\n  inputKey = validateInputKey(inputKey);\n\n  if (!Array.isArray(options.format)) {\n    const format = validateFormat(options.format, supportedFormats);\n    return supportedFormats[format].decomposeKey(inputKey, options);\n  }\n\n  const formats = options.format.map(format => validateFormat(format, supportedFormats)); // Attempt to decompose the keys, until one succeeds\n  // Along the way, we collect the errors for each format\n\n  const errors = {};\n  let decomposeKey;\n\n  for (const format of formats) {\n    try {\n      decomposeKey = supportedFormats[format].decomposeKey(inputKey, options);\n      break;\n    } catch (err) {\n      // Skip if the error is marked as `invalidInputKey`\n      if (err.invalidInputKey) {\n        errors[format] = err;\n        continue;\n      }\n\n      err.format = format;\n      throw err;\n    }\n  }\n\n  if (!decomposeKey) {\n    throw new AggregatedError('No format was able to recognize the input key', errors);\n  }\n\n  return decomposeKey;\n};\n\nconst composeKey = (supportedFormats, decomposedKey, options) => {\n  decomposedKey = validateDecomposedKey(decomposedKey, supportedFormats);\n  return supportedFormats[decomposedKey.format].composeKey(decomposedKey, options);\n};\n\nexport const decomposePrivateKey = (inputKey, options) => decomposeKey(PRIVATE_FORMATS, inputKey, {\n  password: null,\n  format: DEFAULT_PRIVATE_FORMATS,\n  ...options\n});\nexport const decomposePublicKey = (inputKey, options) => decomposeKey(PUBLIC_FORMATS, inputKey, {\n  password: null,\n  format: DEFAULT_PUBLIC_FORMATS,\n  ...options\n});\nexport const composePrivateKey = (decomposedKey, options) => composeKey(PRIVATE_FORMATS, decomposedKey, {\n  password: null,\n  ...options\n});\nexport const composePublicKey = decomposedKey => composeKey(PUBLIC_FORMATS, decomposedKey, {});\nexport const getKeyTypeFromAlgorithm = keyAlgorithm => {\n  const keyAlgorithmId = typeof keyAlgorithm === 'string' ? keyAlgorithm : keyAlgorithm && keyAlgorithm.id;\n  return KEY_TYPES[keyAlgorithmId];\n};"]},"metadata":{},"sourceType":"module"}