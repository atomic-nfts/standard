{"ast":null,"code":"import { PRIVATE_FORMATS, PUBLIC_FORMATS, DEFAULT_PRIVATE_FORMATS, DEFAULT_PUBLIC_FORMATS } from './formats';\nimport { validateInputKey, validateFormat, validateDecomposedKey } from './util/validator';\nimport { AggregatedError } from './util/errors';\nimport { KEY_TYPES } from './util/key-types';\n\nconst decomposeKey = (supportedFormats, inputKey, options) => {\n  inputKey = validateInputKey(inputKey);\n\n  if (!Array.isArray(options.format)) {\n    const format = validateFormat(options.format, supportedFormats);\n    return supportedFormats[format].decomposeKey(inputKey, options);\n  }\n\n  const formats = options.format.map(format => validateFormat(format, supportedFormats)); // Attempt to decompose the keys, until one succeeds\n  // Along the way, we collect the errors for each format\n\n  const errors = {};\n  let decomposeKey;\n\n  for (const format of formats) {\n    try {\n      decomposeKey = supportedFormats[format].decomposeKey(inputKey, options);\n      break;\n    } catch (err) {\n      // Skip if the error is marked as `invalidInputKey`\n      if (err.invalidInputKey) {\n        errors[format] = err;\n        continue;\n      }\n\n      err.format = format;\n      throw err;\n    }\n  }\n\n  if (!decomposeKey) {\n    throw new AggregatedError('No format was able to recognize the input key', errors);\n  }\n\n  return decomposeKey;\n};\n\nconst composeKey = (supportedFormats, decomposedKey, options) => {\n  decomposedKey = validateDecomposedKey(decomposedKey, supportedFormats);\n  return supportedFormats[decomposedKey.format].composeKey(decomposedKey, options);\n};\n\nexport const decomposePrivateKey = (inputKey, options) => decomposeKey(PRIVATE_FORMATS, inputKey, {\n  password: null,\n  format: DEFAULT_PRIVATE_FORMATS,\n  ...options\n});\nexport const decomposePublicKey = (inputKey, options) => decomposeKey(PUBLIC_FORMATS, inputKey, {\n  password: null,\n  format: DEFAULT_PUBLIC_FORMATS,\n  ...options\n});\nexport const composePrivateKey = (decomposedKey, options) => composeKey(PRIVATE_FORMATS, decomposedKey, {\n  password: null,\n  ...options\n});\nexport const composePublicKey = decomposedKey => composeKey(PUBLIC_FORMATS, decomposedKey, {});\nexport const getKeyTypeFromAlgorithm = keyAlgorithm => {\n  const keyAlgorithmId = typeof keyAlgorithm === 'string' ? keyAlgorithm : keyAlgorithm && keyAlgorithm.id;\n  return KEY_TYPES[keyAlgorithmId];\n};","map":{"version":3,"sources":["/home/al/Desktop/koi/narcissus/content/node_modules/crypto-key-composer/es/index.js"],"names":["PRIVATE_FORMATS","PUBLIC_FORMATS","DEFAULT_PRIVATE_FORMATS","DEFAULT_PUBLIC_FORMATS","validateInputKey","validateFormat","validateDecomposedKey","AggregatedError","KEY_TYPES","decomposeKey","supportedFormats","inputKey","options","Array","isArray","format","formats","map","errors","err","invalidInputKey","composeKey","decomposedKey","decomposePrivateKey","password","decomposePublicKey","composePrivateKey","composePublicKey","getKeyTypeFromAlgorithm","keyAlgorithm","keyAlgorithmId","id"],"mappings":"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","sourcesContent":["import { PRIVATE_FORMATS, PUBLIC_FORMATS, DEFAULT_PRIVATE_FORMATS, DEFAULT_PUBLIC_FORMATS } from './formats';\nimport { validateInputKey, validateFormat, validateDecomposedKey } from './util/validator';\nimport { AggregatedError } from './util/errors';\nimport { KEY_TYPES } from './util/key-types';\n\nconst decomposeKey = (supportedFormats, inputKey, options) => {\n  inputKey = validateInputKey(inputKey);\n\n  if (!Array.isArray(options.format)) {\n    const format = validateFormat(options.format, supportedFormats);\n    return supportedFormats[format].decomposeKey(inputKey, options);\n  }\n\n  const formats = options.format.map(format => validateFormat(format, supportedFormats)); // Attempt to decompose the keys, until one succeeds\n  // Along the way, we collect the errors for each format\n\n  const errors = {};\n  let decomposeKey;\n\n  for (const format of formats) {\n    try {\n      decomposeKey = supportedFormats[format].decomposeKey(inputKey, options);\n      break;\n    } catch (err) {\n      // Skip if the error is marked as `invalidInputKey`\n      if (err.invalidInputKey) {\n        errors[format] = err;\n        continue;\n      }\n\n      err.format = format;\n      throw err;\n    }\n  }\n\n  if (!decomposeKey) {\n    throw new AggregatedError('No format was able to recognize the input key', errors);\n  }\n\n  return decomposeKey;\n};\n\nconst composeKey = (supportedFormats, decomposedKey, options) => {\n  decomposedKey = validateDecomposedKey(decomposedKey, supportedFormats);\n  return supportedFormats[decomposedKey.format].composeKey(decomposedKey, options);\n};\n\nexport const decomposePrivateKey = (inputKey, options) => decomposeKey(PRIVATE_FORMATS, inputKey, {\n  password: null,\n  format: DEFAULT_PRIVATE_FORMATS,\n  ...options\n});\nexport const decomposePublicKey = (inputKey, options) => decomposeKey(PUBLIC_FORMATS, inputKey, {\n  password: null,\n  format: DEFAULT_PUBLIC_FORMATS,\n  ...options\n});\nexport const composePrivateKey = (decomposedKey, options) => composeKey(PRIVATE_FORMATS, decomposedKey, {\n  password: null,\n  ...options\n});\nexport const composePublicKey = decomposedKey => composeKey(PUBLIC_FORMATS, decomposedKey, {});\nexport const getKeyTypeFromAlgorithm = keyAlgorithm => {\n  const keyAlgorithmId = typeof keyAlgorithm === 'string' ? keyAlgorithm : keyAlgorithm && keyAlgorithm.id;\n  return KEY_TYPES[keyAlgorithmId];\n};"]},"metadata":{},"sourceType":"module"}