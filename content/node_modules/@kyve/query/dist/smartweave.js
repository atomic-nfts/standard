"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.interactRead = exports.readContract = void 0;
const index_1 = require("./index");
const core_1 = require("@kyve/core");
const extensions_1 = require("@kyve/core/dist/extensions");
const ardb_1 = __importDefault(require("ardb"));
const contract_step_1 = require("smartweave/lib/contract-step");
const utils_1 = require("smartweave/lib/utils");
const smartweave_1 = require("smartweave");
const readContract = (poolID, contractID, returnValidity, arweave = extensions_1.arweaveClient) => __awaiter(void 0, void 0, void 0, function* () {
    // load last KYVE state for this contract
    const query = new index_1.Query(poolID, false, arweave);
    const result = yield query
        .tag("Target-Contract", contractID)
        .only(["id", "tags", "tags.name", "tags.value"])
        .limit(1)
        .find();
    if (!result) {
        throw new Error("No matching transactions in pool found.");
    }
    const transaction = result[0];
    // find 'Block' tag
    const latestArchivedBlock = parseInt(transaction.tags.find((tag) => tag.name == "Block").value);
    const data = JSON.parse(yield core_1.getData(transaction.id));
    let state = data.state;
    // find txs which have not been added to state
    // get latest network height
    const networkInfo = yield arweave.network.getInfo();
    const height = networkInfo.height;
    const ardb = new ardb_1.default(arweave);
    const missingTXs = (yield ardb
        .sort("HEIGHT_ASC")
        .min(latestArchivedBlock + 1)
        .max(height)
        .tags([
        { name: "App-Name", values: ["SmartWeaveAction"] },
        { name: "Contract", values: [contractID] },
    ])
        .findAll());
    // from https://github.com/ArweaveTeam/SmartWeave/blob/master/src/contract-read.ts#L56
    // TODO: FIX ONCE https://github.com/ArweaveTeam/SmartWeave/pull/82 is merged
    yield sortTransactions(arweave, missingTXs);
    const contractInfo = yield smartweave_1.loadContract(arweave, contractID);
    const { handler, swGlobal } = contractInfo;
    const validity = {};
    for (const txInfo of missingTXs) {
        const tags = utils_1.formatTags(txInfo.node.tags);
        const currentTx = Object.assign(Object.assign({}, txInfo.node), { tags });
        let input = currentTx.tags.Input;
        // Check that input is not an array. If a tx has multiple input tags, it will be an array
        if (Array.isArray(input)) {
            console.warn(`Skipping tx with multiple Input tags - ${currentTx.id}`);
            continue;
        }
        try {
            input = JSON.parse(input);
        }
        catch (e) {
            console.log(e);
            continue;
        }
        if (!input) {
            console.log(`Skipping tx with missing or invalid Input tag - ${currentTx.id}`);
            continue;
        }
        const interaction = {
            input,
            caller: currentTx.owner.address,
        };
        swGlobal._activeTx = currentTx;
        const result = yield contract_step_1.execute(handler, interaction, state);
        if (result.type === "exception") {
            console.warn(`Executing of interaction: ${currentTx.id} threw exception.`);
            console.warn(`${result.result}`);
        }
        if (result.type === "error") {
            console.warn(`Executing of interaction: ${currentTx.id} returned error.`);
            console.warn(`${result.result}`);
        }
        validity[currentTx.id] = result.type === "ok";
        state = result.state;
    }
    return returnValidity ? { state, validity } : state;
});
exports.readContract = readContract;
const interactRead = (poolID, contractID, input, wallet, tags = [], target = "", winstonQty = "", arweave = extensions_1.arweaveClient) => __awaiter(void 0, void 0, void 0, function* () {
    const latestState = yield exports.readContract(poolID, contractID, false, arweave);
    const { handler, swGlobal } = yield smartweave_1.loadContract(arweave, contractID);
    const from = wallet ? yield arweave.wallets.getAddress(wallet) : "";
    const interaction = {
        input,
        caller: from,
    };
    const tx = yield createTx(arweave, wallet, contractID, input, tags, target, winstonQty);
    const currentBlock = yield arweave.blocks.getCurrent();
    // @ts-ignore
    swGlobal._activeTx = createDummyTx(tx, from, currentBlock);
    const result = yield contract_step_1.execute(handler, interaction, latestState);
    return result.result;
});
exports.interactRead = interactRead;
// Sort the transactions based on the sort key generated in addSortKey()
function sortTransactions(arweave, txInfos) {
    return __awaiter(this, void 0, void 0, function* () {
        const addKeysFuncs = txInfos.map((tx) => addSortKey(arweave, tx));
        yield Promise.all(addKeysFuncs);
        txInfos.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
    });
}
// Construct a string that will lexographically sort.
// { block_height, sha256(block_indep_hash + txid) }
// pad block height to 12 digits and convert hash value
// to a hex string.
function addSortKey(arweave, txInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const { node } = txInfo;
        const blockHashBytes = arweave.utils.b64UrlToBuffer(node.block.id);
        const txIdBytes = arweave.utils.b64UrlToBuffer(node.id);
        const concatted = arweave.utils.concatBuffers([blockHashBytes, txIdBytes]);
        const hashed = utils_1.arrayToHex(yield arweave.crypto.hash(concatted));
        const blockHeight = `000000${node.block.height}`.slice(-12);
        txInfo.sortKey = `${blockHeight},${hashed}`;
    });
}
function createTx(arweave, wallet, contractId, input, tags, target = "", winstonQty = "0") {
    return __awaiter(this, void 0, void 0, function* () {
        const options = {
            data: Math.random().toString().slice(-4),
        };
        if (target && target.length) {
            options.target = target.toString();
            if (winstonQty && +winstonQty > 0) {
                options.quantity = winstonQty.toString();
            }
        }
        const interactionTx = yield arweave.createTransaction(options, wallet);
        if (!input) {
            throw new Error(`Input should be a truthy value: ${JSON.stringify(input)}`);
        }
        if (tags && tags.length) {
            for (const tag of tags) {
                interactionTx.addTag(tag.name.toString(), tag.value.toString());
            }
        }
        interactionTx.addTag("App-Name", "SmartWeaveAction");
        interactionTx.addTag("App-Version", "0.3.0");
        interactionTx.addTag("Contract", contractId);
        interactionTx.addTag("Input", JSON.stringify(input));
        yield arweave.transactions.sign(interactionTx, wallet);
        return interactionTx;
    });
}
function createDummyTx(tx, from, block) {
    return {
        id: tx.id,
        owner: {
            address: from,
        },
        recipient: tx.target,
        tags: tx.tags,
        fee: {
            winston: tx.reward,
        },
        quantity: {
            winston: tx.quantity,
        },
        block: {
            id: block.indep_hash,
            height: block.height,
            timestamp: block.timestamp,
        },
    };
}
