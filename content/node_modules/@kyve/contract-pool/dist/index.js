// src/modules/deposit.ts
var Deposit = async (state, action) => {
  const credit = state.credit;
  const settings = state.settings;
  const caller = action.caller;
  const tags = SmartWeave.transaction.tags;
  const index = tags.findIndex((tag) => tag.name === "Contract" && tag.value === settings.foriegnContracts.governance);
  ContractAssert(index !== -1, "No interaction with governance contract found.");
  const input = JSON.parse(tags[index + 1].value);
  ContractAssert(input.function === "transfer" && input.target === SmartWeave.contract.id, "Invalid interaction with governance contract.");
  const validity = (await SmartWeave.contracts.readContractState(settings.foriegnContracts.governance, void 0, true)).validity;
  ContractAssert(validity[SmartWeave.transaction.id], "Invalid interaction with governance contract.");
  if (caller in credit) {
    credit[caller].amount += input.qty;
  } else {
    credit[caller] = {
      amount: input.qty,
      stake: 0,
      fund: 0,
      points: 0
    };
  }
  return {...state, credit};
};

// src/modules/fund.ts
var Fund = (state, action) => {
  const credit = state.credit;
  const caller = action.caller;
  const input = action.input;
  const qty = input.qty;
  ContractAssert(caller in credit, "Caller has no balance in the pool.");
  ContractAssert(credit[caller].amount >= qty, "Caller can't fund more than they have.");
  credit[caller].amount -= qty;
  credit[caller].fund += qty;
  return {...state, credit};
};

// src/modules/register.ts
var Register = async (state, action) => {
  const txs = state.txs;
  const settings = state.settings;
  const caller = action.caller;
  ContractAssert(caller === settings.uploader, "Only the uploader can register data.");
  const ids = [];
  const tags = await GetTags(SmartWeave.transaction.id);
  if (tags.findIndex((tag) => tag.name === "Bundle-Format" && tag.value === "json") > -1 && tags.findIndex((tag) => tag.name === "Bundle-Version" && tag.value === "1.0.0") > -1) {
    const data = JSON.parse(await SmartWeave.unsafeClient.transactions.getData(SmartWeave.transaction.id, {decode: true, string: true}));
    const items = data.items;
    items.forEach((item) => ids.push(item.id));
  } else {
    ids.push(SmartWeave.transaction.id);
  }
  for (const id of ids) {
    txs[id] = {
      status: "pending",
      submittedAt: SmartWeave.block.height,
      yays: [],
      nays: [],
      voters: []
    };
  }
  return {...state, txs};
};
var GetTags = async (txID) => {
  const res = await SmartWeave.unsafeClient.api.post("graphql", {
    query: `
      query($txID: ID!) {
        transactions(ids: [$txID]) {
          edges {
            node {
              tags {
                name
                value
              }
            }
          }
        }
      }
  `,
    variables: {txID}
  }, {headers: {"content-type": "application/json"}});
  return res.data.data.transactions.edges[0].node.tags;
};

// src/modules/stake.ts
var Stake = (state, action) => {
  const credit = state.credit;
  const caller = action.caller;
  const input = action.input;
  const qty = input.qty;
  ContractAssert(caller in credit, "Caller has no balance in the pool.");
  ContractAssert(credit[caller].amount >= qty, "Caller can't stake more than they have.");
  credit[caller].amount -= qty;
  credit[caller].stake += qty;
  return {...state, credit};
};

// ../../node_modules/prando/dist/Prando.es.js
var Prando = function() {
  function Prando2(seed) {
    this._value = NaN;
    if (typeof seed === "string") {
      this._seed = this.hashCode(seed);
    } else if (typeof seed === "number") {
      this._seed = this.getSafeSeed(seed);
    } else {
      this._seed = this.getSafeSeed(Prando2.MIN + Math.floor((Prando2.MAX - Prando2.MIN) * Math.random()));
    }
    this.reset();
  }
  Prando2.prototype.next = function(min, pseudoMax) {
    if (min === void 0) {
      min = 0;
    }
    if (pseudoMax === void 0) {
      pseudoMax = 1;
    }
    this.recalculate();
    return this.map(this._value, Prando2.MIN, Prando2.MAX, min, pseudoMax);
  };
  Prando2.prototype.nextInt = function(min, max) {
    if (min === void 0) {
      min = 10;
    }
    if (max === void 0) {
      max = 100;
    }
    this.recalculate();
    return Math.floor(this.map(this._value, Prando2.MIN, Prando2.MAX, min, max + 1));
  };
  Prando2.prototype.nextString = function(length, chars) {
    if (length === void 0) {
      length = 16;
    }
    if (chars === void 0) {
      chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    }
    var str = "";
    while (str.length < length) {
      str += this.nextChar(chars);
    }
    return str;
  };
  Prando2.prototype.nextChar = function(chars) {
    if (chars === void 0) {
      chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    }
    return chars.substr(this.nextInt(0, chars.length - 1), 1);
  };
  Prando2.prototype.nextArrayItem = function(array) {
    return array[this.nextInt(0, array.length - 1)];
  };
  Prando2.prototype.nextBoolean = function() {
    this.recalculate();
    return this._value > 0.5;
  };
  Prando2.prototype.skip = function(iterations) {
    if (iterations === void 0) {
      iterations = 1;
    }
    while (iterations-- > 0) {
      this.recalculate();
    }
  };
  Prando2.prototype.reset = function() {
    this._value = this._seed;
  };
  Prando2.prototype.recalculate = function() {
    this._value = this.xorshift(this._value);
  };
  Prando2.prototype.xorshift = function(value) {
    value ^= value << 13;
    value ^= value >> 17;
    value ^= value << 5;
    return value;
  };
  Prando2.prototype.map = function(val, minFrom, maxFrom, minTo, maxTo) {
    return (val - minFrom) / (maxFrom - minFrom) * (maxTo - minTo) + minTo;
  };
  Prando2.prototype.hashCode = function(str) {
    var hash = 0;
    if (str) {
      var l = str.length;
      for (var i = 0; i < l; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
        hash = this.xorshift(hash);
      }
    }
    return this.getSafeSeed(hash);
  };
  Prando2.prototype.getSafeSeed = function(seed) {
    if (seed === 0)
      return 1;
    return seed;
  };
  Prando2.MIN = -2147483648;
  Prando2.MAX = 2147483647;
  return Prando2;
}();
var Prando_es_default = Prando;

// src/modules/submit.ts
var Submit = async (state, action) => {
  const credit = state.credit;
  const txs = state.txs;
  const foreignCalls = state.foreignCalls;
  const settings = state.settings;
  const voters = Object.entries(credit).filter(([key, value]) => value.stake && key !== settings.uploader).map(([key, value]) => key);
  const caller = action.caller;
  ContractAssert(voters.includes(caller), "Caller has no stake in the pool.");
  const data = JSON.parse(await SmartWeave.unsafeClient.transactions.getData(SmartWeave.transaction.id, {decode: true, string: true}));
  for (const {txID, valid} of data) {
    ContractAssert(!(txs[txID].yays.includes(caller) || txs[txID].nays.includes(caller)), "Caller has already voted.");
    ContractAssert(SmartWeave.block.height <= txs[txID].submittedAt + 2 * settings.gracePeriod, "Transaction has been dropped.");
    if (txs[txID].closesAt) {
      ContractAssert(SmartWeave.block.height <= txs[txID].closesAt, "Grace period has ended.");
    } else {
      txs[txID].closesAt = SmartWeave.block.height + settings.gracePeriod;
    }
    if (valid)
      txs[txID].yays.push(caller);
    else
      txs[txID].nays.push(caller);
    txs[txID].voters = voters;
  }
  const unhandledTxs = Object.entries(txs).sort((a, b) => a[1].closesAt - b[1].closesAt).filter(([key, value]) => value.status === "pending" && (SmartWeave.block.height > value.closesAt || SmartWeave.block.height > value.submittedAt + 2 * settings.gracePeriod));
  for (const [txID, data2] of unhandledTxs) {
    if (data2.yays.length + data2.nays.length > 0.5 * data2.voters.length) {
      const bytes = await GetBytes(txID);
      const tokens = Round(settings.payout.kyvePerByte * bytes + settings.payout.idleCost);
      if (tokens > Object.entries(credit).map(([key, value]) => value.fund).reduce((a, b) => a + b, 0)) {
        settings.paused = true;
        continue;
      }
      let tempAmount = tokens;
      for (const address of Object.keys(credit)) {
        if (tempAmount <= credit[address].fund) {
          credit[address].fund -= tempAmount;
          break;
        } else {
          tempAmount -= credit[address].fund;
          credit[address].fund = 0;
        }
      }
      const governancePayout = Round(tokens * 0.01);
      const holder = await RandomHolder(settings.foriegnContracts.governance, settings.foriegnContracts.treasury);
      foreignCalls.push({
        txID: `${SmartWeave.transaction.id}//${foreignCalls.length}`,
        contract: settings.foriegnContracts.governance,
        input: {
          function: "transfer",
          target: holder,
          qty: governancePayout
        }
      });
      const treasuryPayout = Round(tokens * 0.01);
      foreignCalls.push({
        txID: `${SmartWeave.transaction.id}//${foreignCalls.length}`,
        contract: settings.foriegnContracts.governance,
        input: {
          function: "transfer",
          target: settings.foriegnContracts.treasury,
          qty: treasuryPayout
        }
      });
      const uploaderPayout = Round(tokens * 0.68);
      credit[settings.uploader].amount += uploaderPayout;
      const validatorsPayout = tokens - governancePayout - treasuryPayout - uploaderPayout;
      for (const address of [...data2.yays, ...data2.nays]) {
        credit[address].amount += Round(validatorsPayout / (data2.yays.length + data2.nays.length));
      }
      if (data2.yays.length >= data2.nays.length) {
        txs[txID].status = "valid";
        for (const address of data2.voters.filter((item) => data2.yays.indexOf(item) === -1)) {
          credit[address].points += 1;
        }
      } else {
        txs[txID].status = "invalid";
        credit[settings.uploader].points += 1;
        for (const address of data2.voters.filter((item) => data2.nays.indexOf(item) === -1)) {
          credit[address].points += 1;
        }
      }
    } else {
      txs[txID].status = "dropped";
    }
    txs[txID].finalizedAt = SmartWeave.block.height;
  }
  const unhandledSlashing = Object.entries(credit).filter(([key, value]) => value.points > settings.slashThreshold);
  let totalSlashed = 0;
  for (const [address, data2] of unhandledSlashing) {
    totalSlashed += credit[address].stake;
    credit[address].points = 0;
    credit[address].stake = 0;
    if (address === settings.uploader) {
      settings.uploader = "";
      settings.paused = true;
    }
  }
  if (totalSlashed) {
    foreignCalls.push({
      txID: `${SmartWeave.transaction.id}//${foreignCalls.length}`,
      contract: settings.foriegnContracts.governance,
      input: {
        function: "transfer",
        target: settings.foriegnContracts.treasury,
        qty: totalSlashed
      }
    });
  }
  return {...state, credit, txs, foreignCalls, settings};
};
var GetBytes = async (txID) => {
  const res = await SmartWeave.unsafeClient.api.post("graphql", {
    query: `
      query($txID: ID!) {
        transactions(ids: [$txID]) {
          edges {
            node {
              data {
                size
              }
            }
          }
        }
      }
  `,
    variables: {txID}
  }, {headers: {"content-type": "application/json"}});
  return res.data.data.transactions.edges[0].node.data.size;
};
var Round = (input) => {
  return Math.floor(input * 10 ** 12) / 10 ** 12;
};
var RandomHolder = async (governance, treasury) => {
  const state = await SmartWeave.contracts.readContractState(governance);
  const balances = state.balances;
  const vault = state.vault;
  let totalTokens = 0;
  for (const addr of Object.keys(balances)) {
    totalTokens += balances[addr];
  }
  for (const addr of Object.keys(vault)) {
    if (!vault[addr].length)
      continue;
    const vaultBalance = vault[addr].map((a) => a.balance).reduce((a, b) => a + b, 0);
    totalTokens += vaultBalance;
    if (addr in balances) {
      balances[addr] += vaultBalance;
    } else {
      balances[addr] = vaultBalance;
    }
  }
  const weighted = {};
  for (const addr of Object.keys(balances)) {
    weighted[addr] = balances[addr] / totalTokens;
  }
  let sum = 0;
  const r = new Prando_es_default(SmartWeave.transaction.id).next();
  for (const key of Object.keys(weighted)) {
    sum += weighted[key];
    if (r <= sum && weighted[key] > 0) {
      return key;
    }
  }
  return treasury;
};

// src/modules/unfund.ts
var Unfund = (state, action) => {
  const credit = state.credit;
  const caller = action.caller;
  const input = action.input;
  const qty = input.qty;
  ContractAssert(caller in credit, "Caller has no balance in the pool.");
  ContractAssert(credit[caller].fund >= qty, "Caller can't unfund more than they have.");
  credit[caller].fund -= qty;
  credit[caller].amount += qty;
  return {...state, credit};
};

// src/modules/unstake.ts
var Unstake = (state, action) => {
  const credit = state.credit;
  const caller = action.caller;
  const input = action.input;
  const qty = input.qty;
  ContractAssert(caller in credit, "Caller has no balance in the pool.");
  ContractAssert(credit[caller].stake >= qty, "Caller can't unstake more than they have.");
  credit[caller].amount += qty;
  credit[caller].stake -= qty;
  return {...state, credit};
};

// src/modules/update.ts
var Update = (state, action) => {
  const caller = action.caller;
  const input = action.input;
  const settings = input.settings || state.settings;
  const config = input.config || state.config;
  ContractAssert(state.settings.admins.includes(caller), "Only admins can invoke this function.");
  return {
    ...state,
    settings,
    config
  };
};

// src/modules/updateContracts.ts
var UpdateContracts = (state, action) => {
  const contracts = state.settings.foriegnContracts;
  const caller = action.caller;
  const input = action.input;
  const governance = input.governance;
  const treasury = input.treasury;
  ContractAssert(caller === contracts.governance, "Only the governance can invoke this function.");
  if (governance)
    contracts.governance = governance;
  if (treasury)
    contracts.treasury = treasury;
  return {
    ...state,
    settings: {...state.settings, foriegnContracts: contracts}
  };
};

// src/modules/withdraw.ts
var Withdraw = (state, action) => {
  const credit = state.credit;
  const foreignCalls = state.foreignCalls;
  const settings = state.settings;
  const caller = action.caller;
  const input = action.input;
  const qty = input.qty;
  ContractAssert(caller in credit, "Caller is not in the pool.");
  ContractAssert(qty, "Invalid quantity specified.");
  ContractAssert(credit[caller].amount >= qty, "Caller does not have enough balance.");
  foreignCalls.push({
    txID: SmartWeave.transaction.id,
    contract: settings.foriegnContracts.governance,
    input: {
      function: "transfer",
      target: caller,
      qty
    }
  });
  credit[caller].amount -= qty;
  return {...state, credit, foreignCalls};
};

// src/index.ts
export async function handle(state, action) {
  switch (action.input.function) {
    case "deposit":
      return {state: await Deposit(state, action)};
    case "withdraw":
      return {state: Withdraw(state, action)};
    case "fund":
      return {state: Fund(state, action)};
    case "unfund":
      return {state: Unfund(state, action)};
    case "stake":
      return {state: Stake(state, action)};
    case "unstake":
      return {state: Unstake(state, action)};
    case "register":
      return {state: await Register(state, action)};
    case "submit":
      return {state: await Submit(state, action)};
    case "update":
      return {state: Update(state, action)};
    case "updateContracts":
      return {state: UpdateContracts(state, action)};
  }
}
