import { Common, Vote } from "./common";
import { JWKInterface } from "arweave/node/lib/wallet";
import Datastore from "nedb-promises";
import { RedisClient } from "redis";
export declare const URL_GATEWAY_LOGS = "https://gateway.koi.rocks/logs";
export declare class Node extends Common {
    db?: Datastore;
    totalVoted: number;
    receipts: Array<any>;
    redisClient?: RedisClient;
    /**
     * Asynchronously load a wallet from a UTF8 JSON file
     * @param file Path of the file to be loaded
     * @returns JSON representation of the object
     */
    loadFile(file: string): Promise<any>;
    /**
     * Loads wallet for node Simulator key from file path and initialize ndb.
     * @param walletFileLocation Wallet key file location
     * @returns Key as an object
     */
    nodeLoadWallet(walletFileLocation: string): Promise<JWKInterface | undefined>;
    /**
     * Submit vote to bundle server or direct to contract
     * @param arg Object with direct, voteId, and useVote
     * @returns Transaction ID
     */
    vote(arg: Vote): Promise<any>;
    /**
     * propose a tafficLog for vote
     * @param arg
     * @returns object arg.gateway(trafficlog orginal gateway id) and arg.stakeAmount(min required stake to vote)
     */
    submitTrafficLog(arg: any): Promise<string>;
    /**
     * Triggers proposal rank in contract
     * @returns Transaction ID
     */
    rankProposal(): Promise<string>;
    /**
     * Interact with contract to add the votes
     * @param arg Batch data
     * @returns Transaction ID
     */
    batchAction(arg: any): Promise<string>;
    /**
     * Propose a stake slashing
     * @returns
     */
    proposeSlash(): Promise<void>;
    /**
     * Triggers distribute reward function
     * @returns Transaction ID
     */
    distributeDailyRewards(): Promise<string>;
    /**
     * Validate traffic log by comparing traffic log from gateway and arweave storage
     * @param voteId Vote id which is belongs for specific proposalLog
     * @returns Whether data is valid
     */
    validateData(voteId: number): Promise<boolean | null>;
    /**
     * Loads redis client
     */
    loadRedisClient(): void;
    /**
     * Recalculates the predicted state based on the pending transactions
     * @param wallet
     * @param latestContractState
     * @param redisClient
     * @returns
     */
    recalculatePredictedState(wallet: any, latestContractState: any, redisClient: any): Promise<any>;
    /**
     * internal function, writes to contract. Used explicitly for signed transaction received from UI, uses redis
     * @param txId
     * @param owner
     * @param tx
     * @param state
     * @returns
     */
    registerDataDryRun(txId: any, owner: any, tx: any, state: any, contract: any): Promise<any>;
    /**
     * Store data in Redis async
     * @param key Redis key of data
     * @param value String to store in redis
     * @returns
     */
    redisSetAsync(key: any, value: string): Promise<void>;
    /**
     * Get data from Redis async
     * @param key Redis key of data
     * @returns Data as a string, null if no such key exists
     */
    redisGetAsync(key: any): Promise<string | null>;
    /**
     * Gets the contract state from kyve
     * @returns Promise containing the state
     */
    kyveGetContractState(): Promise<any>;
    /**
     * internal function, writes to contract. Overrides common._interactWrite, uses redis
     * @param input
     * @returns Transaction ID
     */
    protected _interactWrite(input: any): Promise<string>;
    /**
     * Read contract latest state
     * @returns Contract
     */
    protected _readContract(): Promise<any>;
    /**
     * Read the data and update
     * @returns Database document ID
     */
    private _db;
    /**
     * Get the latest state
     * @returns  Active vote Id
     */
    private _activeVote;
    /**
     * Submits a payload to server
     * @param payload Payload to be submitted
     * @returns Result as a promise
     */
    private _bundlerNode;
    /**
     * Get traffic logs from gateway
     * @param path Gateway url
     * @returns Result as a promise
     */
    private _getTrafficLogFromGateWay;
    /**
     *
     * @param gateWayUrl
     * @returns
     */
    private _storeTrafficLogOnArweave;
    /**
     * Read contract latest state
     * @param data Data to be hashed
     * @returns Hex string
     */
    private _hashData;
    /**
     *
     * @param redisClient
     * @returns
     */
    private _checkPendingTransactionStatus;
}
