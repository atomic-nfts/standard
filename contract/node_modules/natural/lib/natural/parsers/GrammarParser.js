module.exports=Grammar = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { grammar: peg$parsegrammar },
        peg$startRuleFunction  = peg$parsegrammar,

        peg$c0 = [],
        peg$c1 = peg$FAILED,
        peg$c2 = function(rules) {
           grammar = new Grammar();
           for (var i = 0; i < rules.length; i++) {
             grammar.production_rules.push(rules[i][1]);
           }
           grammar.start_symbol = grammar.production_rules[0].lhs;
           grammar.nonterminals = nonterminals;
           grammar.is_CNF = is_CNF;
           grammar.symbols = symbols;
           return(grammar);
          },
        peg$c3 = function(rule, cseq) {
           if (cseq) {
             rule.constraints = cseq;
           }
           return(rule);
          },
        peg$c4 = null,
        peg$c5 = function(lhs, rhs_1, head, rhs_2) {
           var rhs = [];
           var head_pos = 0;

           rhs = rhs_1;
           if (head) {
             head_pos = rhs_1.length;
             rhs.push(head[1]);
           }
           rhs = rhs.concat(rhs_2);
           rhs.forEach(function(symbol) {
             symbols[symbol] = true;
           });
           var rule = new Rule(lhs, rhs, head_pos);
           nonterminals[lhs] = true;
           symbols[lhs] = true;
           if ((rule.rhs.length > 2) || (rule.rhs.length === 0)) {
             is_CNF = false;
           }
           return(rule);
          },
        peg$c6 = function(nt) {
           return(nt);
          },
        peg$c7 = function(path, atom) {
           var constraint = new Constraint(path, atom);
           return(constraint);
          },
        peg$c8 = function(path1, path2) {
           var constraint = new Constraint(path1, path2);
           return(constraint);
          },
        peg$c9 = function(idseq) {
           return(idseq);
          },
        peg$c10 = /^[a-zA-Z_0-9]/,
        peg$c11 = { type: "class", value: "[a-zA-Z_0-9]", description: "[a-zA-Z_0-9]" },
        peg$c12 = function(characters) {
           var s = "";
           for (var i = 0; i < characters.length; i++) {
             s += characters[i];
           }
           return(s);
          },
        peg$c13 = /^[a-zA-Z_0-9$]/,
        peg$c14 = { type: "class", value: "[a-zA-Z_0-9$]", description: "[a-zA-Z_0-9$]" },
        peg$c15 = "->",
        peg$c16 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c17 = "<",
        peg$c18 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c19 = ">",
        peg$c20 = { type: "literal", value: ">", description: "\">\"" },
        peg$c21 = "=",
        peg$c22 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c23 = "*",
        peg$c24 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c25 = "\r\n",
        peg$c26 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
        peg$c27 = "\n",
        peg$c28 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c29 = "\r",
        peg$c30 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c31 = "//",
        peg$c32 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c33 = void 0,
        peg$c34 = { type: "any", description: "any character" },
        peg$c35 = " ",
        peg$c36 = { type: "literal", value: " ", description: "\" \"" },
        peg$c37 = "\t",
        peg$c38 = { type: "literal", value: "\t", description: "\"\\t\"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsegrammar() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parseS();
      if (s3 !== peg$FAILED) {
        s4 = peg$parseproduction_rule();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseS();
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c1;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c1;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c1;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parseS();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseproduction_rule();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseS();
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c1;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c1;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c1;
          }
        }
      } else {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c2(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseproduction_rule() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parserule();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseconstraint();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseconstraint();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c3(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parserule() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parsenonterminal();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseArrow();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseidentifier_no_eol();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseidentifier_no_eol();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parseHeadIndicator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseidentifier_no_eol();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseHeadIndicator();
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c1;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c1;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c1;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c4;
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseidentifier_no_eol();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseidentifier_no_eol();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseEOL();
                if (s6 === peg$FAILED) {
                  s6 = peg$parseEOI();
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c5(s1, s3, s4, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsenonterminal() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseconstraint() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsefeature_path();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEqual();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseidentifier();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c7(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsefeature_path();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEqual();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsefeature_path();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c8(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      }

      return s0;
    }

    function peg$parsefeature_path() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsePathOpen();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier_seq();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePathClose();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c9(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseidentifier_seq() {
      var s0, s1;

      s0 = [];
      s1 = peg$parseidentifier();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseidentifier();
      }

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c10.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
        }
      } else {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c12(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseidentifier_no_eol() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c13.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c13.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
        }
      } else {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS_no_eol();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c12(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseArrow() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c15) {
        s1 = peg$c15;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS_no_eol();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsePathOpen() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 60) {
        s1 = peg$c17;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parsePathClose() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 62) {
        s1 = peg$c19;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseEqual() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c21;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseHeadIndicator() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c23;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseS_no_eol();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseEOL() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c25) {
        s0 = peg$c25;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c27;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c29;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
        }
      }

      return s0;
    }

    function peg$parseComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c31) {
        s1 = peg$c31;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseEOL();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c33;
        } else {
          peg$currPos = s4;
          s4 = peg$c1;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c1;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseEOL();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c33;
          } else {
            peg$currPos = s4;
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c34); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c1;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseEOL();
          if (s3 === peg$FAILED) {
            s3 = peg$parseEOI();
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }

    function peg$parseS() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s1 = peg$c37;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$parseEOL();
          if (s1 === peg$FAILED) {
            s1 = peg$parseComment();
          }
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 9) {
            s1 = peg$c37;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$parseEOL();
            if (s1 === peg$FAILED) {
              s1 = peg$parseComment();
            }
          }
        }
      }

      return s0;
    }

    function peg$parseS_no_eol() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s1 = peg$c37;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$parseComment();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 9) {
            s1 = peg$c37;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$parseComment();
          }
        }
      }

      return s0;
    }

    function peg$parseEOI() {
      var s0, s1;

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = peg$c33;
      } else {
        peg$currPos = s0;
        s0 = peg$c1;
      }

      return s0;
    }


      var is_CNF = true;
      var nonterminals = {};
      var symbols = {};

      function Atom(val) {
        this.atom = val;
      }

      function Path(ids) {
        this.path = ids;
      }

      function Rule(lhs, rhs, head) {
       this.lhs = lhs;
       this.rhs = rhs;
       this.head = head;
      }

      function Constraint(left_op, right_op) {
        this.left = left_op;
        this.right = right_op;
      }

    function Grammar() {
      this.production_rules = [];
      this.nonterminals = {};
      this.symbols = {};
      this.start_symbol = "";
      this.is_CNF = true;
    }

    //Checks if B is a nonterminal
    Grammar.prototype.is_nonterminal = function(B) {
      console.log("Checking if " + B + " is a nonterminal: " + this.nonterminals[B]);
      return (this.nonterminals[B]);
    };

    //Checks if B is a (pre)terminal
    Grammar.prototype.is_terminal = function(B) {
      console.log("Checking if " + B + " is a (pre)terminal: " + !this.nonterminals[B]);
      return (!this.nonterminals[B]);
    };

    // Looks up all rules with lhs B
    Grammar.prototype.rules_with_lhs = function(B) {
      var rules = [];
      
      this.production_rules.forEach(function(rule) {
        if (rule.lhs === B) {
          rules.push(rule);
        }
      });
      return(rules);
    };

    // Returns the start production rule which is the first rule read from file
    Grammar.prototype.start_rule = function() {
      return(this.production_rules[0]);
    };

    // Returns the start symbol
    Grammar.prototype.get_start_symbol = function() {
      return(this.start_symbol);
    };

    // Returns all rules that match right hand side nonterminals s and t
    Grammar.prototype.get_rules_with_rhs = function(s, t) {
      var res = [];
      
      this.production_rules.forEach(function(rule) {
        if ((rule.rhs.length === 2) && (rule.rhs[0] === s) && (rule.rhs[1] === t)) {
          res.push(rule);
        }
      });
      return res;
    };

    // Based on: http://folk.uio.no/plison/pdfs/lectures/compling2010/pdfs/compling2010-parsingcfg-solutions.pdf
    Grammar.prototype.compute_lc_relation = function() {
      that = this;
      // Compute the first order lc relation
      this.lc = {};
      this.production_rules.forEach(function(rule) {
        if (!that.lc[rule.lhs]) {
          that.lc[rule.lhs] = {};
        }
        if (that.is_nonterminal(rule.rhs[0])) {
          that.lc[rule.lhs][rule.rhs[0]] = true;
        }
      });
      // Reflexive closure
      Object.keys(this.nonterminals).forEach(function(A){
        if (!that.lc[A]) {
          that.lc[A] = {};
        }
        that.lc[A][A] = true;
      });
      // Transitive closure
      var changed;
      do {
        changed = false;
        Object.keys(this.nonterminals).forEach(function(A) {
          Object.keys(that.lc[A]).forEach(function(B) {
            Object.keys(that.lc[B]).forEach(function(C) {
              if (!that.lc[A][C]) {
                // add all left corners of C to A
                Object.keys(that.lc[C]).forEach(function(D){
                  that.lc[A][D] = true;
                  changed = true;
                });
              }
            });
          });
        });
      } while (changed);
    };

    Grammar.prototype.rules_with_leftmost_daughter = function (B) {
      rules = [];

      this.production_rules.forEach(function(rule) {
        if (rule.rhs[0] === B) {
          rules.push(rule);
        }
      });
      return(rules);
    };

    Grammar.prototype.is_leftcorner_of = function(B, C) {
      if (this.lc[C]) {
        return(this.lc[C][B]);
      }
      else {
        return(false);
      }
    };

    // Check if nonterminal A is head-corner of nonterminal B
    Grammar.prototype.is_headcorner_of = function(A, B) {
      if (this.hc[B]) {
        return(this.hc[B][A]);
      }
      else {
        return(false);
      }
    }
     
    // Get rules with nonterminal H as head
    Grammar.prototype.get_rules_with_head = function(H) {
      var res = [];

      this.production_rules.forEach(function(rule) {
        if (rule.rhs[rule.head] === H) {
          res.push(rule);
        }
      });
      return(res);
    };

    // Computation of the head-corner relation follows the pattern of the 
    // computation of the lef-corner relation
    Grammar.prototype.compute_hc_relation = function() {
      that = this;
      // Compute the first order hc relation
      this.hc = {};
      this.production_rules.forEach(function(rule) {
        if (!that.hc[rule.lhs]) {
          that.hc[rule.lhs] = {};
        }
        that.hc[rule.lhs][rule.rhs[rule.head]] = true;
      });
      // Reflexive closure
      Object.keys(this.symbols).forEach(function(A){
        if (!that.hc[A]) {
          that.hc[A] = {};
        }
        that.hc[A][A] = true;
      });
      // Transitive closure
      var changed;
      do {
        changed = false;
        Object.keys(this.symbols).forEach(function(A) {
          Object.keys(that.hc[A]).forEach(function(B) {
            Object.keys(that.hc[B]).forEach(function(C) {
              if (!that.hc[A][C]) {
                // add all head corners of C to A
                Object.keys(that.hc[C]).forEach(function(D){
                  that.hc[A][D] = true;
                  changed = true;
                });
              }
            });
          });
        });
      } while (changed);
    };



    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();
